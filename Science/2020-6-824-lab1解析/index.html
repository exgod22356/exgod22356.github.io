<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>2020 6.824 lab1解析 - Icarus</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#f7f7f7"><meta name="application-name" content="Icaurs - Hexo Theme"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="msapplication-TileColor" content="#f7f7f7"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Icaurs - Hexo Theme"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前置知识： go    linux    2020 6.824 lab1解析前言  本系列主要是对mit课程6.824的lab进行解析，包括部分原理的讲解以及代码的实现。主要使用go来进行编写。本文讲解的是lab1，根据给定的代码框架来实现MapReduce结构。"><meta property="og:type" content="blog"><meta property="og:title" content="2020 6.824 lab1解析"><meta property="og:url" content="https://exgod22356.github.com/Science/2020-6-824-lab1%E8%A7%A3%E6%9E%90/"><meta property="og:site_name" content="Icarus"><meta property="og:description" content="前置知识： go    linux    2020 6.824 lab1解析前言  本系列主要是对mit课程6.824的lab进行解析，包括部分原理的讲解以及代码的实现。主要使用go来进行编写。本文讲解的是lab1，根据给定的代码框架来实现MapReduce结构。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://exgod22356.github.com/img/og_image.png"><meta property="article:published_time" content="2020-08-10T11:10:30.000Z"><meta property="article:author" content="王钦砚"><meta property="article:tag" content="编程"><meta property="article:tag" content="开发"><meta property="article:tag" content="分布式"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://exgod22356.github.com/Science/2020-6-824-lab1%E8%A7%A3%E6%9E%90/"},"headline":"Icarus","image":["https://exgod22356.github.com/img/og_image.png"],"datePublished":"2020-08-10T11:10:30.000Z","author":{"@type":"Person","name":"王钦砚"},"description":"前置知识： go    linux    2020 6.824 lab1解析前言  本系列主要是对mit课程6.824的lab进行解析，包括部分原理的讲解以及代码的实现。主要使用go来进行编写。本文讲解的是lab1，根据给定的代码框架来实现MapReduce结构。"}</script><link rel="canonical" href="https://exgod22356.github.com/Science/2020-6-824-lab1%E8%A7%A3%E6%9E%90/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Icarus" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Gitter" href="https://gitter.im/"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exgod22356/exgod22356.github.io"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-08-10T11:10:30.000Z" title="2020-08-10T11:10:30.000Z">2020-08-10</time></span><span class="level-item"><a class="link-muted" href="/categories/Science/">Science</a></span><span class="level-item">32 minutes read (About 4813 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">2020 6.824 lab1解析</h1><div class="content"><h3 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h3><ul>
<li>go   </li>
<li>linux  </li>
</ul>
<h1 id="2020-6-824-lab1解析"><a href="#2020-6-824-lab1解析" class="headerlink" title="2020 6.824 lab1解析"></a>2020 6.824 lab1解析</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  本系列主要是对mit课程6.824的lab进行解析，包括部分原理的讲解以及代码的实现。主要使用go来进行编写。本文讲解的是lab1，根据给定的代码框架来实现MapReduce结构。   </p>
<a id="more"></a>   
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>  6.824是mit的分布式系统课程，而该课程的实验也就是lab目的为通过给定的代码框架来实现通用的分布式系统。该课程lab在2020年进行了部分更新，例如本次的lab1就进行了大改，与前几年几乎完全不同，因此以往网络上的各路教程也就过时了。详细课程资源可以到<a target="_blank" rel="noopener" href="http://pdos.csail.mit.edu/6.824/">6.824官方网站</a>进行查看。<br>  本文的lab1实现的是MapReduce架构，作为谷歌在2003年发表的论文，为现在的分布式计算思想提供了很明确的方向。它继承于函数式编程的思想，并且在谷歌内部真正进行了实现与运用。本文便根据给定的代码框架以及论文思想，来实现这么一个模型。   </p>
<h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><p>  MapReduce如上文所说，源于函数式编程思想，简单来说Map对应“映射”，Reduce对应“归约”，前者将数据切分从而映射到键值对（key-value对）组，后者将键值对组进行整理归纳，并整合到输出文件。该算法的优势在于优秀的并行化，可以使用多台计算机来应对计算规模的增加，从而节省时间。<br>  但在具体原理上，我们还需要阅读<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">谷歌发表的那篇论文</a>从而了解更多细节。该论文写的很好，在实现细节不理解的情况下建议多读几遍。但在这里还是简述一下论文的观点。<br>  论文中提供了编程模型的实现：通过master机器来统筹工作，通过worker机器来进行具体的map或者reduce工作。master给worker分配map或者reduce工作，worker接收到map工作时便读取对应数据，执行map工作，将map完成后的键值对组存于磁盘，并且通知master完成工作。当master了解到所有map工作完成后，便通知worker进行reduce工作。worker接收到指令后便读取磁盘上的对应键值对。然后通常先对键值对组进行排序，然后进行reduce工作，并存于输出文件中。同样，在master了解到所有文件已经reduce完成后便可以进行退出。<br>  下面本文的实验也将基于上述模型来实现。   </p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>  进入<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">lab1官网</a>，官网的准备工作说的相当清楚。要准备linux环境，go环境，然后下载实验文件。这里需要一些基本的linux知识，不过官网已经将步骤给的相当清楚了。再次不过多赘述。   </p>
<h3 id="实验目标与流程"><a href="#实验目标与流程" class="headerlink" title="实验目标与流程"></a>实验目标与流程</h3><p>  从官网可以看到，lab1的实验目标是完成mr文件夹中的master.go rpc.go worker.go三个文件，并且在main文件夹中通过mrmaster.go来创建一个master，通过执行多次mrworker.go来创建多个worker来运行。同时实验也给定了一个串行的结果正确的文件mrsequential.go，可以来参考以及改bug。在实验最后，我们需要对写好的文件进行测试。文件给了我们一个shell脚本test-mr.sh，该脚本会执行真正的应用程序以及给定各种实验场景，我们的目标是通过该测试。<br>  在mr文件夹中，rpc.go负责master与worker之间的通信。这里可能需要rpc的一些知识来理解，但在本次实验中可以简单理解为worker以rpc.go内的结构体为参数，调用master.go文件中的函数来与master进行通讯。在master和worker的文件内也给定了样例，并且在worker内部还封装好了call函数，即使不理解rpc也可以学样例编写程序。<br>  在worker文件中，可以看到Worker的参数为两个func，即map和reduce两个函数，这是在创建worker时候就给定的，那么我们可以想到在worker函数内部，我们需要主动找master要工作。同时在完成工作后，我们也需要找master汇报工作，同时接受下一份工作，直到master让你休假（但休假完还是要上班）或者master卷款跑路。（太资本主义了）<br>  在master文件中，可以看到初始化master时候给定了文件名序列以及reduce后文件的数量。毫无疑问，我们先要把这些存起来。然后根据上述worker的工作流程，master的工作也可以确认：接受worker的工作请求，查看手里有啥空闲的工作，有map就给map，map活都接完但是没干完的就让员工先休假，等到map活干完再来分配reduce工作。reduce工作都干完了就可以卷款跑路（调用Done函数return true）了。（太资本主义了）<br>  工作流程基本如上，虽然很形象，但接下来，我们需要具体用代码去实现它。    </p>
<h3 id="RPC-go"><a href="#RPC-go" class="headerlink" title="RPC.go"></a>RPC.go</h3><p>  master与worker要通过rpc进行通讯，那么我们先来规范好通讯协议，知道员工该告诉老板啥，老板该告诉员工啥，才能更好地展开工作。在这里，我们将worker发给master的数据称为请求，反过来称为相应。<br>  首先，无论是map工作还是reduce工作，无论是分配工作还是汇报工作，都要通过文件来进行。master需要告诉worker去读取哪个文件，worker需要告诉master哪个文件已经完成了。因此在请求和相应二者中，可以确定的一项是filename。数据类型这里选用的是string。<br>  其次，除了工作地点也就是文件名之外，还要汇报工作类型，是map还是reduce。所以无论是请求还是相应，都需要有表示工作类型的数据。这里我在请求中使用Status进行表示，同时也可以表示worker自己完成了工作还是在休假；响应中使用JobName进行表示。数据类型均为string。或许有些英语不准确但问题不大。<br>  我们可以得到以下代码：    </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RPCArgs <span class="keyword">struct</span> {</span><br><span class="line">	Status <span class="keyword">string</span></span><br><span class="line">	Filename <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RPCReplys <span class="keyword">struct</span> {</span><br><span class="line">	JobName <span class="keyword">string</span></span><br><span class="line">	Filename <span class="keyword">string</span></span><br><span class="line">	NReduce <span class="keyword">int</span></span><br><span class="line">	NMap <span class="keyword">int</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  这里args为请求，replys为响应。在响应中多了两项，是为了worker更好地工作而传送的，在介绍worker时候会进行介绍。   </p>
<h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><p>  明确沟通协议后，master的工作就很明确了：存储各种工作状态，分配工作，接受汇报工作并且改变工作的状态，并在所有工作结束自己退出。我们先根据上述描述了解master需要存什么。<br>  首先，MakeMaster参数中的filenames和nReduce肯定是要存的，毫无疑问。<br>  其次，需要存储各个工作的状态。在这里可以使用数组来表示，0表示未分配，1表示工作中，2表示已完成。这样做的另一个好处是在工作时间过长的时候可以重新把该工作设置为未分配，从而达到容错的效果。这里需要两个数组，mapTasks []int 和 reduceTasks []int。<br>  第三，标志工作完成的标识符。这里用的mapDone和reduceDone两个int来标识。这也是确认工作完成来切换到reduce工作的标志。<br>于是我们可以得到以下声明：   </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> {</span><br><span class="line">	<span class="comment">// Your definitions here.</span></span><br><span class="line">	filenames   []<span class="keyword">string</span></span><br><span class="line">	mapTasks    []<span class="keyword">int32</span></span><br><span class="line">	reduceTasks []<span class="keyword">int32</span></span><br><span class="line">	nReduce     <span class="keyword">int</span></span><br><span class="line">	nMap        <span class="keyword">int</span></span><br><span class="line">	mapDone     <span class="keyword">int</span></span><br><span class="line">	reduceDone  <span class="keyword">int</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  可以看到多了个nMap，也是为了worker便于工作而存放的。   </p>
<p>  MakeMaster函数便不用多说，进行初始化即可。  </p>
<p>  确定完协议后，就需要真正的函数来进行通信处理。这里使用的函数我命名为GetJob，接受参数如下：   </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">GetJob</span><span class="params">(args *RPCArgs, reply *RPCReplys)</span> <span class="title">error</span></span> </span><br></pre></td></tr></tbody></table></figure>
<p>  确定协议后就需要做事了。首先我们来接受worker的汇报工作，如果他完成的工作叫map，则找到他完成的工作，划掉工作。具体代码如下：   </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.Status == <span class="string">"map"</span> {</span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> m.filenames {</span><br><span class="line">		<span class="keyword">if</span> args.Filename == value &amp;&amp; atomic.LoadInt32(&amp;m.mapTasks[index]) == <span class="number">1</span> {</span><br><span class="line">			atomic.StoreInt32(&amp;m.mapTasks[index], <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  横向有点长，主要是因为会有多个线程同时访问数组，要保证数组操作的原子性，从而调用函数。reduce代码基本一样，不过多赘述。   </p>
<p>  接收汇报后便要先检测工作干完没有，干完了就可以直接结束。没干完就继续发配。这里检测是否完成与终止master进程的函数一样，调用了Done函数。   </p>
<p>  Done函数遍历工作池，如果所有工作都做完了，则删掉MapReduce的中间产生的键值对组，返回true值。否则返回 false。这里写的麻烦了点，而且删掉中间产物也不应该由master来做，在shell测试脚本中由shell来清空了中间产物。但最终可以过测试就行。   </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">Done</span><span class="params">()</span> <span class="title">bool</span></span> {</span><br><span class="line">	ret := <span class="literal">false</span></span><br><span class="line">	m.mapDone = <span class="number">1</span></span><br><span class="line">	m.reduceDone = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> m.mapTasks {</span><br><span class="line">		<span class="keyword">if</span> value != <span class="number">2</span> {</span><br><span class="line">			m.mapDone = <span class="number">0</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> m.reduceTasks {</span><br><span class="line">		<span class="keyword">if</span> value != <span class="number">2</span> {</span><br><span class="line">			m.reduceDone = <span class="number">0</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> m.mapDone == <span class="number">1</span> &amp;&amp; m.reduceDone == <span class="number">1</span> {</span><br><span class="line">		ret = <span class="literal">true</span></span><br><span class="line">		fmt.Println(<span class="string">"Done jobs"</span>)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.nReduce; i++ {</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m.nMap; j++ {</span><br><span class="line">				f, err := os.OpenFile(<span class="string">"mr-"</span>+strconv.Itoa(i)+<span class="string">"-"</span>+strconv.Itoa(j), os.O_RDWR|os.O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">					fmt.Println(err)</span><br><span class="line">				}</span><br><span class="line">				f.Close()</span><br><span class="line">			}</span><br><span class="line">		}<span class="comment">//删掉中间产物</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  在结束条件确认之后，身为master便可以尽情发配工作了。发配工作流程是，检测第一个未分配工作，如果有则分配下去并且开始计时，计时结束如果未完成说明遭受了意外完成不了，重新变为未分配。如果完成了则一切安好。如果所有工作都分配了但有的未完成，便可以先叫员工休假。代码如下：   </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m.mapDone == <span class="number">0</span> {</span><br><span class="line">			index := m.getMapIndex()<span class="comment">//手动封装的函数，找到第一个为0的数组索引，否则返回-1</span></span><br><span class="line">			<span class="keyword">if</span> index != <span class="number">-1</span> {</span><br><span class="line">				reply.JobName = <span class="string">"map"</span></span><br><span class="line">				reply.Filename = m.filenames[index]</span><br><span class="line">				reply.NMap = index<span class="comment">//在map时候传送index数，在reduce时候传输nmap总数，便于中间文件的命名</span></span><br><span class="line">				atomic.StoreInt32(&amp;m.mapTasks[index], <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">					time.Sleep(time.Duration(<span class="number">10</span>) * time.Second)</span><br><span class="line">					<span class="keyword">if</span> atomic.LoadInt32(&amp;m.mapTasks[index]) != <span class="number">2</span> {</span><br><span class="line">						atomic.StoreInt32(&amp;m.mapTasks[index], <span class="number">0</span>)</span><br><span class="line">					}</span><br><span class="line">				}()<span class="comment">//计时器，完成了则安好，未完成则改成未分配</span></span><br><span class="line"></span><br><span class="line">			} <span class="keyword">else</span> {</span><br><span class="line">				reply.JobName = <span class="string">"free"</span><span class="comment">//休假</span></span><br><span class="line">				reply.Filename = <span class="string">""</span></span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">		} </span><br></pre></td></tr></tbody></table></figure>
<p>  reduce同理，不过多赘述。至此，我们完成了master与worker所需要通信的所有东西……除了函数返回值。我们需要返回一个error类型。我选择的是干脆返回一个nil。  </p>
<p>  不要忘了nMap和nReduce两个通信参数，在接下来的部分会用到。</p>
<p>  至此，master部分结束了，接下来讲解worker部分。  </p>
<h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><p>  worker部分我们需要完成的也就是主要的Worker函数，也就是那个接收两个函数为参数的函数。我们需要完成的也很简单：循环调用GetJob来联系Master，接收到map活则干map，接收到reduce活则干reduce，接收到暂停任务则sleep一下，如果联系不到则说明Master工作已经完成，干脆自己也退出就行。  </p>
<p>  worker主要部分也就确定了。一个大循环体，最开头是联系Master获得任务，代码如下：   </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> call(<span class="string">"Master.GetJob"</span>, &amp;args, &amp;reply) == <span class="literal">false</span> {</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		}</span><br></pre></td></tr></tbody></table></figure>
<p>  注意，go是没有while的，你需要使用for循环。  </p>
<p>  接收到map工作后，先打开老板给的文件名，读取文件，将文件调用map函数，得到一个键值对组，存入中间文件中。中间文件的命名便有讲究：采用将key哈希成数字，然后对nReduce进行取余计算，这样可以保证相同的key计算值是一样的，同时也保证了分布式计算的正确性。将此数字作为中间文件名的一部分，同时另一部分采用map的号码，也就是传输过来的NMap号，来构成二元组。这样即保证了每个map任务的结果互不干扰，在一个map任务挂掉后重新执行该map，能够直接清空文件并再次编写。当进行reduce任务的时候，由于map数字是固定的，便于索引。     </p>
<p>  由于在mrsequential.go中实现了串行的MapReduce，因此可以复制粘贴一部分代码到里面。具体代码如下：  </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> reply.JobName == <span class="string">"map"</span> {</span><br><span class="line">			filename := reply.Filename</span><br><span class="line">			file, err := os.Open(filename)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">				log.Fatalf(<span class="string">"cannot open %v"</span>, filename)</span><br><span class="line">			}</span><br><span class="line">			content, err := ioutil.ReadAll(file)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">				log.Fatalf(<span class="string">"cannot read %v"</span>, filename)</span><br><span class="line">			}</span><br><span class="line">			file.Close()</span><br><span class="line">			kva := mapf(filename, <span class="keyword">string</span>(content))<span class="comment">//读取文件，调用map</span></span><br><span class="line">			<span class="keyword">var</span> files []*os.File</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; reply.NReduce; i++ {</span><br><span class="line">				f, err := ioutil.TempFile(<span class="string">"./"</span>, <span class="string">"tmp-map*"</span>)<span class="comment">//建立临时文件，可以保证程序意外退出后能够直接清空</span></span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">					fmt.Println(err)</span><br><span class="line">				}</span><br><span class="line">				files = <span class="built_in">append</span>(files, f)</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva {</span><br><span class="line">				name := ihash(kv.Key) % reply.NReduce<span class="comment">//哈希操作</span></span><br><span class="line">				f := files[name]</span><br><span class="line">				fmt.Fprintf(f, <span class="string">"%v %v\n"</span>, kv.Key, kv.Value)<span class="comment">//将key相同的放进一个文件</span></span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">for</span> index, value := <span class="keyword">range</span> files {</span><br><span class="line">				value.Close()<span class="comment">//保存临时文件，同时改名为正式的中间文件的名字。也就是NMAP的作用</span></span><br><span class="line">				os.Rename(value.Name(), <span class="string">"mr-"</span>+strconv.Itoa(index)+<span class="string">"-"</span>+strconv.Itoa(reply.NMap))</span><br><span class="line">			}</span><br><span class="line">			args.Status = <span class="string">"map"</span></span><br><span class="line">			args.Filename = filename</span><br><span class="line">			reply = RPCReplys{}</span><br><span class="line">		} </span><br></pre></td></tr></tbody></table></figure>
<p>  代码不短，但有注释，很容易理解。   </p>
<p>  到reduce部分，reduce部分干的活便是打开reduce号对应的所有中间文件，读取他们，并对他们进行排序。然后，同样是为了容错，根据reduce号建立输出文件的临时文件。然后，遍历排序过的键值对组，将key值相同的文件，调用reduce函数归纳整理，将结果输出到临时文件中。最后，重命名临时文件到正式文件。   </p>
<p>  与map相同，由于在mrsequential.go中有对排序的实现以及文件名字命名的规范，文件内容的规范，我们也可以复制粘贴过来。具体代码如下：   </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> reply.JobName == <span class="string">"reduce"</span> {</span><br><span class="line">	<span class="keyword">var</span> kvs []KeyValue</span><br><span class="line">	<span class="keyword">var</span> kv KeyValue</span><br><span class="line">	filecode := reply.Filename</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; reply.NMap; i++ {</span><br><span class="line">		filename := <span class="string">"mr-"</span> + filecode + <span class="string">"-"</span> + strconv.Itoa(i)</span><br><span class="line">		ifile, err := os.OpenFile(filename, os.O_RDONLY, <span class="number">0666</span>)<span class="comment">//根据reduce号计算中间文件名字，读取所有中间文件</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			log.Fatalf(<span class="string">"cannot read %v"</span>, filename)</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span> {</span><br><span class="line">			_, err := fmt.Fscanf(ifile, <span class="string">"%v %v"</span>, &amp;kv.Key, &amp;kv.Value)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">				fmt.Println(err)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			}</span><br><span class="line">			kvs = <span class="built_in">append</span>(kvs, kv)</span><br><span class="line">		}</span><br><span class="line">		ifile.Close()</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="string">"len ="</span>, <span class="built_in">len</span>(kvs))</span><br><span class="line"></span><br><span class="line">	sort.Sort(ByKey(kvs))<span class="comment">//对键值对组排序，ByKey可以参考mrsequential.go</span></span><br><span class="line">	oname := <span class="string">"mr-out-"</span> + reply.Filename</span><br><span class="line">	ofile, err := ioutil.TempFile(<span class="string">"./"</span>, <span class="string">"out-tmp*"</span>)<span class="comment">//临时文件，便于出错时直接丢弃</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"output error"</span>)</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i &lt; <span class="built_in">len</span>(kvs) {</span><br><span class="line">			j := i + <span class="number">1</span></span><br><span class="line">			<span class="keyword">for</span> j &lt; <span class="built_in">len</span>(kvs) &amp;&amp; kvs[j].Key == kvs[i].Key {</span><br><span class="line">				j++</span><br><span class="line">			}</span><br><span class="line">			values := []<span class="keyword">string</span>{}</span><br><span class="line">			<span class="keyword">for</span> k := i; k &lt; j; k++ {</span><br><span class="line">				values = <span class="built_in">append</span>(values, kvs[k].Value)</span><br><span class="line">			}</span><br><span class="line">			output := reducef(kvs[i].Key, values)</span><br><span class="line"></span><br><span class="line">			fmt.Fprintf(ofile, <span class="string">"%v %v\n"</span>, kvs[i].Key, output)</span><br><span class="line"></span><br><span class="line">			i = j</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	ofile.Close()<span class="comment">//这一部分参考mrsequential.go</span></span><br><span class="line">	os.Rename(ofile.Name(), oname)<span class="comment">//重命名</span></span><br><span class="line">	args.Status = <span class="string">"reduce"</span></span><br><span class="line">	args.Filename = reply.Filename</span><br><span class="line">	reply = RPCReplys{}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<p>  至此，worker基本完成了。还有个休假部分，简单的sleep就行，不过多赘述。  </p>
<p>  整个MapReduce实验便完整地完成了。  </p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>  代码写完当然要测试。在lab1的官网上，给了我们一个很好的各种测试办法。具体可以参考官网。这里说说最终测试。   </p>
<p>  最后我们要执行的，是test-mr.sh的shell脚本。测试总共五项：测试word count程序，测试indexer程序，map并行化测试,reduce并行化测试以及容错测试。前两个是应用测试。中间两个我也不知道怎么测的，我也没看Shell源码，反正直接过了。最后一个容错测试值得多说几句。在现实生活中会遇到各种各样的错误，在上面实现的容错，也就是通过master在分配工作后检测给定时间内是否完成，未完成则重新分配，只能解决worker挂掉的问题。本次测试的也是如此。但现实生活中，可能master也会挂掉。这些问题在论文中提供了解决的思路。同时在论文中也有着多种优化的技巧与思路，所以论文值得多读几遍。     </p>
<p>  在执行完test-mr.sh最后，会有如下输出。如果你的结果和以下一样，恭喜你，你完成了本次实验。  </p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- crash test: PASS</span><br><span class="line">*** PASSED ALL TESTS</span><br></pre></td></tr></tbody></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  现在是凌晨2.15，写本博客比预先构想所花的时间要更长。写6.824的计划其实半年前学完go就想写了，但由于各种原因拖到最近才写完，从下载6.824到写完lab1过掉所有test只花了两天时间，和预想差不多。写本文花了两个半多小时。半年前最开始动手的时候感觉相当的迷茫，不知道从何下手，先是对go不熟悉，怕各种错误糊一脸，然后是对项目文件的不熟悉。这个过程中，仔细看官网，读论文，搜资料着实起到了很大的帮助。也幸亏MapReduce论文看了好几遍，让我交上了信息检索课的作业。   </p>
<p>  总之，正确早日写完6.824，不要留坑。  </p>
<script>
        document.querySelectorAll('.not-gallery-item')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="article-licensing box"><div class="licensing-title"><p>2020 6.824 lab1解析</p><p><a href="https://exgod22356.github.com/Science/2020-6-824-lab1解析/">https://exgod22356.github.com/Science/2020-6-824-lab1解析/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>王钦砚</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-08-10</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%BC%96%E7%A8%8B/">编程</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></div><div class="sharethis-inline-share-buttons"></div><script src="//platform-api.sharethis.com/js/sharethis.js#property=5ab6f60ace89f00013641890&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Science/c-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">C++ 实现线程池</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Science/git%E7%9A%84%E4%BD%BF%E7%94%A8/"><span class="level-item">git的使用</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/gallery/endo_yurika.jpg" alt="王钦砚"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">王钦砚</p><p class="is-size-6 is-block">Web Developer</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">37</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">25</p></a></div></div></nav></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Ego/"><span class="level-start"><span class="level-item">Ego</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Gaman/"><span class="level-start"><span class="level-item">Gaman</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Romance/"><span class="level-start"><span class="level-item">Romance</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Science/"><span class="level-start"><span class="level-item">Science</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ACM/"><span class="tag">ACM</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-Primer/"><span class="tag">C++Primer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GO/"><span class="tag">GO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Gaman/"><span class="tag">Gaman</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Introduction/"><span class="tag">Introduction</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%81%9A%E9%A2%98%E5%AE%B6/"><span class="tag">做题家</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80/"><span class="tag">基础</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%89%E5%85%A8/"><span class="tag">安全</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"><span class="tag">容器化</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91/"><span class="tag">开发</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A8%A1%E6%9D%BF/"><span class="tag">模板</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%87%E7%BC%96/"><span class="tag">汇编</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><span class="tag">编译原理</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tag">网络</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%97%E5%8F%A5/"><span class="tag">诗句</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E7%BC%96%E7%A8%8B/"><span class="tag">面向面试编程</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Icarus" height="28"></a><p class="is-size-7"><span>&copy; 2021 王钦砚</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exgod22356/exgod22356.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><!-- hexo injector body_end start -->
    <script>
    (() => {
        function switchTab() {
            if (!location.hash) {
              return;
            }
            Array
                .from(document.querySelectorAll('.tab-content'))
                .forEach($tab => {
                    $tab.classList.add('is-hidden');
                });
            Array
                .from(document.querySelectorAll('.tabs li'))
                .forEach($tab => {
                    $tab.classList.remove('is-active');
                });
            const $activeTab = document.querySelector(location.hash);
            if ($activeTab) {
                $activeTab.classList.remove('is-hidden');
            }
            const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
            if ($tabMenu) {
                $tabMenu.parentElement.classList.add('is-active');
            }
        }
        switchTab();
        window.addEventListener('hashchange', switchTab, false);
    })();
    </script>
    <!-- hexo injector body_end end --></body></html>