<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>SICP in Python读书笔记 - Icarus</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#f7f7f7"><meta name="application-name" content="Icaurs - Hexo Theme"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="msapplication-TileColor" content="#f7f7f7"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Icaurs - Hexo Theme"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="主要为SICP in Python的读书笔记，记录了书中的一些平时不是很熟悉的知识点。"><meta property="og:type" content="blog"><meta property="og:title" content="SICP in Python读书笔记"><meta property="og:url" content="https://exgod22356.github.com/Science/sicp-in-python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="Icarus"><meta property="og:description" content="主要为SICP in Python的读书笔记，记录了书中的一些平时不是很熟悉的知识点。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://exgod22356.github.com/img/og_image.png"><meta property="article:published_time" content="2021-05-13T11:10:30.000Z"><meta property="article:author" content="王钦砚"><meta property="article:tag" content="python"><meta property="article:tag" content="开发"><meta property="article:tag" content="读书笔记"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://exgod22356.github.com/Science/sicp-in-python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},"headline":"Icarus","image":["https://exgod22356.github.com/img/og_image.png"],"datePublished":"2021-05-13T11:10:30.000Z","author":{"@type":"Person","name":"王钦砚"},"description":"主要为SICP in Python的读书笔记，记录了书中的一些平时不是很熟悉的知识点。"}</script><link rel="canonical" href="https://exgod22356.github.com/Science/sicp-in-python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Icarus" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Gitter" href="https://gitter.im/"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exgod22356/exgod22356.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-05-13T11:10:30.000Z" title="2021-05-13T11:10:30.000Z">2021-05-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Science/">Science</a></span><span class="level-item">9 minutes read (About 1404 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">SICP in Python读书笔记</h1><div class="content"><p>主要为SICP in Python的读书笔记，记录了书中的一些平时不是很熟悉的知识点。  </p>
<a id="more"></a>

<h2 id="第一章-用函数构建抽象"><a href="#第一章-用函数构建抽象" class="headerlink" title="第一章 用函数构建抽象"></a>第一章 用函数构建抽象</h2><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><code>doctest</code>模块可以用于测试，python可以将测试写进函数的文档字符串内，例子如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_naturals</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">"""Return the sum of the first n natural numbers</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; sum_naturals(10)</span></span><br><span class="line"><span class="string">    55</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; sum_naturals(100)</span></span><br><span class="line"><span class="string">    5050</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + k, k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></tbody></table></figure>
<p>调用如下，<code>globals</code>返回全局变量的表示，需要它来求解表达式，正常运行应该不返回结果：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> doctest <span class="keyword">import</span> run_docstring_examples</span><br><span class="line">run_docstring_examples(sum_naturals,<span class="built_in">globals</span>())</span><br></pre></td></tr></tbody></table></figure>
<p>在文件中编写python，可以用下面命令启动文档中所有doctest：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m doctest &lt;python_source_file&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>观察下列求和函数，可以看到相似的求和过程：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_naturals</span>(<span class="params">n</span>):</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + k, k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_cubes</span>(<span class="params">n</span>):</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        total, k = total + <span class="built_in">pow</span>(k,<span class="number">3</span>), k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pi_sum</span>(<span class="params">n</span>):</span></span><br><span class="line">    total, k = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        total, k = total + <span class="number">8</span>/(k*(k+<span class="number">2</span>)), k+<span class="number">4</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></tbody></table></figure>
<p>对于相似的过程，我们可以将其抽象出来，如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_sum</span>(<span class="params">n,term,<span class="built_in">next</span></span>):</span></span><br><span class="line">    total,k = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        total, k = total + term(k),<span class="built_in">next</span>(k)</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cube</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_one</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_cube_abstract</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> do_sum(n,cube,add_one)</span><br></pre></td></tr></tbody></table></figure>
<p>我们将方程作为参数，抽象出了中间过程，<code>next</code>表示下一项，<code>term</code>表示本项，对于三次方求和可以用如上过程求解。同样，对于<code>pi_sum</code>也可以通过类似方法求解，如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_four</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n+<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pi_sum_term</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span>/(n*(n+<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pi_sum_abstract</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> do_sum(n,pi_sum_term,add_four)</span><br></pre></td></tr></tbody></table></figure>
<p>以同样的过程，我们可以用以下代码表示迭代逼近法：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter_improve</span>(<span class="params">update,test,guess=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> test(guess):</span><br><span class="line">        guess = update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br></pre></td></tr></tbody></table></figure>
<p>该函数代表当<code>guess</code>满足条件时候则返回，否则不断更新<code>guess</code>直到满足条件。我们可以定义以下函数，来计算黄金比例值：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">near</span>(<span class="params">x,f,g</span>):</span></span><br><span class="line">    <span class="keyword">return</span> approx_eq(f(x),g(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">approx_eq</span>(<span class="params">x,y,eps=<span class="number">1e-5</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x-y)&lt;eps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">golden_update</span>(<span class="params">guess</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/guess+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">golden_test</span>(<span class="params">guess</span>):</span></span><br><span class="line">    <span class="keyword">return</span> near(guess,square,add_one)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_golden</span>():</span></span><br><span class="line">    <span class="keyword">return</span> iter_improve(golden_update,golden_test)</span><br></pre></td></tr></tbody></table></figure>
<p>这是计算黄金比例的一种方法，当误差足够小的时候返回，否则继续迭代。</p>
<p>但上述存在一个问题，就是update只接受一个参数，我们可以重新修改我们的模型。</p>
<p>下面操作可以使得我们得到一个数的平方根：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">avg</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x+y)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt_update</span>(<span class="params">guess,x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> avg(guess,x/guess)</span><br></pre></td></tr></tbody></table></figure>
<p>通过不断更新来获取平方根，但问题在于该<code>update</code>需要俩参数，我们可以通过以下方法来调用：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sqrt</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">guess</span>):</span></span><br><span class="line">        <span class="keyword">return</span> sqrt_update(guess,x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">guess</span>):</span></span><br><span class="line">        <span class="keyword">return</span> approx_eq(square(guess),x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> iter_improve(update,test)</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到，此处<code>sqrt_update</code>可以看到参数<code>x</code>，而无需改变<code>iter_improve</code>函数。这里局部函数的用法，他只影响函数内的东西，而不影响函数外的。局部定义的函数也通常称为闭包。</p>
<p>我们可以组合函数，得到一个新的函数，具体如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compose</span>(<span class="params">f,g</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">h</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> f(g(x))</span><br><span class="line">    <span class="keyword">return</span> h</span><br></pre></td></tr></tbody></table></figure>
<p>我们通过局部函数的方法，得到了一个新的函数。我们也可以用lambda表达式代替上述示例，返回不是函数而是lambda表达式：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compose_lambda</span>(<span class="params">f,g</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:f(g(x))</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以通过函数嵌套的方法，实现牛顿法。首先，实现求导，这里采用近似法求导：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">approx_derivative</span>(<span class="params">f,x,delta=<span class="number">1e-5</span></span>):</span></span><br><span class="line">    df = f(x+delta)-f(x)</span><br><span class="line">    <span class="keyword">return</span> df/delta</span><br></pre></td></tr></tbody></table></figure>
<p>我们继续复用上面的迭代逼近法，这里包装一下，形成新的<code>update</code>函数，如下所示，注意函数类型：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newton_update</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x-f(x)/approx_derivative(f,x)</span><br><span class="line">    <span class="keyword">return</span> update</span><br></pre></td></tr></tbody></table></figure>
<p>牛顿法写好后，我们就复用迭代逼近法，如下所示，注意函数类型：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_root</span>(<span class="params">f,initial_guess=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> approx_eq(f(x),<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> iter_improve(newton_update(f),test,guess=initial_guess)</span><br></pre></td></tr></tbody></table></figure>
<p><code>find_root</code>是一个通用方法，根据传进来的方程找到方程值为0的情况，下面是一些应用，分别是找到<code>x**2==a</code>的情况和<code>x**0.5==a</code>的情况：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_root</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> square(x)-a</span><br><span class="line">    <span class="keyword">return</span> find_root(f)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt_root</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> find_root(<span class="keyword">lambda</span> x:x**<span class="number">0.5</span>-a)</span><br></pre></td></tr></tbody></table></figure>
<p>高阶函数也可以用装饰器语法糖，这里不过多赘述。</p>
<h2 id="第二章-使用对象构建抽象"><a href="#第二章-使用对象构建抽象" class="headerlink" title="第二章 使用对象构建抽象"></a>第二章 使用对象构建抽象</h2><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><p>我们可以用以下方法实现二元组：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pair</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_item</span>(<span class="params">m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">elif</span> m == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">    <span class="keyword">return</span> get_item</span><br></pre></td></tr></tbody></table></figure>
<p>二元组并非传统意义上的二元组，而是实现了了一个函数，可以起到二元组的功能，调用方法如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = make_pair(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">print(p(<span class="number">0</span>))</span><br><span class="line">print(p(<span class="number">1</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以用这样的元组，来实现一个有理数。这里将有理数定义为<code>a/b</code>的形式，可以为假分数。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_rat</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    tmp = gcd(x,y)</span><br><span class="line">    <span class="keyword">return</span> make_pair(x//tmp,y//tmp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_rat</span>(<span class="params">r</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(r(<span class="number">1</span>)!=<span class="number">1</span>):</span><br><span class="line">        print(r(<span class="number">0</span>),<span class="string">"/"</span>,r(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(r(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_rat</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    a0,a1 = a(<span class="number">0</span>),a(<span class="number">1</span>)</span><br><span class="line">    b0,b1 = b(<span class="number">0</span>),b(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> make_rat(b0*a1+a0*b1,a1*b1)</span><br></pre></td></tr></tbody></table></figure>
<p>这里只实现了加法操作和现实操作，其他的操作也类似。这是一种抽象的方法。</p>
<h3 id="实现类与对象"><a href="#实现类与对象" class="headerlink" title="实现类与对象"></a>实现类与对象</h3><p>首先明确思路：类包含成员函数，对象有着自己的属性。当调用成员函数的时候，需要将函数与对象相绑定。</p>
<p>我们可以用字典来模拟属性与方法。在类中的字典存放方法，调用的时候绑定到对象。在对象的字典中存放属性。</p>
<p>首先可以写出<code>make_instance</code>函数来创造一个对象，如下所示：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_instance</span>(<span class="params">cls</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_value</span>(<span class="params">name</span>):</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> attributes:</span><br><span class="line">            <span class="keyword">return</span> attributes[name]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = cls[<span class="string">"get"</span>](name)</span><br><span class="line">            <span class="keyword">return</span> bind_method(value,instance)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_value</span>(<span class="params">name,value</span>):</span></span><br><span class="line">        attributes[name] = value</span><br><span class="line">    </span><br><span class="line">    attributes = {}</span><br><span class="line">    instance = {<span class="string">"get"</span>:get_value,<span class="string">"set"</span>:set_value}</span><br><span class="line">    <span class="keyword">return</span> instance</span><br></pre></td></tr></tbody></table></figure>
<p>其中<code>get_value</code>用于获取属性，或者调用成员函数。<code>set_value</code>用于更改成员。当调用<code>get_value</code>时候，我们先找是否存在属性，如果找不到，则在类中找到对应方法并绑定。</p>
<p><code>bind_method</code>用于绑定，实现如下所示：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bind_method</span>(<span class="params">value,instance</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">callable</span>(value):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">*args</span>):</span></span><br><span class="line">            <span class="keyword">return</span> value(instance,*args)</span><br><span class="line">        <span class="keyword">return</span> method</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></tbody></table></figure>
<p>如果入参为可调用的，则绑定到<code>instance</code>，如果不是，则返回对应值。</p>
<p>注意这里的<code>instance</code>本质还是一个字典，在后续的成员函数的使用上会看到这一点。</p>
<p>在关注完创建对象之后我们再来关注创建类，如下所示：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_class</span>(<span class="params">attributes,base_class=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_value</span>(<span class="params">name</span>):</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> attributes:</span><br><span class="line">            <span class="keyword">return</span> attributes[name]</span><br><span class="line">        <span class="keyword">elif</span> base_class <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> base_class[<span class="string">"get"</span>](name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_value</span>(<span class="params">name,value</span>):</span></span><br><span class="line">        attributes[name] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">*args</span>):</span></span><br><span class="line">        <span class="keyword">return</span> init_instance(cls, *args)</span><br><span class="line"></span><br><span class="line">    cls = {<span class="string">"get"</span>:get_value,<span class="string">"set"</span>:set_value,<span class="string">"new"</span>:new}</span><br><span class="line">    <span class="keyword">return</span> cls</span><br></pre></td></tr></tbody></table></figure>
<p>类的本质也是一个绑定了<code>get</code>,<code>set</code>,<code>new</code>三个基本方法的字典。这里实现了继承功能。在<code>get</code>的时候，会找到成员，如果找不到则在父类中寻找。<code>set</code>则逻辑相同。<code>new</code>的时候接收各种类型的参数，创建实例，然后找到用户定义的<code>__init__</code>函数，将参数输入进去进行对象的初始化，具体如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_instance</span>(<span class="params">cls,*args</span>):</span></span><br><span class="line">    instance = make_instance(cls)</span><br><span class="line">    init = cls[<span class="string">"get"</span>](<span class="string">"__init__"</span>)</span><br><span class="line">    <span class="keyword">if</span> init:</span><br><span class="line">        init(instance, *args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance</span><br></pre></td></tr></tbody></table></figure>
<p>接下来我们可以具体实现一个类，来观察这个系统是怎么执行的。创建类的函数实现如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_account_class</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self_instance,account_holder</span>):</span></span><br><span class="line">        print(self_instance)</span><br><span class="line">        self_instance[<span class="string">"set"</span>](<span class="string">"holder"</span>,account_holder)</span><br><span class="line">        self_instance[<span class="string">"set"</span>](<span class="string">"balance"</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span>(<span class="params">self_instance, amount</span>):</span></span><br><span class="line">        <span class="string">"""Increase the account balance by amount and return the new balance."""</span></span><br><span class="line">        new_balance = self_instance[<span class="string">'get'</span>](<span class="string">'balance'</span>) + amount</span><br><span class="line">        self_instance[<span class="string">'set'</span>](<span class="string">'balance'</span>, new_balance)</span><br><span class="line">        <span class="keyword">return</span> self_instance[<span class="string">'get'</span>](<span class="string">'balance'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span>(<span class="params">self_instance, amount</span>):</span></span><br><span class="line">        <span class="string">"""Decrease the account balance by amount and return the new balance."""</span></span><br><span class="line">        balance = self_instance[<span class="string">'get'</span>](<span class="string">'balance'</span>)</span><br><span class="line">        <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">        self_instance[<span class="string">'set'</span>](<span class="string">'balance'</span>, balance - amount)</span><br><span class="line">        <span class="keyword">return</span> self_instance[<span class="string">'get'</span>](<span class="string">'balance'</span>)</span><br><span class="line">    <span class="keyword">return</span> make_class({<span class="string">'__init__'</span>: __init__,</span><br><span class="line">                        <span class="string">'deposit'</span>:  deposit,</span><br><span class="line">                        <span class="string">'withdraw'</span>: withdraw,</span><br><span class="line">                        <span class="string">'interest'</span>: <span class="number">0.02</span>})</span><br></pre></td></tr></tbody></table></figure>
<p>这里实现了一个账户类以及一些方法。首先关注创建时候的流程。当调用该函数的时候，函数会创建一个class字典，其<code>attributes</code>为<code>return</code>里面的东西，而<code>attritubes</code>需要通过<code>get_value</code>函数，<code>set_value</code>函数来访问。调用方法如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Account = make_account_class()</span><br><span class="line">print(Account[<span class="string">"get"</span>](<span class="string">"interest"</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>该调用过程：<code>makeclass.get_value("interest") =&gt; makeclass.attributes["interest"]</code></p>
<p>在完成类的创建后，我们需要通过访问class字典的<code>new</code>成员，将其当作函数来调用，如下所示：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jim_acc = Account[<span class="string">"new"</span>](<span class="string">"Jim"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>调用过程:<code>makeclass.new("Jim") =&gt; init_instance(makeclass.cls,"Jim") =&gt; make_account_class.__init__(make_instance(cls),"Jim")</code></p>
<p>在调用方法的时候，以以下形式调用：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(jim_acc[<span class="string">"get"</span>](<span class="string">"deposit"</span>)(<span class="number">20</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>他会先从对象的字典中寻找<code>deposit</code>，找不到则在类中找到<code>deposit</code>方法，并且调用类的<code>deposit</code>方法，参数为该对象与调用时候输入的参数。</p>
<p>接下来我们使用继承，看看继承是如何实现的：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_different_account_class</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span>(<span class="params">selfinstance, amount</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Account[<span class="string">'get'</span>](<span class="string">"withdraw"</span>)(selfinstance,amount+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> make_class({<span class="string">"withdraw"</span>:withdraw,<span class="string">"interest"</span>:<span class="number">0.01</span>},Account)</span><br></pre></td></tr></tbody></table></figure>
<p>我们实现了一个<code>Account</code>子类，复用了里面的所有方法，改写了<code>withdraw</code>方法使得扣钱会多一块钱。</p>
<p>这就是实现类与对象的基本思路。</p>
<h3 id="泛用方法"><a href="#泛用方法" class="headerlink" title="泛用方法"></a>泛用方法</h3><p><strong>接口</strong>：我们可以通过统一的接口来实现抽象。负数在表示时候可以用角度表示也可以用实数表示，以下加法可以协调两种不同表示法：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_complex</span>(<span class="params">z1,z2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> ComplexRI(z1.real+z2.real,z1.img+z2.img)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul_complex</span>(<span class="params">z1,z2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> ComplexMA(z1.mag * z2.mag, z1.ang + z2.ang)</span><br></pre></td></tr></tbody></table></figure>
<p>只要两个类都定义了对应属性，就可以相加。这里引入<code>@property</code>装饰器，使用该装饰器可以当属性直接调用，而不用打括号。也减少了重复存储的麻烦。两个类定义如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComplexRI</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,real,img</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.real = real</span><br><span class="line">        self.img = img</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mag</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (self.real ** <span class="number">2</span> + self.img ** <span class="number">2</span>) ** <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ang</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> atan2(self.img,self.real)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ComlexRI ({0},{1})"</span>.<span class="built_in">format</span>(self.real,self.img)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComplexMA</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,mag,ang</span>):</span></span><br><span class="line">        self.mag = mag</span><br><span class="line">        self.ang = ang</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">real</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.mag*cos(self.ang)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">img</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.mag*sin(self.ang)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ComplexMA({0},{1})"</span>.<span class="built_in">format</span>(self.mag,self.ang)</span><br></pre></td></tr></tbody></table></figure>
<p>这样就简单地实现了复用。我们还可以用python的特殊方法，来实现运算符的使用，只要分别定义如下几行：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ComplexRI.__add__ = <span class="keyword">lambda</span> self, other: add_complex(self, other)</span><br><span class="line">ComplexMA.__add__ = <span class="keyword">lambda</span> self, other: add_complex(self, other)</span><br><span class="line">ComplexRI.__mul__ = <span class="keyword">lambda</span> self, other: mul_complex(self, other)</span><br><span class="line">ComplexMA.__mul__ = <span class="keyword">lambda</span> self, other: mul_complex(self, other)</span><br></pre></td></tr></tbody></table></figure>
<p>这样我们就可以使用加法运算符和乘法运算符。</p>
<p>我们可以通过判断type来实现跨类型的加法运算定制。也可以将其封装起来，实现一个字典，按照字典查找对应的加法运算。</p>
<h2 id="第三章-计算机程序的构造和解释"><a href="#第三章-计算机程序的构造和解释" class="headerlink" title="第三章 计算机程序的构造和解释"></a>第三章 计算机程序的构造和解释</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归往往会因为重复计算而产生额外的开销。可以用以下装饰器来让递归记忆化：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memo</span>(<span class="params">f</span>):</span></span><br><span class="line">    cache = {}</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">memorized</span>(<span class="params">n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">            cache[n] = f(n)</span><br><span class="line">        <span class="keyword">return</span> cache[n] </span><br><span class="line">    <span class="keyword">return</span> memorized</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.not-gallery-item')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="article-licensing box"><div class="licensing-title"><p>SICP in Python读书笔记</p><p><a href="https://exgod22356.github.com/Science/sicp-in-python读书笔记/">https://exgod22356.github.com/Science/sicp-in-python读书笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>王钦砚</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-05-13</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/python/">python</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><div class="sharethis-inline-share-buttons"></div><script src="//platform-api.sharethis.com/js/sharethis.js#property=5ab6f60ace89f00013641890&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Science/hackthon%E5%AE%9E%E6%88%98-%E2%80%94%E2%80%94%E7%BB%8F%E9%AA%8C%E4%B8%8E%E6%95%99%E8%AE%AD/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Hackthon实战 ——经验与教训</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Science/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E4%B8%8E%E6%95%99%E8%AE%AD-%E2%80%94%E2%80%94%E3%80%8A%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9%E3%80%8B%E5%92%8C%E3%80%8A%E8%BD%AF%E4%BB%B6%E9%95%BF%E6%9C%9F%E5%8D%B1%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-item">软件开发经验与教训  ——《没有银弹》和《软件长期危机》读书笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/gallery/endo_yurika.jpg" alt="王钦砚"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">王钦砚</p><p class="is-size-6 is-block">Web Developer</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">47</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">29</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#第一章-用函数构建抽象"><span class="level-left"><span class="level-item">1</span><span class="level-item">第一章 用函数构建抽象</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#测试"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">测试</span></span></a></li><li><a class="level is-mobile" href="#高阶函数"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">高阶函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第二章-使用对象构建抽象"><span class="level-left"><span class="level-item">2</span><span class="level-item">第二章 使用对象构建抽象</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#数据抽象"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">数据抽象</span></span></a></li><li><a class="level is-mobile" href="#实现类与对象"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">实现类与对象</span></span></a></li><li><a class="level is-mobile" href="#泛用方法"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">泛用方法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第三章-计算机程序的构造和解释"><span class="level-left"><span class="level-item">3</span><span class="level-item">第三章 计算机程序的构造和解释</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#递归"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">递归</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Ego/"><span class="level-start"><span class="level-item">Ego</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Gaman/"><span class="level-start"><span class="level-item">Gaman</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Romance/"><span class="level-start"><span class="level-item">Romance</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/Science/"><span class="level-start"><span class="level-item">Science</span></span><span class="level-end"><span class="level-item tag">36</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ACM/"><span class="tag">ACM</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-Primer/"><span class="tag">C++Primer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GO/"><span class="tag">GO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Gaman/"><span class="tag">Gaman</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Introduction/"><span class="tag">Introduction</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%81%9A%E9%A2%98%E5%AE%B6/"><span class="tag">做题家</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80/"><span class="tag">基础</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%89%E5%85%A8/"><span class="tag">安全</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"><span class="tag">容器化</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91/"><span class="tag">开发</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A8%A1%E6%9D%BF/"><span class="tag">模板</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%87%E7%BC%96/"><span class="tag">汇编</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><span class="tag">编译原理</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tag">网络</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%97%E5%8F%A5/"><span class="tag">诗句</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"><span class="tag">软件工程</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%90%E7%BB%B4/"><span class="tag">运维</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E7%BC%96%E7%A8%8B/"><span class="tag">面向面试编程</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Icarus" height="28"></a><p class="is-size-7"><span>&copy; 2021 王钦砚</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exgod22356/exgod22356.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><!-- hexo injector body_end start -->
    <script>
    (() => {
        function switchTab() {
            if (!location.hash) {
              return;
            }
            Array
                .from(document.querySelectorAll('.tab-content'))
                .forEach($tab => {
                    $tab.classList.add('is-hidden');
                });
            Array
                .from(document.querySelectorAll('.tabs li'))
                .forEach($tab => {
                    $tab.classList.remove('is-active');
                });
            const $activeTab = document.querySelector(location.hash);
            if ($activeTab) {
                $activeTab.classList.remove('is-hidden');
            }
            const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
            if ($tabMenu) {
                $tabMenu.parentElement.classList.add('is-active');
            }
        }
        switchTab();
        window.addEventListener('hashchange', switchTab, false);
    })();
    </script>
    <!-- hexo injector body_end end --></body></html>