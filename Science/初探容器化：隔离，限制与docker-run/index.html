<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>初探容器化：隔离，限制与docker run - Icarus</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#f7f7f7"><meta name="application-name" content="Icaurs - Hexo Theme"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="msapplication-TileColor" content="#f7f7f7"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Icaurs - Hexo Theme"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文为容器化技术系列文章的第一篇。本文将介绍容器化中的隔离，限制的原理，并且实际编写一个类docker应用，并且实际执行docker run命令。"><meta property="og:type" content="blog"><meta property="og:title" content="初探容器化：隔离，限制与docker run"><meta property="og:url" content="https://exgod22356.github.com/Science/%E5%88%9D%E6%8E%A2%E5%AE%B9%E5%99%A8%E5%8C%96%EF%BC%9A%E9%9A%94%E7%A6%BB%EF%BC%8C%E9%99%90%E5%88%B6%E4%B8%8Edocker-run/"><meta property="og:site_name" content="Icarus"><meta property="og:description" content="本文为容器化技术系列文章的第一篇。本文将介绍容器化中的隔离，限制的原理，并且实际编写一个类docker应用，并且实际执行docker run命令。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://exgod22356.github.com/img/og_image.png"><meta property="article:published_time" content="2020-11-12T11:10:30.000Z"><meta property="article:author" content="王钦砚"><meta property="article:tag" content="Linux"><meta property="article:tag" content="容器化"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://exgod22356.github.com/Science/%E5%88%9D%E6%8E%A2%E5%AE%B9%E5%99%A8%E5%8C%96%EF%BC%9A%E9%9A%94%E7%A6%BB%EF%BC%8C%E9%99%90%E5%88%B6%E4%B8%8Edocker-run/"},"headline":"Icarus","image":["https://exgod22356.github.com/img/og_image.png"],"datePublished":"2020-11-12T11:10:30.000Z","author":{"@type":"Person","name":"王钦砚"},"description":"本文为容器化技术系列文章的第一篇。本文将介绍容器化中的隔离，限制的原理，并且实际编写一个类docker应用，并且实际执行docker run命令。"}</script><link rel="canonical" href="https://exgod22356.github.com/Science/%E5%88%9D%E6%8E%A2%E5%AE%B9%E5%99%A8%E5%8C%96%EF%BC%9A%E9%9A%94%E7%A6%BB%EF%BC%8C%E9%99%90%E5%88%B6%E4%B8%8Edocker-run/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Icarus" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Gitter" href="https://gitter.im/"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exgod22356/exgod22356.github.io"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-11-12T11:10:30.000Z" title="2020-11-12T11:10:30.000Z">2020-11-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Science/">Science</a></span><span class="level-item">31 minutes read (About 4603 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">初探容器化：隔离，限制与docker run</h1><div class="content"><p>  本文为容器化技术系列文章的第一篇。本文将介绍容器化中的隔离，限制的原理，并且实际编写一个类docker应用，并且实际执行docker run命令。    </p>
<a id="more"></a>

<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li>Linux  </li>
<li>Go</li>
</ul>
<h1 id="初探容器化：隔离，限制与docker-run"><a href="#初探容器化：隔离，限制与docker-run" class="headerlink" title="初探容器化：隔离，限制与docker run"></a>初探容器化：隔离，限制与docker run</h1><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a target="_blank" rel="noopener" href="https://exgod22356.github.io/science/A-Glimpse-of-Container-Technique/#%E5%89%8D%E8%A8%80">前言</a>  </li>
<li><a target="_blank" rel="noopener" href="https://exgod22356.github.io/science/A-Glimpse-of-Container-Technique/#%E9%9A%94%E7%A6%BB">隔离</a>  <ul>
<li><a target="_blank" rel="noopener" href="https://exgod22356.github.io/science/A-Glimpse-of-Container-Technique/#namepspaces-%E7%B3%BB%E7%BB%9F">Namepspaces 系统</a></li>
<li><a target="_blank" rel="noopener" href="https://exgod22356.github.io/science/A-Glimpse-of-Container-Technique/#go%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">Go的系统调用</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://exgod22356.github.io/science/A-Glimpse-of-Container-Technique/#%E9%99%90%E5%88%B6">限制</a>  <ul>
<li><a target="_blank" rel="noopener" href="https://exgod22356.github.io/science/A-Glimpse-of-Container-Technique/#cgroups%E6%8A%80%E6%9C%AF">Cgroups技术</a></li>
<li><a target="_blank" rel="noopener" href="https://exgod22356.github.io/science/A-Glimpse-of-Container-Technique/#cgroups%E5%AE%9E%E6%88%98">Cgroups实战</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://exgod22356.github.io/science/A-Glimpse-of-Container-Technique/#docker_run">docker run</a><ul>
<li><a target="_blank" rel="noopener" href="https://exgod22356.github.io/science/A-Glimpse-of-Container-Technique/#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">基本结构</a></li>
<li><a target="_blank" rel="noopener" href="https://exgod22356.github.io/science/A-Glimpse-of-Container-Technique/#%E5%AE%9E%E6%88%98docker_run">实战docker_run</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://exgod22356.github.io/science/A-Glimpse-of-Container-Technique/#%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%81%9A%E4%BB%80%E4%B9%88">下一步做什么</a>  </li>
<li><a target="_blank" rel="noopener" href="https://exgod22356.github.io/science/A-Glimpse-of-Container-Technique/#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%90%8E%E8%AE%B0">总结与后记</a></li>
</ul>
<h2 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h2><h3 id="Namepspaces-系统："><a href="#Namepspaces-系统：" class="headerlink" title="Namepspaces 系统："></a>Namepspaces 系统：</h3><p>  Namespaces 系统是linux对于系统资源的一种抽象，它使得进程认为在同一namespaces系统下的进程之间能够互相感知，而对namespace外一无所知，从而实现隔离的效果。<br>  linux最新版本中，根据不同的功能，实现了7个namespace系统，如下所示：   </p>

<table class="md-table"><thead><tr class="md-end-block" cid="n215" mdtype="table_row"><th><span contenteditable="true" class="td-span" cid="n216" mdtype="table_cell"><span md-inline="plain" class="md-plain">Namespace</span></span></th><th><span contenteditable="true" class="td-span" cid="n217" mdtype="table_cell"><span md-inline="plain" class="md-plain">Constant</span></span></th><th><span contenteditable="true" class="td-span" cid="n218" mdtype="table_cell"><span md-inline="plain" class="md-plain">Isolates</span></span></th></tr></thead><tbody><tr class="md-end-block" cid="n219" mdtype="table_row"><td><span contenteditable="true" class="td-span" cid="n220" mdtype="table_cell"><span md-inline="plain" class="md-plain">Cgroup</span></span></td><td><span contenteditable="true" class="td-span" cid="n221" mdtype="table_cell"><span md-inline="plain" class="md-plain">CLONE_NEWCGROUP</span></span></td><td><span contenteditable="true" class="td-span" cid="n222" mdtype="table_cell"><span md-inline="plain" class="md-plain">Cgroup root directory</span></span></td></tr><tr class="md-end-block" cid="n223" mdtype="table_row"><td><span contenteditable="true" class="td-span" cid="n224" mdtype="table_cell"><span md-inline="plain" class="md-plain">IPC</span></span></td><td><span contenteditable="true" class="td-span" cid="n225" mdtype="table_cell"><span md-inline="plain" class="md-plain">CLONE_NEWIPC</span></span></td><td><span contenteditable="true" class="td-span" cid="n226" mdtype="table_cell"><span md-inline="plain" class="md-plain">System V IPC, POSIX message queues</span></span></td></tr><tr class="md-end-block" cid="n227" mdtype="table_row"><td><span contenteditable="true" class="td-span" cid="n228" mdtype="table_cell"><span md-inline="plain" class="md-plain">Network</span></span></td><td><span contenteditable="true" class="td-span" cid="n229" mdtype="table_cell"><span md-inline="plain" class="md-plain">CLONE_NEWNET</span></span></td><td><span contenteditable="true" class="td-span" cid="n230" mdtype="table_cell"><span md-inline="plain" class="md-plain">Network devices, stacks, ports, etc.</span></span></td></tr><tr class="md-end-block" cid="n231" mdtype="table_row"><td><span contenteditable="true" class="td-span" cid="n232" mdtype="table_cell"><span md-inline="plain" class="md-plain">Mount</span></span></td><td><span contenteditable="true" class="td-span" cid="n233" mdtype="table_cell"><span md-inline="plain" class="md-plain">CLONE_NEWNS</span></span></td><td><span contenteditable="true" class="td-span" cid="n234" mdtype="table_cell"><span md-inline="plain" class="md-plain">Mount points</span></span></td></tr><tr class="md-end-block" cid="n235" mdtype="table_row"><td><span contenteditable="true" class="td-span" cid="n236" mdtype="table_cell"><span md-inline="plain" class="md-plain">PID</span></span></td><td><span contenteditable="true" class="td-span" cid="n237" mdtype="table_cell"><span md-inline="plain" class="md-plain">CLONE_NEWPID</span></span></td><td><span contenteditable="true" class="td-span" cid="n238" mdtype="table_cell"><span md-inline="plain" class="md-plain">Process IDs</span></span></td></tr><tr class="md-end-block" cid="n239" mdtype="table_row"><td><span contenteditable="true" class="td-span" cid="n240" mdtype="table_cell"><span md-inline="plain" class="md-plain">User</span></span></td><td><span contenteditable="true" class="td-span" cid="n241" mdtype="table_cell"><span md-inline="plain" class="md-plain">CLONE_NEWUSER</span></span></td><td><span contenteditable="true" class="td-span" cid="n242" mdtype="table_cell"><span md-inline="plain" class="md-plain">User and group IDs</span></span></td></tr><tr class="md-end-block" cid="n243" mdtype="table_row"><td><span contenteditable="true" class="td-span" cid="n244" mdtype="table_cell"><span md-inline="plain" class="md-plain">UTS</span></span></td><td><span contenteditable="true" class="td-span" cid="n245" mdtype="table_cell"><span md-inline="plain" class="md-plain">CLONE_NEWUTS</span></span></td><td><span contenteditable="true" class="td-span" cid="n246" mdtype="table_cell"><span md-inline="plain" class="md-plain">Hostname and NIS domain name</span></span></td></tr></tbody></table>


<p>  详情可见man namespaces。具体命名空间数量由linux版本决定，在这里，由于只实现简易版本，我们只使用到IPC Network Mount PID User UTS这几个namespace。在内核版本3.8之后，这几个namespace都可用。  </p>
<p>  在man文档中，给了我们几种系统调用的方法，分别是：<br>  <strong>clone</strong>：创建新进程，根据flag数，为每一个flag创建一个namespace，将进程封入进去。<br>  <strong>setns</strong>：将调用的进程封装进已经存在的namespace里面。<br>  <strong>unshare</strong>：将正在调用的进程封装进由flags确立的新的namespaces里面。<br>  <strong>ioctl</strong>:查看namespaces的信息。<br>  文档中给出了这些信息，但我们不一定需要使用裸露的api，go为我们封装了它。  </p>
<h3 id="Go的系统调用："><a href="#Go的系统调用：" class="headerlink" title="Go的系统调用："></a>Go的系统调用：</h3><p>  在go的syscall库中，为我们封装了系统调用。我们可以通过设置SysProcAttr结构体，来进行系统调用。该结构体定义如下：  </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SysProcAttr <span class="keyword">struct</span> {</span><br><span class="line">        Chroot       <span class="keyword">string</span>         <span class="comment">// Chroot.</span></span><br><span class="line">        Credential   *Credential    <span class="comment">// Credential.</span></span><br><span class="line">        Ptrace       <span class="keyword">bool</span>           <span class="comment">// Enable tracing.</span></span><br><span class="line">        Setsid       <span class="keyword">bool</span>           <span class="comment">// Create session.</span></span><br><span class="line">        Setpgid      <span class="keyword">bool</span>           <span class="comment">// Set process group ID to Pgid, or, if Pgid == 0, to new pid.</span></span><br><span class="line">        Setctty      <span class="keyword">bool</span>           <span class="comment">// Set controlling terminal to fd Ctty (only meaningful if Setsid is set)</span></span><br><span class="line">        Noctty       <span class="keyword">bool</span>           <span class="comment">// Detach fd 0 from controlling terminal</span></span><br><span class="line">        Ctty         <span class="keyword">int</span>            <span class="comment">// Controlling TTY fd</span></span><br><span class="line">        Foreground   <span class="keyword">bool</span>           <span class="comment">// Place child's process group in foreground. (Implies Setpgid. Uses Ctty as fd of controlling TTY)</span></span><br><span class="line">        Pgid         <span class="keyword">int</span>            <span class="comment">// Child's process group ID if Setpgid.</span></span><br><span class="line">        Pdeathsig    Signal         <span class="comment">// Signal that the process will get when its parent dies (Linux only)</span></span><br><span class="line">        Cloneflags   <span class="keyword">uintptr</span>        <span class="comment">// Flags for clone calls (Linux only)</span></span><br><span class="line">        Unshareflags <span class="keyword">uintptr</span>        <span class="comment">// Flags for unshare calls (Linux only)</span></span><br><span class="line">        UidMappings  []SysProcIDMap <span class="comment">// User ID mappings for user namespaces.</span></span><br><span class="line">        GidMappings  []SysProcIDMap <span class="comment">// Group ID mappings for user namespaces.        // GidMappingsEnableSetgroups enabling setgroups syscall.        // If false, then setgroups syscall will be disabled for the child process.        // This parameter is no-op if GidMappings == nil. Otherwise for unprivileged        // users this should be set to false for mappings work.</span></span><br><span class="line">        GidMappingsEnableSetgroups <span class="keyword">bool</span></span><br><span class="line">        AmbientCaps                []<span class="keyword">uintptr</span> <span class="comment">// Ambient capabilities (Linux only)</span></span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>
<p>  在结构体中，我们着重关注Cloneflags,Unshareflags,UidMappings,GidMappings,这些在namespaces系统中，可能会用得到。   </p>
<p>  下面是一个小demo，用于展示如何使用SysProcAttr去创建进程并且封入新的namespace里面。    </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	cmd:=exec.Command(<span class="string">"sh"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"start namespace demo"</span>)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr{</span><br><span class="line">    Cloneflags: syscall.CLONE_NEWUTS|syscall.CLONE_NEWIPC|syscall.CLONE_NEWPID|syscall.CLONE_NEWNS|syscall.CLONE_NEWUSER,</span><br><span class="line">    UidMappings: []syscall.SysProcIDMap{</span><br><span class="line">			{</span><br><span class="line">				ContainerID: syscall.Getuid(),</span><br><span class="line">				HostID:      syscall.Getuid(),</span><br><span class="line">				Size:        <span class="number">1</span>,</span><br><span class="line">			},</span><br><span class="line">		},</span><br><span class="line">		GidMappings: []syscall.SysProcIDMap{</span><br><span class="line">			{</span><br><span class="line">				ContainerID: syscall.Getgid(),</span><br><span class="line">				HostID:      syscall.Getgid(),</span><br><span class="line">				Size:        <span class="number">1</span>,</span><br><span class="line">      },</span><br><span class="line">    }</span><br><span class="line">	}</span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> err:=cmd.Run();err!=<span class="literal">nil</span> {</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="string">"end namespace demo"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  在demo，创建了子进程，启动了一个sh，并且封入了各个namespace中。在这个demo中，可以尝试各种指令来尝试隔离性，如ps -ef。  </p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><h3 id="Cgroups技术"><a href="#Cgroups技术" class="headerlink" title="Cgroups技术"></a>Cgroups技术</h3><p>  Namespace技术保证了各个进程的隔离。而若要添加诸如内存大小的限制，我们需要学习cgroups技术。<br>  Control cgroups，通常称为cgroups，是linux内核提供的特性，它能使进程被组织进hierarchical  groups，可以用来限制和监视各种资源的使用。内核的cgroup接口通过伪文件系统cgroupfs来调用。分组操作在cgroup内核中实现，而资源跟踪和限制则是通过资源类型子系统来实现。<br>  cgroup 是绑定到通过 cgroup 文件系统定义的一组限制或参数的进程的集合。<br>  subsystems 是修改cgroup进程的行为的内核组建。各式各样的子系统能够用来执行一些操作，诸如限制cpu时间或者内存。subsytems也被成为资源控制器。<br>  控制器的cgroup按层次结构排列。 通过在cgroup文件系统中创建，删除和重命名子目录来定义此层次结构。 在层次结构的每个级别，都可以定义属性（例如，限制）。 cgroup提供的限制，控制和计费通常在定义属性的cgroup之下的整个子层次结构中都有效，例如，后代不能超过在层次结构中较高级别上放置在cgroup上的限制cgroups。   </p>
<h3 id="Cgroups实战"><a href="#Cgroups实战" class="headerlink" title="Cgroups实战"></a>Cgroups实战</h3><ul>
<li>环境需要  <ul>
<li>stress程序 用于模拟系统负载较高场景  </li>
</ul>
</li>
</ul>
<p>  首先我们创建文件夹，并且把cgroup挂载进去。执行一下命令：  </p>
<figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">root@wqy:/<span class="title">home</span>/<span class="title">wqy</span># <span class="title">mkdir</span> <span class="title">cgroup</span>-<span class="title">test</span></span></span><br><span class="line"><span class="function"><span class="title">root</span>@<span class="title">wqy</span>:/<span class="title">home</span>/<span class="title">wqy</span># <span class="title">sudo</span> <span class="title">mount</span> -<span class="title">t</span> <span class="title">cgroup</span> -<span class="title">o</span> <span class="title">none</span>,<span class="title">name</span>=<span class="title">cgroup</span>-<span class="title">test</span> <span class="title">cgroup</span>-<span class="title">test</span> ./<span class="title">cgroup</span>-<span class="title">test</span></span></span><br><span class="line"><span class="function"><span class="title">root</span>@<span class="title">wqy</span>:/<span class="title">home</span>/<span class="title">wqy</span># <span class="title">ls</span> ./<span class="title">cgroup</span>-<span class="title">test</span>/</span></span><br><span class="line"><span class="function"><span class="title">cgroup.clone_children</span>  <span class="title">cgroup.sane_behavior</span>  <span class="title">release_agent</span></span></span><br><span class="line"><span class="function"><span class="title">cgroup.procs</span>	       <span class="title">notify_on_release</span>     <span class="title">tasks</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>  可以看到，在我们挂在完成后，文件内创建了一些默认的文件。其中cgroup.clone_childred代表子cgroup是否继承父cgroup的cpuset cgroup.procs代表树中当前节点所有进程组id notify_on_release代表最后一个进程退出后是否执行release_agent release_agent是个路径 用于退出后自动清理 tasks表示cgroup下的进程id。<br>  我们可以在此文件夹中增加新的cgroup来进行测试。执行以下指令：  </p>
<figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">root@wqy:/<span class="title">home</span>/<span class="title">wqy</span>/<span class="title">cgroup</span>-<span class="title">test</span># <span class="title">sudo</span> <span class="title">mkdir</span> <span class="title">cgroup</span>-1</span></span><br><span class="line"><span class="function"><span class="title">root</span>@<span class="title">wqy</span>:/<span class="title">home</span>/<span class="title">wqy</span>/<span class="title">cgroup</span>-<span class="title">test</span># <span class="title">sudo</span> <span class="title">mkdir</span> <span class="title">cgroup</span>-2</span></span><br><span class="line"><span class="function"><span class="title">root</span>@<span class="title">wqy</span>:/<span class="title">home</span>/<span class="title">wqy</span>/<span class="title">cgroup</span>-<span class="title">test</span># <span class="title">tree</span></span></span><br><span class="line"><span class="function">.</span></span><br><span class="line"><span class="function">├── <span class="title">cgroup</span>-1</span></span><br><span class="line"><span class="function">│&nbsp;&nbsp; ├── <span class="title">cgroup.clone_children</span></span></span><br><span class="line"><span class="function">│&nbsp;&nbsp; ├── <span class="title">cgroup.procs</span></span></span><br><span class="line"><span class="function">│&nbsp;&nbsp; ├── <span class="title">notify_on_release</span></span></span><br><span class="line"><span class="function">│&nbsp;&nbsp; └── <span class="title">tasks</span></span></span><br><span class="line"><span class="function">├── <span class="title">cgroup</span>-2</span></span><br><span class="line"><span class="function">│&nbsp;&nbsp; ├── <span class="title">cgroup.clone_children</span></span></span><br><span class="line"><span class="function">│&nbsp;&nbsp; ├── <span class="title">cgroup.procs</span></span></span><br><span class="line"><span class="function">│&nbsp;&nbsp; ├── <span class="title">notify_on_release</span></span></span><br><span class="line"><span class="function">│&nbsp;&nbsp; └── <span class="title">tasks</span></span></span><br><span class="line"><span class="function">├── <span class="title">cgroup.clone_children</span></span></span><br><span class="line"><span class="function">├── <span class="title">cgroup.procs</span></span></span><br><span class="line"><span class="function">├── <span class="title">cgroup.sane_behavior</span></span></span><br><span class="line"><span class="function">├── <span class="title">notify_on_release</span></span></span><br><span class="line"><span class="function">├── <span class="title">release_agent</span></span></span><br><span class="line"><span class="function">└── <span class="title">tasks</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2 <span class="title">directories</span>, 14 <span class="title">files</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>  可以看到，在添加子cgroup后，子cgroup继承了属性。<br>  接下来，我们为进程加入限制。我们将创建一个stress程序，占用200m内存，观察限制前与限制后是否有区别。  </p>
<figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --vm-bytes <span class="number">200</span>m --vm-keep -m <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>  执行以上指令，在本机的top中可以看到，%MEM项目为2.6,即200M。接下来，加上限制。</p>
<figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">root@wqy:/<span class="title">home</span>/<span class="title">wqy</span>/<span class="title">cgroup</span>-<span class="title">test</span># <span class="title">mount</span> |<span class="title">grep</span> <span class="title">memory</span></span></span><br><span class="line"><span class="function"><span class="title">cgroup</span> <span class="title">on</span> /<span class="title">sys</span>/<span class="title">fs</span>/<span class="title">cgroup</span>/<span class="title">memory</span> <span class="title">type</span> <span class="title">cgroup</span> (<span class="title">rw</span>,<span class="title">nosuid</span>,<span class="title">nodev</span>,<span class="title">noexec</span>,<span class="title">relatime</span>,<span class="title">memory</span>)</span></span><br><span class="line"><span class="function"><span class="title">root</span>@<span class="title">wqy</span>:/<span class="title">home</span>/<span class="title">wqy</span>/<span class="title">cgroup</span>-<span class="title">test</span># <span class="title">cd</span> /<span class="title">sys</span>/<span class="title">fs</span>/<span class="title">cgroup</span>/<span class="title">memory</span> </span></span><br><span class="line"><span class="function"><span class="title">root</span>@<span class="title">wqy</span>:/<span class="title">sys</span>/<span class="title">fs</span>/<span class="title">cgroup</span>/<span class="title">memory</span># <span class="title">sudo</span> <span class="title">mkdir</span> <span class="title">test</span>-<span class="title">limit</span>-<span class="title">memory</span></span></span><br><span class="line"><span class="function"><span class="title">root</span>@<span class="title">wqy</span>:/<span class="title">sys</span>/<span class="title">fs</span>/<span class="title">cgroup</span>/<span class="title">memory</span># <span class="title">cd</span> <span class="title">test</span>-<span class="title">limit</span>-<span class="title">memory</span>/</span></span><br><span class="line"><span class="function"><span class="title">root</span>@<span class="title">wqy</span>:/<span class="title">sys</span>/<span class="title">fs</span>/<span class="title">cgroup</span>/<span class="title">memory</span>/<span class="title">test</span>-<span class="title">limit</span>-<span class="title">memory</span># <span class="title">sudo</span> <span class="title">sh</span> -<span class="title">c</span> "<span class="title">echo</span> "100<span class="title">m</span>" &gt;<span class="title">memory.limit_in_bytes</span>"  </span></span><br><span class="line"><span class="function"><span class="title">root</span>@<span class="title">wqy</span>:/<span class="title">sys</span>/<span class="title">fs</span>/<span class="title">cgroup</span>/<span class="title">memory</span>/<span class="title">test</span>-<span class="title">limit</span>-<span class="title">memory</span># <span class="title">sudo</span> <span class="title">sh</span> -<span class="title">c</span> "<span class="title">echo</span> $$ &gt; <span class="title">tasks</span>"</span></span><br><span class="line"><span class="function"><span class="title">root</span>@<span class="title">wqy</span>:/<span class="title">sys</span>/<span class="title">fs</span>/<span class="title">cgroup</span>/<span class="title">memory</span># <span class="title">stress</span> --<span class="title">vm</span>-<span class="title">bytes</span> 200<span class="title">m</span> --<span class="title">vm</span>-<span class="title">keep</span> -<span class="title">m</span> 1</span></span><br></pre></td></tr></tbody></table></figure>
<p>  在上述命令中，我们通过mount和grep找到了memory所在的挂载点，在挂载点创建了子cgroup：test-limit-memory，将内存限制写入了限制文件，将本进程写入了task，最后执行了指令。通过top命令可以看到 %MEM项目为1.3,即100M。我们成功实现了限制内存使用。  </p>
<p>  在完成了namespace隔离demo和cgroup限制demo后，我们即将用go语言，将这些整合在一起，实现简单的隔离限制程序。  </p>
<h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker_run"></a>docker_run</h2><p>  该部分代码仓库：<a target="_blank" rel="noopener" href="https://github.com/exgod22356/mydockerpractice">github:mydockerpractice</a> 具体为main.go subsystem cgroupmanager container四个部分。  </p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>  在实现简易的docker run之前，我们需要理清思路：我们即将要编写的文件，how it works。  </p>
<ul>
<li>功能  <ul>
<li>实现命令行解析参数 包括命令种类如run 资源限制如-m  </li>
<li>在指定run命令后 使用namespace创建子进程 并且执行命令行给予的程序  </li>
<li>在指定限制之后 能使用cgroup加入限制  </li>
</ul>
</li>
</ul>
<p>  解析文件可以由第三方库来实现，这里使用的是github.com/urfave/cli，在上述vendor文件夹中可以找到。  </p>
<h3 id="实战docker-run"><a href="#实战docker-run" class="headerlink" title="实战docker_run"></a>实战docker_run</h3><p>  首先，我们来确认主函数功能：启动cli，绑定各种参数，进行解析。剩下事务交给其他模块来做。我们可以得到以下主函数：  </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/urfave/cli"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	_ <span class="string">"github.com/Sirupsen/logrus"</span></span><br><span class="line">	container <span class="string">"mydocker/container"</span></span><br><span class="line">	subsystem <span class="string">"mydocker/subsystem"</span></span><br><span class="line">	cgroupmanager <span class="string">"mydocker/cgroupmanager"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> usage = <span class="string">`mydocker is a simple container.`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	app := cli.NewApp()</span><br><span class="line">	app.Name = <span class="string">"mydocker"</span></span><br><span class="line">	app.Usage = usage</span><br><span class="line">	app.Commands = []cli.Command{</span><br><span class="line">		initCommand,</span><br><span class="line">		runCommand,</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> err:= app.Run(os.Args); err!=<span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	}	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  可以看到，我们定义了两个启动命令init和run，分别是初始化容器和启动程序。我们将在下面介绍两个指令的功能。<br>   <strong>runCommand以及Run函数</strong>：runCommand解析参数并且传递给Run函数。Run函数使用NewParentProcess创建了带namespace的进程，创建了cgroup管理程序，配置了限制，应用到进程上，并且将程序指令写入pipe，便于namespace的进程调用。  </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> runCommand = cli.Command{</span><br><span class="line">	Name : <span class="string">"run"</span>,</span><br><span class="line">	Usage : <span class="string">"Create a container"</span>,</span><br><span class="line">	Flags : []cli.Flag{</span><br><span class="line">		cli.BoolFlag{</span><br><span class="line">			Name : <span class="string">"ti"</span>,</span><br><span class="line">			Usage: <span class="string">"enable tty"</span>,</span><br><span class="line">		},</span><br><span class="line">		cli.StringFlag{</span><br><span class="line">			Name : <span class="string">"m"</span>,</span><br><span class="line">			Usage : <span class="string">"limit the memory"</span>,</span><br><span class="line">		},		</span><br><span class="line">	},</span><br><span class="line"></span><br><span class="line">	Action: <span class="function"><span class="keyword">func</span><span class="params">(context *cli.Context)</span> <span class="title">error</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"start runCommand"</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(context.Args()) &lt; <span class="number">1</span> {</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"Missing container command"</span>)</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">var</span> cmdArray []<span class="keyword">string</span></span><br><span class="line">		<span class="keyword">for</span> _, arg := <span class="keyword">range</span> context.Args() {</span><br><span class="line">			cmdArray = <span class="built_in">append</span>(cmdArray, arg)</span><br><span class="line">		}</span><br><span class="line">		tty := context.Bool(<span class="string">"ti"</span>)</span><br><span class="line">		resConf := &amp;subsystem.ResourceConfig{</span><br><span class="line">			MemoryLimit: context.String(<span class="string">"m"</span>),</span><br><span class="line">		}</span><br><span class="line">		Run(tty, cmdArray, resConf)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	},</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Run command  </span></span><br><span class="line"><span class="comment">start a parentprocess with namespace</span></span><br><span class="line"><span class="comment">start a CgroupManager</span></span><br><span class="line"><span class="comment">set the config</span></span><br><span class="line"><span class="comment">store the command</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(tty <span class="keyword">bool</span>, commandArray []<span class="keyword">string</span>, resConf *subsystem.ResourceConfig)</span></span>{</span><br><span class="line">	parent, writePipe := container.NewParentProcess(tty)</span><br><span class="line">	<span class="keyword">if</span> err:= parent.Start(); err!=<span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line">	cgroupManager := cgroupmanager.NewCgroupManager(<span class="string">"mydocker-cgroup"</span>)</span><br><span class="line">	<span class="keyword">defer</span> cgroupManager.Destroy()</span><br><span class="line">	cgroupManager.Set(resConf)</span><br><span class="line">	cgroupManager.Apply(parent.Process.Pid)</span><br><span class="line">	sendInitCommand(commandArray, writePipe)</span><br><span class="line">	parent.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  注意上述NewParentProcess，这是完成程序隔离的重要函数。在下面我们会讲解它。  </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NewParentProcess function:</span></span><br><span class="line"><span class="comment">creates a child precess with namespaces, </span></span><br><span class="line"><span class="comment">run itself in the process, </span></span><br><span class="line"><span class="comment">create a pipe and file for the Run fucntion to write</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewParentProcess</span><span class="params">(tty <span class="keyword">bool</span>)</span> <span class="params">(*exec.Cmd, *os.File)</span></span>{</span><br><span class="line">	fmt.Println(<span class="string">"New parent"</span>)</span><br><span class="line">	readPipe, writePipe, err := NewPipe()</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span> {</span><br><span class="line">		fmt.Printf(<span class="string">"pipe error %v\n"</span>,err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">nil</span></span><br><span class="line">	}</span><br><span class="line">	cmd := exec.Command(<span class="string">"/proc/self/exe"</span>,<span class="string">"init"</span>)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr{</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID |</span><br><span class="line">		syscall.CLONE_NEWNS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWNET |syscall.CLONE_NEWUSER,</span><br><span class="line">		UidMappings: []syscall.SysProcIDMap{</span><br><span class="line">			{</span><br><span class="line">				ContainerID: syscall.Getuid(),</span><br><span class="line">				HostID:      syscall.Getuid(),</span><br><span class="line">				Size:        <span class="number">1</span>,</span><br><span class="line">			},</span><br><span class="line">		},</span><br><span class="line">		GidMappings: []syscall.SysProcIDMap{</span><br><span class="line">			{</span><br><span class="line">				ContainerID: syscall.Getgid(),</span><br><span class="line">				HostID:      syscall.Getgid(),</span><br><span class="line">				Size:        <span class="number">1</span>,</span><br><span class="line">			},</span><br><span class="line">		},</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> tty {</span><br><span class="line">		cmd.Stdin = os.Stdin</span><br><span class="line">		cmd.Stdout = os.Stdout</span><br><span class="line">		cmd.Stderr = os.Stderr</span><br><span class="line">	}</span><br><span class="line">	cmd.ExtraFiles = []*os.File{readPipe}</span><br><span class="line">	<span class="keyword">return</span> cmd, writePipe</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  这便是NewParentProcess的全貌。它启动了一个子cmd，套上了namespace隔离，并且最终要的一点，它使用了以init参数exec /proc/self/exe 这相当与它在子进程中以init参数调用它自己，重新启动。这会覆盖掉当前的数据，堆栈，PID等，从而实现了使用指定的run进程覆盖掉init进程的办法。就这样，我们便得到了一个守护进程以及一个被隔离的容器进程。<br>  该函数返回了writePipe，便是方便将指令传达给子进程。它使用了ExtraFiles属性，意味着在创建子进程时候会额外携带该句柄。在操作系统中，几乎总是分配最小的可用句柄。由于0 1 2为标准输入输出错误句柄，这样在子进程中，就可以直接打开3号句柄获取指令。（虽然硬编码非常不优雅）<br>  在隔离之后，我们还要为其加上限制。这一部分功能是由CgroupManager来完成。这里只实现了内存的限制，我们来从内存，观察CgroupManager是如何工作的。  </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CgroupManager <span class="keyword">struct</span> {</span><br><span class="line">	Path <span class="keyword">string</span></span><br><span class="line">	Resource *subsystem.ResourceConfig</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCgroupManager</span><span class="params">(path <span class="keyword">string</span>)</span> *<span class="title">CgroupManager</span></span>{</span><br><span class="line">	<span class="keyword">return</span> &amp;CgroupManager{</span><br><span class="line">		Path: path,</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CgroupManager)</span> <span class="title">Apply</span><span class="params">(pid <span class="keyword">int</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">	<span class="keyword">for</span> _, subSysIns := <span class="keyword">range</span>(subsystem.SubsystemIns) {</span><br><span class="line">		subSysIns.Apply(c.Path, pid)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CgroupManager)</span> <span class="title">Set</span><span class="params">(res *subsystem.ResourceConfig)</span> <span class="title">error</span></span> {</span><br><span class="line">	<span class="keyword">for</span> _, subSysIns := <span class="keyword">range</span>(subsystem.SubsystemIns) {</span><br><span class="line">		subSysIns.Set(c.Path, res)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CgroupManager)</span> <span class="title">Destroy</span><span class="params">()</span> <span class="title">error</span></span>{</span><br><span class="line">	<span class="keyword">for</span> _, subSysIns := <span class="keyword">range</span>(subsystem.SubsystemIns) {</span><br><span class="line">		<span class="keyword">if</span> err:= subSysIns.Remove(c.Path); err!= <span class="literal">nil</span> {</span><br><span class="line">			fmt.Printf(<span class="string">"error in remove cgroup %v\n"</span>,err)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  可以看到，CgroupManager包含了路径以及资源限制的配置ResouceConfig。而在Run函数中可以看到，CgroupManager实现了Apply,Set,Destroy等方法，这些方法本质上是将ResouceConfig传递给subsystem文件中的SubsystemIns，使用SubsystemIns的多态方法进行调用。<br>  接下来我们来观察subsystem文件声明，来观察它是如何限制资源的。  </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> subsystem</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ResourceConfig <span class="keyword">struct</span> {</span><br><span class="line">	MemoryLimit <span class="keyword">string</span></span><br><span class="line">	CPUShare    <span class="keyword">string</span></span><br><span class="line">	CPUSet      <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Subsystem <span class="keyword">interface</span> {</span><br><span class="line">	Name() <span class="keyword">string</span></span><br><span class="line">	Set(path <span class="keyword">string</span>, res *ResourceConfig) error</span><br><span class="line">	Apply(path <span class="keyword">string</span>, pid <span class="keyword">int</span>) error</span><br><span class="line">	Remove(path <span class="keyword">string</span>) error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	SubsystemIns = []Subsystem{</span><br><span class="line">		<span class="comment">//&amp;CPUSetSubSystem{},</span></span><br><span class="line">		&amp;MemorySubSystem{},</span><br><span class="line">		<span class="comment">//&amp;CPUSubSystem{},</span></span><br><span class="line">	}</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>  在这里可以看出，SubsystemIns是一个Subsystem数组，其中包括MemorySubSystem。Subsystem接口规定了实现的方法，Name,Set,Apply,Remove。<br>  接下来让我们以MemorySubSystem为例子，观察具体的限制是如何实现的。  </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Set function</span></span><br><span class="line"><span class="comment">write the memory limit into the cgroup path</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MemorySubSystem)</span> <span class="title">Set</span><span class="params">(cgroupPath <span class="keyword">string</span>, res *ResourceConfig)</span> <span class="title">error</span></span> {</span><br><span class="line">	<span class="keyword">if</span> subsysCgroupPath, err := GetCgroupPath(s.Name(),cgroupPath,<span class="literal">true</span>); err == <span class="literal">nil</span>{</span><br><span class="line">		<span class="keyword">if</span> res.MemoryLimit != <span class="string">""</span> {</span><br><span class="line">			<span class="keyword">if</span> err := ioutil.WriteFile(path.Join(subsysCgroupPath, <span class="string">"memory.limit_in_bytes"</span>), []<span class="keyword">byte</span>(res.MemoryLimit),<span class="number">0644</span>); err != <span class="literal">nil</span> {</span><br><span class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">"set cgroup memory failed %v"</span>,err)</span><br><span class="line">			}	</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Apply function</span></span><br><span class="line"><span class="comment">Join a process into a cgroup</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MemorySubSystem)</span> <span class="title">Apply</span><span class="params">(cgroupPath <span class="keyword">string</span>, pid <span class="keyword">int</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">	<span class="keyword">if</span> subsysCgroupPath, err := GetCgroupPath(s.Name(),cgroupPath,<span class="literal">false</span>); err == <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">if</span> err := ioutil.WriteFile(path.Join(subsysCgroupPath, <span class="string">"tasks"</span>),[]<span class="keyword">byte</span>(strconv.Itoa(pid)),<span class="number">0644</span>); err!=<span class="literal">nil</span> {</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"set cgroup proc fail %v"</span>,err)</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"get cgroup %s error: %v"</span>,cgroupPath,err)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Remove function</span></span><br><span class="line"><span class="comment">remove the cgroup path</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MemorySubSystem)</span> <span class="title">Remove</span><span class="params">(cgroupPath <span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">	<span class="keyword">if</span> subsysCgroupPath, err := GetCgroupPath(s.Name(),cgroupPath,<span class="literal">false</span>); err == <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> os.Remove(subsysCgroupPath)</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Name function</span></span><br><span class="line"><span class="comment">get its name</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MemorySubSystem)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"memory"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  此处代码有注释，不过多赘述。本质上和之前的demo一样，写入限制文件，将进程放进去，和移除该进程限制所在的文件夹。在这里GetCgroupPath作用是根据mountinfo找到cgroup限制的文件夹，并创建子目录。具体代码可以在仓库内查看。<br>  就此，限制系统demo便完成了。接下来我们来观察init指令执行后，该进程会如何运行。  </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> initCommand = cli.Command {</span><br><span class="line">	Name : <span class="string">"init"</span>,</span><br><span class="line">	Usage : <span class="string">"Init the process"</span>,</span><br><span class="line"></span><br><span class="line">	Action: <span class="function"><span class="keyword">func</span><span class="params">(context *cli.Context)</span> <span class="title">error</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"start initCommand"</span>)</span><br><span class="line">		cmd := readUserCommand()</span><br><span class="line">		err := container.RunContainerInitProcess(cmd[<span class="number">0</span>],cmd[<span class="number">1</span>:])</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	},</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  回到主进程。在创建子进程并且以init为参数执行了/proc/self/exe后，相对应接收的便是init指令。上面可以看到，init指令读取了之前的参数，并且初始化了容器进程。读取指令就像之前所说一样，可以采用fd=3的硬编码打开读取。<br>  接下来我们来看看RunContainerInitProcess该如何运行。  </p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">RunContainerInitProcess function:</span></span><br><span class="line"><span class="comment">mounts the essential environment, </span></span><br><span class="line"><span class="comment">read the command stored by the NewParentProcess,</span></span><br><span class="line"><span class="comment">run the commands</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunContainerInitProcess</span><span class="params">(command <span class="keyword">string</span>, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span>{</span><br><span class="line">	fmt.Printf(<span class="string">"the command is %s\n"</span>,command)</span><br><span class="line">	fmt.Println(<span class="string">"mount start"</span>)</span><br><span class="line">	err :=syscall.Mount(<span class="string">""</span>,<span class="string">"/"</span>,<span class="string">""</span>,syscall.MS_PRIVATE|syscall.MS_REC,<span class="string">""</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	defaultMountFlags := syscall.MS_NOEXEC | syscall.MS_NOSUID | syscall.MS_NODEV</span><br><span class="line">	err = syscall.Mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>,<span class="string">"proc"</span>, <span class="keyword">uintptr</span>(defaultMountFlags),<span class="string">""</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	command,err = exec.LookPath(command)</span><br><span class="line">	<span class="keyword">if</span>(err!=<span class="literal">nil</span>){</span><br><span class="line">		fmt.Printf(<span class="string">"error in finding %s \n"</span>,command)</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	argv := <span class="built_in">append</span>([]<span class="keyword">string</span>{command},args...)</span><br><span class="line">	<span class="keyword">if</span> err := syscall.Exec(command, argv, os.Environ()) ; err!=<span class="literal">nil</span> {</span><br><span class="line">		fmt.Printf(<span class="string">"exec error is %v\n"</span>,err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  可以看到，该函数接收两个参数，command和args，首先实现了chroot防止proc不释放，然后将proc挂载了进来，便于在容器内实现各种操作。之后，使用LookPath解析了指令，并且exec了程序。至此，我们实现了资源的限制，资源的隔离，并且在完成这些配置后运行了程序。一个简单的docker run项目便如此完成了。  </p>
<h2 id="下一步做什么"><a href="#下一步做什么" class="headerlink" title="下一步做什么"></a>下一步做什么</h2><p>  在docker中，除去隔离与限制，最显著的特点便是它的image镜像功能。这能大大减少部署环境的难度。在下一篇文章中，我们将探讨如何实现这一功能。  </p>
<h2 id="总结与后记"><a href="#总结与后记" class="headerlink" title="总结与后记"></a>总结与后记</h2><p>  本篇文章讲解了如何实现一个隔离并且进行限制的小docker程序。在这其中主要熟悉了各种系统调用的作用与使用方法，以及如何进行实现。由于篇幅问题，本文省略了一部分工具代码，具体代码还需要参考仓库内。在仓库中有各种demo的实现。<br>  本文对系统调用的知识主要来自对man文档的翻译，可能存在欠缺。因此有不足的地方欢迎指正。<br>  本篇文章起于11.12，完成于11.16，由于各种原因存在一些拖延，但整体完成时间较长。本文主要也是我自己对于代码的一个复习于归纳。<br>  下一篇文章不存在意外的话预计不会耗费多余一周的时间。敬请期待。  </p>
<script>
        document.querySelectorAll('.not-gallery-item')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="article-licensing box"><div class="licensing-title"><p>初探容器化：隔离，限制与docker run</p><p><a href="https://exgod22356.github.com/Science/初探容器化：隔离，限制与docker-run/">https://exgod22356.github.com/Science/初探容器化：隔离，限制与docker-run/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>王钦砚</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-11-12</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Linux/">Linux</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/">容器化</a></div><div class="sharethis-inline-share-buttons"></div><script src="//platform-api.sharethis.com/js/sharethis.js#property=5ab6f60ace89f00013641890&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Science/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">容器化技术</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Science/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"><span class="level-item">计算机网络复习</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/gallery/endo_yurika.jpg" alt="王钦砚"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">王钦砚</p><p class="is-size-6 is-block">Web Developer</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">42</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">27</p></a></div></div></nav></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Ego/"><span class="level-start"><span class="level-item">Ego</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Gaman/"><span class="level-start"><span class="level-item">Gaman</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Romance/"><span class="level-start"><span class="level-item">Romance</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/Science/"><span class="level-start"><span class="level-item">Science</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ACM/"><span class="tag">ACM</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-Primer/"><span class="tag">C++Primer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GO/"><span class="tag">GO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Gaman/"><span class="tag">Gaman</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Introduction/"><span class="tag">Introduction</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%81%9A%E9%A2%98%E5%AE%B6/"><span class="tag">做题家</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80/"><span class="tag">基础</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%89%E5%85%A8/"><span class="tag">安全</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"><span class="tag">容器化</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91/"><span class="tag">开发</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A8%A1%E6%9D%BF/"><span class="tag">模板</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%87%E7%BC%96/"><span class="tag">汇编</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><span class="tag">编译原理</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tag">网络</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%97%E5%8F%A5/"><span class="tag">诗句</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E7%BC%96%E7%A8%8B/"><span class="tag">面向面试编程</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Icarus" height="28"></a><p class="is-size-7"><span>&copy; 2021 王钦砚</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exgod22356/exgod22356.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><!-- hexo injector body_end start -->
    <script>
    (() => {
        function switchTab() {
            if (!location.hash) {
              return;
            }
            Array
                .from(document.querySelectorAll('.tab-content'))
                .forEach($tab => {
                    $tab.classList.add('is-hidden');
                });
            Array
                .from(document.querySelectorAll('.tabs li'))
                .forEach($tab => {
                    $tab.classList.remove('is-active');
                });
            const $activeTab = document.querySelector(location.hash);
            if ($activeTab) {
                $activeTab.classList.remove('is-hidden');
            }
            const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
            if ($tabMenu) {
                $tabMenu.parentElement.classList.add('is-active');
            }
        }
        switchTab();
        window.addEventListener('hashchange', switchTab, false);
    })();
    </script>
    <!-- hexo injector body_end end --></body></html>