{"pages":[{"title":"","text":"A simple, delicate, and modern theme for the static site generator Hexo. Preview | Documentation | Chat on Gitter 💿 Installation12$ npm install hexo-theme-icarus$ hexo config theme icarus Please refer to Getting Started with Icarus for more details. 🎁 FeaturesCyberpunk Theme VariantTap into the future cyber world with the newly added Cyberpunk theme variant. Inspired by Cyberpunk 2077. Extensive Plugin SupportIcarus includes plentiful search, comment, sharing and other plugins out of the box that makes your blog feature-rich and powerful. Comment Changyan · Disqus · DisqusJS · Facebook · Gitalk · Gitment · Isso · LiveRe · Utterance · Valine Donate Button Afdian.net · Alipay · Buy me a coffee · Patreon · Paypal · Wecat Search Algolia · Baidu · Google CSE · Insight Share AddThis · AddToAny · Baidu Share · Share.js · ShareThis Widgets Google Adsense · Archives · Categories · External Site Links · Recent Posts · Google Feedburner · Tags · Table of Contents Analytics Baidu Statistics · Bing Webmaster · BuSuanZi Web Counter · CNZZ Statistics · Google Analytics · Hotjar · StatCounter · Twitter Conversion Tracking Other Plugins Cookie Consent · LightGallery · Justified Gallery · KaTeX · MathJax · Oudated Browser · Page Loading Animations Colorful Code HighlightIcarus directly import stylesheets from the highlight.js package and makes more than 90 code highlight themes available to you. Atom One Light Monokai Kimbie Dark Flexible Theme ConfigurationIcarus allows you to configure your site on a per-page or per-layout basis. _config.icarus.yml12345widgets: - type: profile position: left - type: recent_posts position: right post.md12345widgets: - type: profile position: left - type: recent_posts position: left _config.page.yml1widgets: null Responsive LayoutGive your audiences best viewing experience with Icarus’s mobile-friendly responsive layout. 🔨 DevelopmentThis project is built with Hexo Inferno.js Stylus Bulma Please refer to the documentation and contributing guide for implementation details. 🎉 ContributeIf you feel like to help us build a better Icarus, you can ✒ Submit a tutorial | 🌏 Add a translation | 🚩 Report a bug | 🔌 Suggest a new feature 📝 LicenseThis project is licensed under the MIT License - see the LICENSE file for details. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"hello world","text":"本文主要介绍各种语言中“hello world”程序的写法。 前置知识： 无 C语言：12345678910111213141516#include &lt;stdio.h&gt;int main(){ printf(\"hello world\\n\"); return 0;}``` ### C++```c++#include &lt;iostream&gt;using namespace std;int main(){ cout&lt;&lt;\"hello world\"&lt;&lt;endl; return 0;} Python 31print(\"hello world\") Pyhton 21print \"hello world\" PHP123&lt;?phpecho \"hello world\"?&gt; Java因为代码过长而懒得写。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/hello-world/"},{"title":"The Road Not Taken","text":"The Road Not Takenby Robert Frost Two roads diverged in a yellow wood,And sorry I could not travel bothAnd be one traveler, long I stoodAnd looked down one as far as I couldTo where it bent in the undergrowth Then took the other, as just as fair,And having perhaps the better claim,Because it was grassy and wanted wear;Tough as for that the passing thereHad worn them really about the same, And both that morning equally layIn leaves no step had trodden black.Oh,I kept the first for another day!Yet knowing how way leads on to way,I doubted if I should ever come back. I shall be telling this with a sighSomewhere ages and ages hence:Two roads diverged in a wood, and I–I took the one less traveled by,And that has made all the difference. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/the-road-not-taken/"},{"title":"The first blog","text":"这里是我的第一篇博客。 由于贫穷的原因，懒得续费阿里云和域名，现将博客搭到Github上。将来也将陆续将各种文章写在这里。原来写过的文章也会补在这里。预计有时间去注册个免费域名。关于分区：科学/Science ：技术类文章。浪漫/Romance ：生活，人文类文章。克苏鲁/Cthulhu ：奇奇怪怪的文章。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Ego/the-first-blog/"},{"title":"When You Are Old","text":"When You Are Oldby William Butler Yeats When you are old and grey and full of sleep,And nodding by the fire, take down this book,And slowly read, and dream of the soft lookYour eyes hd once, and of their shadow deep; How many loved your moments of glad grace,And loved your beauty with love false or true,But one man loved the pilgrim soul in you,And loved the sorrows of your changing face; And bending down beside the glowing bars,Murmur, a little sadly, how Love fled.And paced upon the mountains overhead.And hid his face amid a crowd of stars. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/when-you-are-old/"},{"title":"Sonnet 18","text":"Sonnet 18by William Shakespeare Shall I compare thee to a summer’s day?Thou art more lovely and more temperate.Rough winds do shake the darling buds of May,And summer’s lease hath all too short a date. Sometime too hot the eye of heaven shines,And often is his gold complexion dimm’d;And every fair to fair sometime declines,By chance or nature’s changing course untrimmed. But thy eternal summer shall not fade,Nor lose possession of that fair thou ow’st;Nor shall Death brag thou wander’st in his shade,When in eternal lines to time thou grow’st. So long as men can breathe or eyes can see,So long lives this, and this gives life to thee. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/sonnet-18/"},{"title":"How Do I Love Thee","text":"How do Love Theeby Elizabeth Barrett Browning How do I love thee? Let me count the ways.I love thee to the depth and breadth and heightMy soul can reach, when feeling out of sightFor the ends of Being and ideal Grace.I love thee to the level of everyday’sMost quiet need, by sun and candlelight.I love thee freely, as men strive or Right;I love thee purely, as they turn for Praise.I love thee with the passion put to useIn my old griefs, and with my childhood’s faith.I love thee with a love I seemed to loseWith my lost saints. I love thee with the breath,Smiles, tears, of all my life; and if God choose,I shall but love thee better after death. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/how-do-i-love-thee/"},{"title":"When We Two Parted","text":"When We Two Partedby Lord Byron When we two partedIn silence and tears,Half broken-hearted,To sever for years,Pale grew thy cheek and cold,Colder thy kiss;Truly that hour foretoldSorrow to this. The dew of the morningSank chill on my brow–It felt like the warningOf what I feel now.Thy vows are all broken,And light is thy fame:I hear thy name spoken,And share in its shame. They name thee before me,A knell to mine ear;A shudder comes o’er me–Why wert thou so dear?They know not I knew thee,Who knew thee too well–Long, long shall I rue thee.Too deeply to tell. In secret we met–In science we grieveThat thy heart could forget,Thy spirit deceive.If I should meet theeAfter long years,How should I greet thee?With silence and tears. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/when-we-two-parted/"},{"title":"She Walks in Beauty","text":"She Walks in Beautyby Lord Byron She walks in beauty, like the nightOf cloudless climes and starry skies;And all that’s best of dark and brightMeet in her aspect and her eyes;Thus mellowed to that tender lightWhich heaven to gaudy day denies? One shade the more, one ray the less,Had half impaired the nameless graceWhich waves in every raven tress,Or softly lightens o’er her face;Where thoughts serenely sweet express,How pure, how dear they’re dwelling-place. And on that cheek, and o’er that brow,So soft, so calm, yet eloquent,The smiles that win, the tints that glow,But tell of days in goodness spent,A mind at peace with all below,A heart whose love is innocent! document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/she-walks-in-beauty/"},{"title":"To His Coy Mistress","text":"To His Coy Mistressby Andrew Marvel Had we but world enough, and time,This coyness, lady, were no crime.We would sit down, and think which wayTo walk, and pass our long love’s day.Thou by the Indian Ganges’ sideShouldst rubies find: I by the tideOf Humber would complain. I wouldLove you ten years before the Flood,And you should, if you please, refuseTill the conversion of Jews.My vegetable love should growVaster than empires, and more slow;An hundred years should go to praiseThine eyes and on thy forehead gaze;Two hundred to adore each breast;But thirty thousand to the rest;An age at least to every part,And the last age should show your heart;For, Lady, you deserve this state,Nor would I love at lower rate.But at my back I always hearTime’s wingèd chariot hurrying near;And yonder all before us lieDeserts of vast eternity.Thy beauty shall no more be found,Nor, in thy marble vault, shall soundMy echoing song: then worms shall tryThat long preserved virginity,And your quaint honour turn to dust,And into ashes all my lust:The grave’s a fine and private place,But none, I think, do there embrace.Now therefore, while the youthful hueSits on thy skin like morning dew,And while thy willing soul transpiresAt every pore with instant fires,Now let us sport us while we may,And now, like amorous birds of prey,Rather at once our time devourThan languish in his slow-chapt power.Let us roll all our strength and allOur sweetness up into one ball,And tear our pleasures with rough strifeThorough the iron gates of life:Thus, though we cannot make our sunStand still, yet we will make him run. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/to-his-coy-mistress/"},{"title":"洛谷P2357守墓人题解","text":"题解 前置知识： C++ 数据结构 题目链接P2357 守墓人 解题思路线段树or树状数组裸题本题解用的可区间更新的树状数组数据范围会爆int,所以用long long 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long long sum[200010];long long lazytag[200010];int n;inline int lowbit(int x){ return x&amp;(-x);}long long suum(int i,long long k[]){ long long s=0; while(i&gt;0) { s+=k[i]; i-=lowbit(i); } return s;}void update(int x,long long a,long long k[]){ while(x&lt;=n) { k[x]+=a; x+=lowbit(x); }}void uprange(int x,int y,long long a){ update(x,-(x-1)*a,sum); update(x,a,lazytag); update(y+1,y*a,sum); update(y+1,-a,lazytag);}long long rangesum(int i,int j){ long long s=0; s+=suum(j,sum)+suum(j,lazytag)*j; s-=suum(i-1,sum)+suum(i-1,lazytag)*(i-1); return s;}int main(){ int f; scanf(\"%d%d\",&amp;n,&amp;f); long long i,j,x,y,su; int t; memset(sum,0,sizeof(sum)); memset(lazytag,0,sizeof(lazytag)); for(i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;t); update(i,t,sum); } for(i=0;i&lt;f;i++) { scanf(\"%lld\",&amp;t); if(t==1) { scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;su); uprange(x,y,su); } if(t==2) { scanf(\"%lld\",&amp;su); uprange(1,1,su); } if(t==3) { scanf(\"%d\",&amp;su); uprange(1,1,-su); } if(t==4) { scanf(\"%lld%lld\",&amp;x,&amp;y); printf(\"%lld\\n\",rangesum(x,y)); } if(t==5) { printf(\"%lld\\n\",rangesum(1,1)); } }} document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E6%B4%9B%E8%B0%B7p2357%E5%AE%88%E5%A2%93%E4%BA%BA%E9%A2%98%E8%A7%A3/"},{"title":"洛谷P4712题解","text":"题解 前置知识： C++ 题目链接P4712 「生物」能量流动 解题思路贪心的思想，要想要获得的能量最多，就要保证流失的能量最少。由题目可知，ri+1 &gt;=ri，后面的食量不小于前面的食量，后面的可以吃到后面的生物，前面的只能吃前面的生物，由此可以得到贪心策略：从前往后尽量满足食物。复杂度据说是O(nlogn),但我不会算……实测跑得很快。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;double a[100005];int main(){ int n,i,left=0,d,j,flag = 0; double x,tmp; scanf(\"%d%lf\",&amp;n,&amp;a[0]); for(i=1; i&lt;=n; i++) { scanf(\"%lf%d\",&amp;x,&amp;d); tmp = x; for(j=left; j&lt;=d; j++) { // printf(\"%f %f\\n\",x,a[j]); if(a[j]&lt;1e-9) left = j; if(x&lt;=a[j]/5.0+1e-10) { a[j]-=5*x; a[i]=tmp; x=0; break; } else { x=x-(a[j]/5.0); a[j]=0; left++; } } if(x&gt;1e-9) { printf(\"-1\\n\"); return 0; } } double sum=0; for(i=left;i&lt;=n;i++) { sum+=a[i]; } printf(\"%f\\n\",sum/5.0);} document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E6%B4%9B%E8%B0%B7p4712%E9%A2%98%E8%A7%A3/"},{"title":"AC自动机模板","text":"题解 前置知识： C++ 数据结构 题目链接P3808 【模板】AC自动机（简单版）P3808 【模板】AC自动机（加强版） 解题思路第一题：在文本串中，寻找有多少模式串出现过。第二题：在文本串中，找到出现次数最多的模式串，并且输出。如有多个结果则输出多个。两题的本质都是AC自动机。先构建Trie树，然后依据KMP的思想，构造fail树。然后进行查询。代码的主要区别在query和insert。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#define N 500010using namespace std;queue&lt;int&gt;q;struct AC{ int c[N][26],val[N],fail[N],cnt; void ins(char *s) //建立trie树 下标存储字母 内容存取跳转 { int len = strlen(s); int now =0; for(int i=0; i&lt;len; i++) { int v = s[i]-'a'; if(!c[now][v]) c[now][v]=++cnt; now = c[now][v]; } val[now]++; } void build()//构建fail树 { for(int i=0; i&lt;26; i++) //初始化 if(c[0][i]) fail[c[0][i]]=0,q.push(c[0][i]); while(!q.empty()) { int u=q.front(); q.pop(); for(int i=0; i&lt;26; i++) { if(c[u][i]) fail[c[u][i]]=c[fail[u]][i],q.push(c[u][i]);//跳转 else c[u][i]=c[fail[u]][i]; } } } int query(char *s) { int len = strlen(s); int now=0,ans=0; for(int i=0; i&lt;len; i++) { now = c[now][s[i]-'a']; for(int t=now; t&amp;&amp;~val[t]; t=fail[t]) ans+=val[t],val[t]=-1; } return ans; }} ac;int n;char p[1000005];char ch[155][75];int main(){ scanf(\"%d\",&amp;n); for(int i=1; i&lt;=n; i++) scanf(\"%s\",p),ac.ins(p); ac.build(); scanf(\"%s\",p); int ans = ac.query(p); printf(\"%d\\n\",ans); return 0;}``` ```c++#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#define N 1000005using namespace std;queue&lt;int&gt;q;int ans[155];struct AC{ int c[N][26],val[N],fail[N],cnt; //建立trie树 下标存储字母 内容存取跳转 v代表模式串的次序 void ins(char *s,int v) { int len = strlen(s); int now =0; for(int i=0; i&lt;len; i++) { int v = s[i]-'a'; if(!c[now][v]) c[now][v]=++cnt; now = c[now][v]; } val[now]=v; } void build()//构建fail树 { for(int i=0; i&lt;26; i++) //初始化 if(c[0][i]) fail[c[0][i]]=0,q.push(c[0][i]); while(!q.empty()) { int u=q.front(); q.pop(); for(int i=0; i&lt;26; i++) { if(c[u][i]) fail[c[u][i]]=c[fail[u]][i],q.push(c[u][i]); //跳转 else c[u][i]=c[fail[u]][i]; } } } void query(char *s) { int len = strlen(s); int now=0; memset(ans,0,sizeof(ans)); for(int i=0; i&lt;len; i++) { now = c[now][s[i]-'a']; for(int t=now; t; t=fail[t]) ans[val[t]]+=1; } }} ac;int n;char p[1000005];char ch[155][75];int main(){ while(~scanf(\"%d\",&amp;n)) { if(n==0) return 0; memset(ac.c,0,sizeof(ac.c)); memset(ac.val,0,sizeof(ac.val)); memset(ac.fail,0,sizeof(ac.fail)); ac.cnt=0; memset(p,0,sizeof(p)); memset(ch,0,sizeof(ch)); memset(ans,0,sizeof(ans)); q=queue&lt;int&gt;(); for(int i=1; i&lt;=n; i++) scanf(\"%s\",ch[i]),ac.ins(ch[i],i); ac.build(); scanf(\"%s\",p); ac.query(p); int tmp = 0; for(int i=1;i&lt;=n;i++) { if(tmp&lt;ans[i]) tmp = ans[i]; } cout&lt;&lt;tmp&lt;&lt;endl; for(int i=1;i&lt;=n;i++) { if(tmp==ans[i]) { printf(\"%s\\n\",ch[i]); } } } return 0;} document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/ac%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%A8%A1%E6%9D%BF/"},{"title":"LCA模板","text":"题解 前置知识： C++ 数据结构 题目链接P3379 【模板】最近公共祖先（LCA） LCALCA 即最近公共祖先前序遍历中 LCA(S) 出现在所有 S 元素之前 后序遍历在 S 之后两点的最近公共祖先必定处在树上两点间的最短路上两点距离 *d(u,v)=h(u)+h(v)-2h(lca(u,v))** 。 代码#include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int maxn = 500005; struct EDGE { int t, next; } e[2 * maxn]; //邻接表存边 //t表示指向的点 next表示下条边 //head[x]表示x的点存的首条边的号码 int dep[maxn], fa[maxn][22], lg[maxn], head[maxn]; int tot; void add(int x, int y) { e[++tot].t = y; e[tot].next = head[x]; head[x] = tot; } void dfs(int f, int fat)//f表示当前节点 fat表示父亲节点 { dep[f] = dep[fat] + 1;//深度+1 fa[f][0] = fat;//f的父亲是fat for (int i = 1; (1&lt;&lt; i) &lt;= dep[f]; i++) fa[f][i] = fa[fa[f][i - 1]][i - 1]; //f的2**i的祖先，是f 的2**(i-1)的祖先的2**(i-1)的祖先 //2**(i-1)+2**(i-1)==2**i for (int i = head[f]; i; i = e[i].next) if (e[i].t != fat) { dfs(e[i].t, f); } } int lca(int x, int y) { if (dep[x] &lt; dep[y]) { swap(x, y); } while (dep[x] &gt; dep[y]) { x = fa[x][lg[dep[x] - dep[y]] - 1]; //跳到同一深度 } if (x == y) return x;//如果一个是另一个祖先，直接返回 for (int k = lg[dep[x]]-1; k &gt;= 0; k--) if (fa[x][k] != fa[y][k]) x = fa[x][k], y = fa[y][k]; return fa[x][0]; } int n, m, s; int main() { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt;= n - 1; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); add(y, x); } dfs(s, 0); for (int i = 1; i &lt;= n; i++) { lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i); cout&lt;&lt;lg[i]&lt;&lt;\" i:\"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;endl; //预先算出log_2(i)+1的值，用的时候直接调用就可以了 } for (int i = 1; i &lt;= m; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", lca(x, y)); } return 0; } document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/lca%E6%A8%A1%E6%9D%BF/"},{"title":"OAuth 2.0","text":"前置知识： 网络 OAuth 2.0令牌 有时间范围，过期失效 可以被所有者撤销，立刻失效 有权限范围令牌四种形式： 授权码： 先申请授权码，再用该码获取令牌 隐藏式： 直接发放令牌 密码式： 直接告诉密码 凭证式： 用于命令行，在命令行下请求令牌令牌使用： 请求头加上authorization字段更新令牌： 一次性发放两个令牌，一次用于更新，一个用 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/oauth-2-0/"},{"title":"C++Primer Learning #0","text":"写在前面：C++Primer Learning预计会成为我的博客的一个系列，其中主要针对的是我个人对于C++语言的所不熟悉，不了解的部分，主要是个人的学习，所以更新内容不确定，对于C++Primer的部分内容会有省略。 目录：待更新 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/c-primer-learning-0/"},{"title":"RESTful api设计","text":"前置知识： 网络 RESTful api设计协议： https域名： 使用专有域名，如https://api.example.com 简单,无扩展的话可以 https://expamle.com/api/版本： 放入url或http头 https://api.example.com/v1/路径： 只能有名词，与数据库表格名相对应，用复数形式，如 https://api.example.com/v1/zoos/HTTP动词： GET (SELECT) 取出资源 POST （CREATE） 新建资源 PUT (UPDATE) 改变后的完整资源的更新 PATCH (UPDATE) 改变资源属性 DELETE (DELETE) 删除资源 HEAD 获取资源原数据 OPINION 知晓哪些属性可以改变参数过滤： ?limit=10 返回记录数量 ?offset=10 返回记录开始位置 ?page=1&amp;perpage=10 每页记录数 ?sotredby=name&amp;order=asc 排序 ?x_type_id=1 筛选条件Status Code： 200 OK 201 created 202 accepted 已经进入排队 异步任务 204 no content 删除成功 400 invalid request 发出请求有错误 401 unauthorized 无权限 403 forbidden 授权但禁止访问 404 not found 不存在 406 not acceptable 请求格式不可得(要xml得到json) 410 gone 永久删除 422 unprocessable entity 创建对象时候验证错误 500 internal server error 服务器发生错误 502 bad gateway 服务器在充当网关或代理时，从其试图完成请求时访问的上游服务器接收到无效响应。错误信息： 返回键值对： error : xxx返回结果： GET /collection: 返回资源对象的列表 /collection/resource: 返回单个 POST /collection: 新生成的对象 PUT /collection/resource: 完整资源对象 PATCH /collection/resource: 同上 DELETE /collection/resource: 返回空文档Hypermedia API： 在返回结果中提供连接连向其他api，便于连向下一步其他： 身份认证用OAuth 2.0框架 多用json document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/restful-api%E8%AE%BE%E8%AE%A1/"},{"title":"docker安装与搭建qqbot","text":"前置知识： 网络 python docker安装与搭建qqbotdocker是什么Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。 它是目前最流行的 Linux 容器解决方案。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 比起虚拟机，docker具有运行速度快，体积小，占用资源少等诸多优点，这让docker十分流行。 docker 安装docker存在社区版与付费的企业版，本次使用的是免费的社区版。 本次使用的是windows的docker，可以点进下载链接进行下载，具体安装流程可以参考官方文档。 值得注意的是，官网并没有提供windows家庭版的安装流程，笔者在这里给出家庭版的流程。 1.安装Hyper-V 将下列代码保存为.cmd文件并以管理员身份运行,执行完毕后重启电脑 123456789pushd \"%~dp0\"dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum &gt;hyper-v.txtfor /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:\"%SystemRoot%\\servicing\\Packages\\%%i\"del hyper-v.txtDism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 2.解决Containers Windows Feature is not available问题 虽然网上教程没有遇到这个问题，但笔者遇到了。解决方法为将下列代码保存为.bat文件，并且以管理员权限运行并重启电脑 123456pushd \"%~dp0\"dir /b %SystemRoot%\\servicing\\Packages\\*containers*.mum &gt;containers.txtfor /f %%i in ('findstr /i . containers.txt 2^&gt;nul') do dism /online /norestart /add-package:\"%SystemRoot%\\servicing\\Packages\\%%i\"del containers.txtDism /online /enable-feature /featurename:Containers -All /LimitAccess /ALLpause 3.修改注册表 在cmd执行以下命令 1REG ADD \"HKEY_LOCAL_MACHINE\\software\\Microsoft\\Windows NT\\CurrentVersion\" /v EditionId /T REG_EXPAND_SZ /d Professional /F 重启后注册表会还原，但不会影响linux容器正常使用。 4.安装installer 注意不要勾选windows容器的选项，一路next就行了。 docker运行docker容器运行的基本流程：下载或打包程序的image-&gt;将image run起来，形成容器。 1.注册账号 docker需要账号才能运行，在此不过多赘述 2.修改配置文件，添加镜像源 在windows界面可以通过gui,在setting-&gt;docker engine中修改，然后重启docker，可以改成如下： 1234\"registry-mirrors\": [ \"https://dockerhub.azk8s.cn\", \"https://hub-mirror.c.163.com\" ], 3.image文件 docker将应用程序和依赖全部打包在image文件中，并且通过该文件生成容器。image文件是通用的，可以将一台机器上的image文件上放入另一台的image进行使用。image文件也可以继承另一个image文件进行开发。 image文件可以上传到仓库进行共享，而docker hub作为官方的仓库，是最为重要的仓库。 下面通过运行实例hello-world进行说明。 首先，可以执行以下命令将官方的hello-world的image文件拉至本地。 1docker image pull hello-world 等待抓取成功后，可以通过以下命令查看image文件 1docker image ls 4.run 通过以下命令运行hello-world的image文件 1docker run hello world 你会看到docker官方给出的信息，并且该容器会在信息结束后自动终止。但并非所有容器都是如此。 至此，简单的docker操作就结束了，下面研究有关将项目搭进docker的应用问题。 项目简介这次搭建的是构建在flask上的基于coolq-http的qqbot项目。项目内使用了redis进行数据的存储。本次将redis和BotServer分别打包进入容器中，实现redis和BotServer两个容器之间的通信，实现BotServer与宿主机上5700端口上的coolq-http通信。 本次项目所有python代码都在BotServer.py文件中。 关于bot怎么写在此不过多赘述，可以详见coolq-http的文档。 下面将详细解释搭建过程。 整理项目依赖项目基于flask实现，并且使用了redis通信模块。我们需要将所有的依赖写进requirement.txt文件中，并放入和项目的BotServer.py文件所在的文件夹。对于python项目，可以使用pipreqs进行自动编写。使用也很简单，cmd进入项目所在文件夹，执行以下命令即可。 12pip install pipreqspipreqs ./ --encoding=utf8 –encoding为可选项，但在windows下不加上这个选项会报错。 编写dockerfiledocker image的创建是通过docker一步步执行dockerfile来实现的。所以在编写好requirement.txt后，我们需要编写dockerfile。 在BotServer.py和requirement.txt所在的目录下，新建一个名为Dockerfile的文件(注意，没有后缀名)，将以下内容写进去。 1234567891011FROM python:3.6-slim WORKDIR /appCOPY . /appRUN pip install -r ./requirements.txt EXPOSE 5701CMD [\"python\",\"BotSever.py\"] FROM语句，含义是继承了官方的3.6-slim版本的python镜像。冒号表示标签，这里标签便是3.6-slim。 WORKDIR语句，指明接下来的工作目录为/app COPY语句，将本目录的所有文件复制到/app目录下去 RUN语句，指在build过程中执行该指令。这里执行的指令指使用pip将requirements.txt里的头文件全部安装。 EXPOSE语句，将端口5701开放。 CMD语句，在run的时候执行，在这里是指用python运行BotServer.py文件。 改写代码在打包成image之前，我们需要改写代码中的ip以及端口，来实现容器和容器之间的通信以及容器和宿主机的通信。 在原来的代码中，我们连接redis的方法如下： 1self.redis_pool = redis.ConnectionPool(host='127.0.0.1', port=6379, password='', db=0) host指向了127.0.0.1,也就是本机ip,但这在容器中是行不通的。由于隔离，无法直接将本机ip和容器中的127.0.0.1连接起来，我们可以将这一行改写成如下形式： 12self.redis_pool = redis.ConnectionPool( host='redis', port=6379, password='', db=0) 使用了redis代指本机ip,在run的时候，可以通过–link选项，将redis所在的容器与该项目所在的容器连接起来。 同理，我们需要将flask监听的地址，从127.0.0.1，改为0.0.0.0，来接受任何连接。 1self.bot_server.run(host=\"0.0.0.0\", port=5701) 在发送信息时，我们需要想宿主机的coolq-http的端口发送信息，就需要将代码中本机的url改为宿主机的url。在windows中，我们可以将127.0.0.1改为host.docker.internal。例如： 12url = \"http://127.0.0.1:12345/send_group_msg\" # 原来的urlurl = \"http://host.docker.internal:12345/send_group_msg\" 这样我们就能实现容器和宿主机的连接。 打包image在改写完代码后，我们就可以打包image了。用cmd进入项目所在目录，执行以下命令： 1docker build -t qqbot . -t用来指定image的名字，**.** 点代表本文件夹。打包需要一些时间下载。在完成后，我们就可以进行下一步。 安装运行redisredis安装是较为简单的一步，与hello word类似，我们可以直接从官方镜像源下载并且安装redis,执行命令如下： 12docker pull redis:latestdocker run -itd --name redis-test -p 6379:6379 redis 其中-p是将宿主机的6379端口(前一个6379)映射到容器的6379端口，从而便于外部访问。-d命令为后台运行。 -i: 以交互模式运行容器，通常与 -t 同时使用， -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用。 运行qqbot我们搭建好了redis的镜像并成功运行了起来，搭建好了bot的镜像，现在所需要做的便是将bot的镜像运行起来。在run之前，我们先查看redis所在的容器。可以执行以下命令查看: 1docker ps -a 在本台电脑上，显示如下： 2c30a28c3979 redis “docker-entrypoint.s…” 24 hours ago Up 3 hours 0.0.0.0:6379-&gt;6379/tcp redis-test 将最前面的container id复制下来，将之前改写的redis和容器地址使用–link连接起来，执行以下命令，便可以将bot跑起来了： 1docker run --name bot -itd --link 2c30a28c3979:redis -p 5701:5701 qqbot 这样，我们就成功将qqbot搭建进docker之中。 后记本文主要是记录自己踩过的一些坑，将整个流程写了一遍，其中改写代码的环节虽然很短，但耗费了我一天半的时间。有些问题很玄学，比如安装installer时报错，重启电脑就解决了。有时候pip时间过长会报错，重启docker就解决了。 为什么不把coolq也放进docker里，主要是因为懒…… 本次没有将qqbot全部代码展现出来，主要是因为代码质量目前还欠佳。等我有时间（没时间）将代码优化后，再来详细讲解bot。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/docker%E5%AE%89%E8%A3%85%E4%B8%8E%E6%90%AD%E5%BB%BAqqbot/"},{"title":"面向面试编程-蓄水池算法","text":"前置知识： 数学 面向面试编程-蓄水池算法题目要求给定一个极其大的数据流，大到无法存入内存，要求在所有数据中随机选取k个元素。 解法：蓄水池算法假设读取第i个数据，从1开始计数。如果i小于等于k，则存入蓄水池。如果i大于k，则随机取从1到i之间的随机数m，如果m处于1到k中，那么将i元素替换蓄水池中m元素。证明对于蓄水池中的元素，被选中的概率是不被蓄水池外的元素替换掉的概率。即k×(k+1)×…×(N-1)/((k+1)×(k+2)×…×(N)) = k/N。对于蓄水池外的元素，假设位置i，那么概率为选中的概率乘以不被后面元素替代的概率。即(k/i)×(i/(i+1))×…×((N-1)/N) = k/N。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E7%BC%96%E7%A8%8B-%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/"},{"title":"git的使用","text":"前置知识： 无 git的使用前言我发现我这个废物到现在没有系统性学习git，于是写了本文。主要用于加强记忆，备忘。 介绍git，又叫分布式版本控制系统。版本管理系统，意味着对项目的版本进行管理，可以退回到历史版本，也可以在历史版本基础上开发新版本，可以将分支的版本合并到主要版本从而便于开发。分布式意味着每台电脑上都是完整的版本，而非版本的一部分。 基本概念git主要有三个主要的基本概念：工作区， 版本库，暂存区。工作区：即工作目录，主要进行开发的位置。版本库：一般在工作目录中的隐藏文件夹.git目录中，git用于管理的工作目录。暂存区：类似于存放项目内文件的各种类修改操作。存放于index文件中。具体实现可以参考原理，本文不过多概述。 git常用命令git init：初始化工作目录，创建.git文件夹从而便于开始管理。git add：接文件名，在工作目录中搜索对应文件名，并且将文件存入暂存区。git commit：提交所有或者部分暂存区文件到仓库。一般加-m参数来写提交注释。一定要写提交注释。git status：查看仓库当前状态。git diff：查看未提交记录与提交过的具体文件差别。git log：查看log。git reset：有三种模式。可以使用–hard来更新工作区，暂存区，仓库所有文件到目标commit记录（参数为commit 的sha1）或者回退到之前几个版本（参数为HEAD^。尖号数量代表往前几个版本），通常用于回滚版本。另外两种模式可参照对应文档。git reflog：查看命令的日志。git checkout –filename：将工作区的文件修改撤销掉，换成最新的暂存区内或者版本库内的文件。git reset HEAD file：撤销暂存区的文件修改。git rm：版本库中删除对应文件。如果确实删除后需要提交。git clone：从对应库中拷贝项目。git mv：移动或者重命名对应文件。git branch：创建分支。git checkout：移动到分支。git merge：合并分支。如果出现冲突则手动解决冲突后git add对应文件。git push：将文件推到远程库。git pull：将远程库拉到本地库并覆盖。git stash：将当前目录保存起来，之后可以切换分支改bug，改完后用git stash pop来恢复现场。git rebase：将多个commit记录合并并接到另一个分支之后。用于整合commit记录。 总结主要包含了git的常用命令以及基本概念，各种参数不全面，各种功能描述也可能不全面或者有误，但主要功能基本准确。现在虽然ide帮我们做了很多，但学习一些git的概念对开发还是有意义的。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/git%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"计算机网络复习","text":"前置知识： 网络 计算机网络复习主要考点选择题/填空题/简答题/综合计算 物理传输介质种类： 引导型传输媒体： 双绞线 同轴电缆 光缆 非导引型传输媒体： 地面微波 卫星通信 网络协议定义，三要素： 定义：为进行网络中数据交换而定义的规则或标准 三要素： 语法：数据与控制信息的结构或格式 语义：发出何种控制信息，完成何种动作，作出何种响应 同步：事件实现顺序的说明 CSMA/CD，CSMA/CA工作原理： CSMA/CD：载波监听多点介入/碰撞检测 多点接入：总线型网络 载波监听：检测传输过程中是否有其他计算机发送，就是不停检测信道 碰撞检测：边发送边监听。检测到电压变化幅度过大则停止检测 使用该协议，只能半双工通信 在检测到空闲后，推迟一个随机的时间，然后重传 CSMA/CA：载波监听多点介入/碰撞避免 碰撞避免：减少碰撞发生的概率 发送数据之前先检测信道，检测为空闲则等待一个帧调节时间后发送，目的接受后则在等待一个短帧间隔后发送ACK，然后开始通信。源站还需要将占用时间发送给其他站。然后在忙变空闲后，在等待一个帧调节时间后进入争用窗口期，所有发送的站都要执行退避算法，随机选择一个时间间隙开启计时器，遇到忙则冻结。 子网路由与主机路由区别： 路由到子网和路由到主机 数据链路层功能，透明传输实现： 链路是从一个节点到相邻结点的一段物理线路 数据链路则是在链路基础上增加必要的硬件软件 向该层用户提供透明可靠的基本服务 三个问题：封装成帧 透明传输 差错检测 封装成帧：规定数据最大传送单元MTU，添加首部SOH，尾部EOT 转义数据报 透明传输：转义数据报 添加ESC字符转义 差错检测：CRC 仅检测不纠错 MAC地址/IP地址： 硬件地址，又称为物理地址与MAC地址，就是适配器地址或者适配器标识符。单个站地址 多播地址 全球管理 本地管理 IP地址：网络层以及以上使用地址，逻辑地址，路由器只根据IP进行选择 链路层只能看见MAC帧，IP层屏蔽了许多细节 ARP：使用ARP高速缓存 建立ARP映射表 动态更新 ARP过程：广播ARP请求分组 得到ARP响应 写入映射表 TCP链接，三次握手四次挥手： 三次握手 客户打开链接 创建传输控制模块TCB 客户向服务器发送SYN=1以及自己的序号X 服务器返回SYN=1 ACK=1 自己的序号Y ack数字X+1 客户机返回ACK=1 序号x+1 ack=y+1 并可以传输数据 四次挥手： 客户主动关闭，向服务发送FIN与序号 服务器照旧发送ACK与seq ack 服务器向客户确认FIN 发送ACK seq ack与上次ack相同 客户照旧确认 客户等待2MSL后关闭 可靠传输实现： 滑动窗口：以字节为单位。通过窗口滑动和累计确认来实现。有缓存用于存储乱序到达或者接受但未被读取的数据 RTT计算：RTT_new = (1-a)RTT_old + a(RTT_sample) a=0.125 超时时间RTO计算：RTO = RTT + 4(RTTd) RTTd_init = 0.5(RTT) RTTd_new = (1-b)RTTd_old + b(abs(RTT_new-RTT_sample)) b=0.25 选择确认：头部加上确认边界，防止重传浪费 TCP拥塞控制算法，计算： 拥塞控制：防止过多的数据注入到网络中全局性的过程 流量控制是点到点通信量控制 开环控制：设计网络时候将拥塞因素考虑周到;闭环控制：检测网络系统拥塞状态，将信息传达到可采取行动的地方 调整网络解决问题 慢开始：幂函数开始 直至达到门限 拥塞避免：每过一个RTT则增加1 快重传：收到一个即使顺序不对也确认 快恢复：3ACK后减半开始拥塞避免 3ACK减半 超时则归为1 门限都减半 AMQ：主动队列管理 小于最小门限则保留 超过最大门限则丢弃 在中间则随机丢弃 IP子网相关计算，超网： IP可以分为网络号，子网号，主机号 IP可以划分为A，B，C类，对应255.0.0.0 255.255.0.0 255.255.255.0 子网掩码与地址取AND，得到网络号地址。子网号位数决定子网数量，通常去掉全0和全1。子网主机数同理。 每一个CIDR地址数都是2的整数幂次倍数，相当包含网络数为2的网络数位数减去CIDR位数幂次 CRC计算： 被除数左移除数位数-1位，处以被除数，得到余数并加上。 余数为0则没有差错 RIP路由计算： 基于距离向量的路由选择协议 距离为跳数 仅和相邻路由器交换信息，交换信息为自己的路由表，按照固定时间间隔交换 距离算法：将表距离加1,下一跳转为目标主机，更新 实现简单 开销较小 好消息传得快 坏消息传的慢 网络规模小，最多为15 收敛慢 网络拓补结构： 边缘部分，核心部分 边缘部分：用户直接使用的，处于互联网的所有主机，又叫端系统。通信方式可分为CS方式和P2P方式 客户-服务方式：服务请求方和服务提供方。客户想服务器请求，不需要特殊硬件和复杂操作系统。服务可同时接受多个请求，需要很强大性能与软件支持。 P2P：对等连接方法 核心部分：给端系统提供服务的。路由器，交换机等。 局域网可分为星形网 环状网 总线网 交换技术种类： 电路交换特点：端到端建立专用物理通路 建立链接 通话 释放链接 在通话全部时间里，两个用户始终占用端到端通信资源 分组交换特点：采用存储转发技术 整块发送报文 将报文加上必要头部发送 需要传输路径 电路交换时延：电路建立连接时间S+报文总量X/数据率B+链路个数K multiply 链路传播时延B 分组交换时延：发送完最后一个分组结束 即经过k-1次转发 时延=数据总长度x/数据率b+（k-1）分组长度p/数据率b+k(传播时延b) 编码技术种类： 不归零制：正电平为1 负电平为0 归零制：正脉冲为1 负脉冲为0 曼彻斯特编码：向下跳变为1 向上跳变为0 差分曼彻斯特：从边界开始跳变为0 边界不跳变为1 调幅：载波的振幅 01表示不同振幅 调频：载波的频率 01对应不同频率 调相：初始相位随基带变化而变化 一般采用混合调制 正交振幅调制 信道复用技术： 频分复用：占用不同的频道带宽 时分复用：在不同时间占用同样的频带宽度 切分时间为固定长度组 统计时分复用：先集中器，再分配时间 波分复用：光的频分复用 码分复用：用户之间正交 网络互连，互连的设备，层次： 计算机，集线器，路由器，交换机等，手机等智能机器 网络将许多计算机连接在一起 互连网将许多网络通过路由器连接在一起 多ISP结构互联网，有主干ISP 地区ISP 本地ISP 互联网交换就诶点IXP允许两个网络直接相连而不必经过最上层主干ISP OSI IEEE体系结构分层： OSI七层模型：应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 OSI缺点：缺少实际经验 商业驱动 实现复杂 效率地下 制定周期长 运作不合理 实际运用为TCP/IP标准 IEEE：802.11 数据链路层分为逻辑链路控制子层 介质访问控制子层 面向连接，无连接应用，区别： 通信前建立连接，完成后释放连接/尽最大努力 传输控制协议TCP：提供面向连接的，可靠的数据传输服务，传输单位为报文段 用户数据报协议UDP：无连接的，尽最大努力的数据传输服务，传输单位为用户数据报 网络定义，网络分类： 计算机网络主要是由一些通用的 可编程的硬件互联而成 这些硬件并非专门用来实现某一特定目的 可编程的硬件能用来传输不同类型数据 并且支持广泛和日益增长的应用 广域网WAN：几十到几千公里;城域网MAN：一个城市;局域网LAN：用于微型计算机或工作站相连;个人区域网PAN：个人使用的电子设备互联 公用网：电信公司建造大型网络;专用网：特殊业务服务，如军队网络。 DNS作用： DNS根服务器采用任播技术 即相同IP但物理位置不同 因而总能找到最近的服务器 递归查询 迭代查询 将域名解析为IP 动态网页实现技术： CGI通用网关接口：定义动态文档如何创建，输入数据如何提供给应用程序 输出结果如何使用 CGI程序又叫CGI脚本 服务器推送技术 TCP开销大 活动文档技术 把工作交给浏览器 HTML，XML区别： HTML：超文本标记语言 展示文档 XML：可扩展标记语言 用于数据存储，传输等。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"},{"title":"C++ 实现线程池","text":"前置知识： c++ 操作系统 C++实现线程池前言 本文使用C++基本库，实现了固定线程数量的线程池。 线程池基础 对于了解过线程的人而言，线程池的概念并不难理解。为了避免频繁地创建与销毁线程，节省开销，预先创建一定数量的线程作为“池子”，并使用池内的线程来进行使用，节省开销。 理论并不困难，但在实现上面，由于现代C++自身的晦涩难懂，标准库的难以使用，而且网络上的教程不说人话，使得使用C++开发线程池存在不少困难。本文便理清这些困难，帮助更好使用C++。 thread介绍 在C++11之后，标准库增加了thread库，使得c++有了原生的线程支持。这里简单介绍一下库的几个方法。 构造函数：thread只有默认构造函数和移动构造函数，没有拷贝构造。在默认构造中，声明如下： 12template&lt; class Function, class... Args &gt;explicit thread( Function&amp;&amp; f, Args&amp;&amp;... args ); 它接收函数与参数，并执行。在实际运用中，除了传递函数指针，也可以直接使用lambda表达式。 方法：thread有多种方法，具体如下： | Observers | | | ———————————————————— | ———————————————————— | | joinable | checks whether the thread is joinable, i.e. potentially running in parallel context (public member function) | | get_id | returns the id of the thread (public member function) | | native_handle | returns the underlying implementation-defined thread handle (public member function) | | hardware_concurrency[static] | returns the number of concurrent threads supported by the implementation (public static member function) | | Operations | | | join | waits for a thread to finish its execution (public member function) | | detach | permits the thread to execute independently from the thread handle (public member function) | | swap | swaps two thread objects (public member function) | 在本次中主要使用了detach，即，将线程放开，到后台运行。 实现思路 可以看到，c11的thread库在线程创建时候便需要与一个函数相关联，无法更改。这里采用的实现思路为：将需要执行的函数当作对象，存入池子中。每个线程先阻塞，在函数存入时便唤醒，获取函数，得到函数参数，并执行该函数，在完成后再次阻塞。 由此，我们可以得到每个thread的主体内容： - 一个指针，指向线程池主体，来获取锁与函数。 - 函数主体为死循环，在检测到池子内有任务后便获取函数并执行。在检测到函数主题关闭后退出循环。在其他时刻阻塞。 - thread理应detach，在后台运行。 根据此流程，我们也可以得到线程池主体控制程序的内容： - 锁，用于协调各个线程。 - 任务队列，用于存放函数。 - 条件变量，用于唤醒线程。 - 标识退出的变量。 基本思路理清，我们可以写出对应代码。 Controller类 Controller类对应的便是控制程序。如上所述，我们构建相应的成员。 1234567891011121314template &lt;class F, class Args, class Ret&gt;class Controller{public: std::mutex mu;//锁 std::queue&lt;std::tuple&lt;F, Args, Ret &amp;&gt;&gt; tasks;//任务队列。存放函数的地方。 std::condition_variable cond_v;//条件变量，用于阻塞和唤醒线程 bool closed = false;//标志是否结束 Controller() = default;//默认构造函数 Controller(const Controller &amp;ctrl)//拷贝构造函数。 { //由于条件变量无法拷贝构造，这里只是占位，并不会实际发生拷贝 }}; 模板的三个参数分别对应函数主体，函数参数，函数返回值。因此返回值在队列里存放的为左引用。 拷贝构造函数不实际执行拷贝，只是占位便于代码编写。 就像之前上一部分所述一样，我们实现了控制类的编写。 ThreadPool 类 代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970template &lt;class F, class Args, class Ret&gt;class ThreadPool{public: Controller&lt;F, Args, Ret&gt; controller;//控制类 std::shared_ptr&lt;Controller&lt;F, Args, Ret&gt;&gt; shr_ptr;//指向控制类的指针 被所有线程共享 //构造函数。构造出给定数量的线程并且放入后台执行。 ThreadPool(size_t size) : controller() { this-&gt;shr_ptr = std::make_shared&lt;Controller&lt;F, Args, Ret&gt;&gt;(this-&gt;controller); //循环构造给定数量thread 并进入让其执行死循环 for (size_t i = 0; i &lt; size; i++) { std::thread([ptr = shr_ptr] { std::unique_lock&lt;std::mutex&gt; mux(ptr-&gt;mu); for (;;) { if (!ptr-&gt;tasks.empty())//如果任务非空，则从队列里获取并执行任务 { auto current = std::move(ptr-&gt;tasks.front()); F fun = std::get&lt;0&gt;(current); Args arg = std::get&lt;1&gt;(current); Ret &amp;re = std::get&lt;2&gt;(current); ptr-&gt;tasks.pop(); mux.unlock(); re = fun(arg); mux.lock(); } else if (ptr-&gt;closed)//退出循环 { break; } else//进入阻塞 { ptr-&gt;cond_v.wait(mux); } } }).detach(); } } //析构函数 先上锁通知类已经关闭 再利用条件变量通知所有线程 ~ThreadPool() { if ((bool)shr_ptr) { { std::lock_guard&lt;std::mutex&gt; mu(shr_ptr-&gt;mu); shr_ptr-&gt;closed = true; } shr_ptr-&gt;cond_v.notify_all(); } } //执行函数 先上锁写入任务，再通知一个线程进行执行 void excute(F &amp;&amp;f, Args &amp;&amp;args, Ret &amp;ret) { { std::lock_guard&lt;std::mutex&gt; mu(shr_ptr-&gt;mu); //上锁 析构时候解锁 便于写入 shr_ptr-&gt;tasks.emplace(std::tuple&lt;F, Args, Ret &amp;&gt;(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args), ret)); } shr_ptr-&gt;cond_v.notify_one(); }}; 如注释所写一般，我们使用c++实现了线程池。 总结 本次花了一晚上时间，使用c++实现了一个线程池。虽然只是固定数量的线程池，但对于c++并发而言，算是一个很好的入门。就我个人而言，本次也复习了不少c++相关知识，更接触了不少现代c++特性。可以看出，本文在左值右值上并没有过多阐述，因为本人对完美转发掌握尚不熟练。本次部分代码也是依葫芦画瓢。之后的c++学习过程中还得强化概念与使用方法。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/c-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"title":"容器化技术","text":"容器化技术作为当今热门的技术，已经形成的成熟的应用以及活跃的生态。越来越多的程序采用容器技术来进行封装。容器技术极大地改善了程序，简化了程序部署。其轻量化的特性也被许多解决方案所青睐。 本文旨在从零开始，构建一个类docker的容器应用，并且实际运行，同时对其中的原理进行剖析。 容器化技术本机环境：Linux version: 4.19.0-10-amd64 (debian-kernel@lists.debian.org) (gcc version 8.3.0 (Debian 8.3.0-6)) #1 SMP Debian 4.19.132-1 (2020-07-24)GO version: go1.13.6 linux/amd64 参考书籍《自己动手写Docker》 陈显鹭 王炳燊 秦妤嘉著 目录 初探容器化：隔离，限制与docker run 容器镜像与持久化 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF/"},{"title":"简易正则转NFA实现","text":"本文将介绍简易正则转nfa的一个python实现。 前置知识 python 编译原理 简易正则转NFA实现简介 NFA，即非确定性有限状态自动机。他将文本匹配转化为状态的转移，给予初态与终态。当一串文本随着输入，能成功从初态转换到终止状态，即为匹配成功。并且由于其为非确定型，相同的文本匹配模式，可能存在的NFA形态会很多。 正则表达式，即一串用于描述文本匹配规则的文本。通过特殊字符组合成规则字符串，用于过滤文本。 本项目将实现使用python，将简易正则，即包含连接运算，克林星号运算，或操作运算的正则表达式，转换到等价NFA的过程。 NFA实现 状态机本身相当于图，包含边集与点集。由于我们不需要实际进行匹配，只需要转换，因此可以省略部分点，只保留起点与终点。但我们需要展示所有边，因而边不可以省略。 根据上述描述，我们来定义类： 123456class NFA: def __init__(self,ch): self.head = 1 self.tail = 2 self.lines = [[1,ch,2]] 初始化方法，起点与终点，初始化的边。我们便拥有了一个最简单的NFA。在此基础上，我们再来实现相应运算功能。 连接操作 连接操作最为简单。我们只需要将第二个NFA起点连接到第一个NFA终点即可。注意结点序号问题。我们需要标识每个结点，这时候只需要将接在后面的NFA的每个结点的序号增加前NFA节点个数-1的数量即可。 12345def and_NFA(self,NFA_b): NFA_b.add_num(len(self)-1) for line in NFA_b.lines: self.lines.append(line) self.tail = NFA_b.tail 或运算操作 或运算稍为复杂，但也不难。或运算相当于将两个NFA并联起来。我们只需要增加头节点，尾结点，再在中间并联两个NFA即可。同样，注意结点序号问题。 1234567891011def or_NFA(self,NFA_b): self.add_num(1) NFA_b.add_num(len(self)+1) for line in NFA_b.lines: self.lines.append(line) self.lines.append([1,'~',self.head]) self.lines.append([1,'~',NFA_b.head]) self.lines.append([self.tail,'~',NFA_b.tail+1]) self.lines.append([NFA_b.tail,'~',NFA_b.tail+1]) self.tail = NFA_b.tail+1 self.head = 1 克林星号运算 克林星号运算所表示的NFA并不复杂。它表示前面的字符可以匹配0次或者多次。这里我们需要有一个循环的思想。即起点可以直接跳到终点，终点也可以直接跳到起点。那么增加两条边即可。 123def kleen_NFA(self): self.lines.append([self.head,'~',self.tail]) self.lines.append([self.tail,'~',self.head]) 由于我们只实现简易正则，实现三个运算即可。在完成NFA方法构建后，我们来关注正则的解析问题。 正则表达式解析 正则的解析如同计算器一样，需要符号栈与文本栈，并且要处理优先级问题。但我们只实现了三种运算，优先级问题并不困难。 对于克林运算，我们可以直接对文本栈顶进行运算。它的优先级最高。 对于连接运算，我们需要放入符号栈，等待遇到或运算清理栈时候来处理。 对于或运算，当检测到或时候，我们可以将栈顶的连接运算全部清空，直到遇到或运算或者左括号为止。再放入符号栈。 对于括号运算，左括号直接进入符号栈，右括号则清理文本栈，直到遇到左括号为止。 当算法结束后，若文本栈未规约完成，则继续弹出两个文本与一个符号，进行运算，直至规约完成。 对于上述规则，我们可以得到代码.此处连接使用点来代替。calculate函数代表将符号作用于文本栈： 12345678910111213141516171819202122232425262728293031def parse(s): sign_stack = [] nfa_stack = [] for ch in s: if ch=='(': sign_stack.append(ch) elif ch == ')': while len(sign_stack) != 0 and sign_stack[-1] != '(': tmp = sign_stack[-1] sign_stack.pop() nfa_stack[-2] = calculate(tmp,nfa_stack[-2],nfa_stack[-1]) nfa_stack.pop() elif ch == '*': nfa_stack[-1] = calculate(ch,nfa_stack[-1],None) elif ch == '|': while len(sign_stack) != 0 and sign_stack[-1] == '.': sign_stack.pop() nfa_stack[-2] = calculate('.',nfa_stack[-2],nfa_stack[-1]) nfa_stack.pop() sign_stack.append(ch) elif ch == '.': sign_stack.append(ch) else : nfa_stack.append(NFA(ch)) while len(nfa_stack)&gt;1: ch = sign_stack[-1] sign_stack.pop() nfa_stack[-2] = calculate(ch,nfa_stack[-2],nfa_stack[-1]) nfa_stack.pop() return nfa_stack[0] One more thing 最后一个问题。在默认的正则表达式中没有连接运算符。我们可以硬编码一下增加连接运算符的规则，然后将原来的表达式转换为可以解析的表达式。 123456789101112131415161718192021222324def RegexToNFA(s): ret = s[0] for i in range(1,len(s)): pre = s[i-1] now = s[i] if isCharacter(pre) and isCharacter(now): ret +='.' ret += now elif isCharacter(pre) and now == '(': ret +='.' ret += now elif pre == ')' and isCharacter(now): ret +='.' ret += now elif pre == '*' and isCharacter(now): ret +='.' ret += now elif pre == '*' and now == '(': ret +='.' ret += now else : ret += now print(ret) return parse(ret) 规则阐述不必多说。上述可能有遗漏，欢迎指正。 总结 本文提供了一个简单正则转NFA的python实现。之所以使用python是因为写着简单，数据结构随意。在最开始我想拿scheme写，但api还是不熟悉。最后选用了python。 本文技术含量不高，纯粹为课堂记录。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E7%AE%80%E6%98%93%E6%AD%A3%E5%88%99%E8%BD%ACnfa%E5%AE%9E%E7%8E%B0/"},{"title":"Go知识点","text":"一些GO的知识点。 Go的知识点编译相关Go可以生成汇编，采用下列指令进行查看： 1go build -gcflags -S main.go Go可以生成汇编优化过程。通过GOSSAFUNC，可以生成html文件来交互查看。 SSA：静态单赋值。即每个变量只会被赋值一次，便于优化。同一变量名字会生成不同后缀来区分。 GO可以生成各种机器码，包括wasm。 TODO：待到学完编译原理在看。 数据结构数组只有类型和大小完全相同，才能认为是同一数据类型，可以用==比较。 【…】T{1,2,3}与【3】T{1,2,3}使用上完全相同，只是语法糖。 当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上。 当元素数量大于 4 个时，会将数组中的元素放到静态存储区初始化然后拷贝到栈上。 简单的越界错误可以由编译器发现，复杂的则需要运行时。运行时发现越界时候会panicIndex和runtime.goPanicIndex。运行时会插入代码，检查边界，越界则panic，通过则Load或Store。 切片slice有data指针，len长度，cap容量。 切片初始化可以有make创建，字面量初始化，或者截取数组或者切片的一部分。 切片逃逸：1、如果函数外部没有引用，则优先放到栈中；2、如果函数外部存在引用，则必定放到堆中； 切片很小并且非发生逃逸，会在栈或静态存储区初始化。否则在堆区初始化。 cap足够时候append覆盖时候会优化情况。不够则会调用growslice扩容并且拷贝过去。扩容规则如下： 如果期望容量大于当前容量的两倍就会使用期望容量； 如果当前切片的长度小于 1024 就会将容量翻倍； 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量； 大致容量如此，接下来还需要进行对齐操作。 拷贝时候会memove，这比依次拷贝性能更好，耗费资源仍然较多。 哈希表开放地址法:填空。 拉链法：挂上链表。 map底层为hmap，由若干个bmap桶组成。每个桶通常可以存8个元素。 通过哈希值低8位找到桶，在通过高八位对比tophash数组来查找。 分配时候若桶满则可以放入溢出桶，用overflow指针指过去。元素少于25个则直接hash，多余25则创建两个数组存储键值，然后for哈希过去。 在make时候，则会检查内存是否足够，获取哈希种子，计算最少桶数量，创建保存桶数组。 仅获取value的访问采用mapaccess1，会计算哈希值，查找桶，查找tophash，并且访问。mapaccess2就多个返回值。 当装载因子超过6.5或使用太多溢出桶会触发扩容 。扩容将桶数量翻倍，通过growWork触发，访问时候访问旧桶，写入则分流过到新桶。 删除和赋值逻辑类似。 字符串只读字符串，由data指针和len组成。 如果要修改，则要转换成为【】byte来进行。开销并不小。 逃逸分析取地址或者逃出了函数，按照此原则分析变量分配方法 语言基础函数调用在c语言中，函数调用参数使用寄存器与栈实现。6个一下为寄存器。以上放入栈。 Go采用栈来入参和出参，简化了实现，不必考虑架构。 Go无论是基本类型，结构体，还是指针，都会传值拷贝。 接口接口引入中间层，实现上下游解耦。在GO中，实现接口所有方法就算实现了接口。 interface{}不是任意类型。当我们转换成interface时候，类型就是interface。 函数接收者不是指针的时候，能通过结构体和指针使用方法。是指针的时候，只能通过指针使用方法。不能同时存在同名方法定义两次。 nil在转换成interface类型时候会包含以前的类型信息，因此转换后不是nil。 对于空interface而言，结构体为eface，不含方法，之包含类型与数据指针。_type类型中有数据大小，哈希值来快速确定类型是否相当，equal判断多个对象是否相等。 非空interface包含itab指针与数据指针。itab中包含对上述_type的哈希，来确认目标类型与具体类型是否相等。有fun动态大小数组，当成虚函数表，存储函数指针。同时包含原类型type和接口类型interfacetype。 非指针变量转换为接口会拷贝到堆上。 断言switch a.(type)时候会检查哈希值。 反射TypeOf接受空接口参数，转换为emptyInterface类型，并且获取typ并返回。 ValueOf则是先将其逃逸到堆上，热爱华南虎使用unpackEface将传进来的转换为emptyInterface结构体，包装成Value结构体并且返回。 更新变量时候，会检查变量是否对外公开。然后调用assignTo返回新反射对象，并且覆盖原始反射变量。 eface用于运行时，emptyInterface用于反射。 for range在for _,v:=range arr时候，系统会创建一个变量v，将数组值在迭代中覆盖过去，这导致v的地址在循环中不变。 使用for循环清空数组，切片，哈希表时候，会编译成arrayClear，加速过程，开销并不大。 range循环不会永动机，因为最开始会调用len来获取终止条件。 哈希表遍历：随机选一个正常桶开始，遍历桶内，桶外溢出桶，再按顺序来。 selectselect与switch类似，但状态只能是chan收发状态。 多个条件都满足时候，switch会随机执行，避免饥饿状态。 select的case用结构体表示 select不存在case直接阻塞，只有一个case则变成单if，一个case一个default会改写成if,else，默认情况下会将case转换为结构体，调用selectgo函数获取一个可行的结构体，使用一连串if观察是哪个被选中了。 轮询会随机开始，加锁顺序则是按地址排序。 调用select先确认轮询顺序加锁顺序，之后如果能立即执行则立即执行并返回，不能则创建sudog结构体，加入相关的收发队列，挂起等唤醒，唤醒了则遍历去找。 deferdefer会在函数结束执行，而不是代码作用域结束。 defer参数的值是在调用时候计算的。 defer采用延迟链表，最早只有堆上分配，后期有栈上分配，开放编码优化。 根据defer数量和return数量判断是否开放编码优化。直接插入到函数返回前。 panic recoverpanic时候，会放到panic链表最前面，然后获取defer链表，执行，最后panic。 程序的恢复由gopanic执行。取出栈顶指针和pc，执行recovery函数，recovery则跳回去。 make newmake需要判断类型，new则只用初始化指针，申请空间。 context基本用法如下： 12345678910111213141516171819202122232425func main() { ctx, cancel := context.WithCancel(context.Background()) go watch(ctx, \"【监控1】\") go watch(ctx, \"【监控2】\") go watch(ctx, \"【监控3】\") time.Sleep(10 * time.Second) fmt.Println(\"可以了，通知监控停止\") cancel() //为了检测监控过是否停止，如果没有监控输出，就表示停止了 time.Sleep(5 * time.Second)}func watch(ctx context.Context, name string) { for { select { case &lt;-ctx.Done(): fmt.Println(name, \"监控退出，停止了...\") return default: fmt.Println(name, \"goroutine监控中...\") time.Sleep(2 * time.Second) } }} chanchan结构体内包含队列元素个数，循环队列长度，数据指针，发送waitq，接收waitq。waitq表示双向链表，包含向前的sudog和向后的sudog。 发送前会先上锁，再判断是否closed。直接发送：先拷贝到目标地址，再标记接收goroutine，放进处理器runnext等待执行。带缓冲区：计算下一个可以存储数据的地方，再将数据拷贝到缓冲区，增加索引与计时器。缓冲区为循环数组。阻塞式发送：则先获取发送数据的goroutine，再获取sudog设置阻塞发送相关信息，加入发送等待队列，沉睡并等待唤醒，唤醒后首尾。 接收：如果不在缓冲区且就绪，则直接拷贝。在缓冲区，则拷贝并且移动缓冲区指针。chan为空则挂起，关闭则检查缓冲区，无数据则返回。如果发送队列存在挂起的，则从缓冲区拷贝到接收，再将发送挂起的拷贝进缓冲区。缓冲区存在数据则直接读，否则挂起。 GMP模型G表示goroutine，M表示线程，P表示处理器。G类似线程，包含自己的内存，栈，寄存器状态，再调度器保存或者恢复上下文的时候用到。M操作系统线程，GOMAXPROCS控制活跃数量，默认为CPU核数，减少系统调度开销。P提供上下文环境，可以调度线程上等待队列。调度时间点：主动挂起，系统调用，协作式调度，系统监控。 垃圾收集三色标记法：黑色，白色与灰色。 黑色代表活跃的对象，已经被访问过，并且本对象引用的其他对象也被标记过。 灰色代表活跃的对象，已经被访问，但存在引用的其他对象未被访问。 白色代表潜在的垃圾，未被访问过。 当开始运行时候，根对象被标记为灰色对象，然后之后的程序只从灰色对象向外扩展。类似BFS。当灰色集合不存在的时候，遍历结束，回收白色的垃圾。GC是一个过程，中途可能改变对象的引用指向，可能会增加，可能会删除，因此需要遵守两个不变性之一：强三色不变性-黑色不会指向白色；弱三色不变性-黑色指向的白色的可达路径上一定有灰色（白色肯定能被灰色扩展到）引入写屏障技术，在写进内存前做一些干涉，保证gc的正确性即可。存在两种写屏障：Dijkstra插入写屏障与Yuasa删除写屏障。Dijkstra插入写屏障：在黑色需要指向白色时候，将白色染成灰色即可。但由于栈上的对象会被认为成根对象，因此要么为栈上的对象添加写屏障，要么在标记结束后再次扫描栈。Yuasa删除写屏障：在删除对象的时候，将被删除的对象标记为灰色。这样保证了弱三色不变性，但回收精度低，有的需要下一轮才能回收。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/go%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"容器镜像与持久化","text":"本文为容器化技术系列文章的第二篇。本文将把容器技术与文件系统，压缩文件相结合，并且实现commit命令，用于保存镜像文件。 前置知识 Linux Go 容器镜像与持久化容器镜像overlay文件系统 从本文开始，我们将把参考资料《自己动手写docker》的原版中实现的镜像构造进行改造，其中最根本原因是原书采用了AUFS，而在笔者的系统上，没有AUFS，因而采用了docker也在使用的overlayfs进行替代。 overlayfs与AUFS类似，在linux 3.18内核便被支持。overlay允许一个读写目录树覆盖到另一个只读目录树上，所有对文件的修改都在上层的可写层进行。它与其他的UFS不同，在打开文件后的所有操作都转换到底层或者上层的文件系统。这使得文件系统的实现得到简化。 overlay简单的用法如下所示。 1mount -t overlay overlay -o lowerdir=/lower,upperdir=/upper,workdir=/work /merged 从上述的指令可以看出，指令指定了底层文件只读层，可以有多层;上层文件可写层;工作文件是提供给文件系统便于生成。merged则是最后合并的挂载目录。注意底层，顶层与工作的目录的文件系统，overlay在这方面有很多限制。 在执行完成上述挂载指令后，我们可以在文件夹中进行读写文件的尝试。具体不在本文中呈现。下面我们将其挂入容器系统之中。 busybox基础镜像 这里我们采用busybox作为基础的镜像。busybox是一个精简的镜像，包含了很多UNIX环境的常用命令。busybox可以使用docker export得到tar，并且解压得到新的rootfs。 我们实现的基础思路是：使用pivot_root将整个root文件系统移动进busybox所提供的目录，使用overlay将其创建为只读层，然后创建只写层，提供给容器进行运行操作。在容器结束运行后，还原这一切。 首先，我们将busybox解压，得到其rootfs。 12345678910111213141516171819func CreateReadOnlyLayer(rootURL string) error { //注意文件位置 将tar放到指定位置 busyboxURL := rootURL + \"busybox/\" busyboxTarURL := rootURL + \"busybox.tar\" exist, err := PathExists(busyboxURL) if err != nil { return fmt.Errorf(\"path exist error:%v\", err) } if exist == false { if err := os.Mkdir(busyboxURL, 0777); err != nil { return fmt.Errorf(\"mkdir root error: %v\", err) } //解压文件到文件夹 if _, err := exec.Command(\"tar\", \"-vxf\", busyboxTarURL, \"-C\", busyboxURL).CombinedOutput(); err != nil { return fmt.Errorf(\"tar error: %v\", err) } } return nil} 然后，创建读写层与工作层，将其挂入目录。此处不必多说。 之后，在mount各种需要的东西之前，我们要使用pivot_root系统调用，将整个系统的根文件移动进入该文件夹。 123456789101112131415161718192021222324252627282930func pivotRoot(root string) error { fmt.Println(\"pivot rooting\") //重新挂在本目录 便于使得新老root不在同一文件系统下 if err := syscall.Mount(root, root, \"bind\", syscall.MS_BIND|syscall.MS_REC, \"\"); err != nil { return fmt.Errorf(\"mount bind error: %v\", err) } pivotDir := filepath.Join(root, \".pivot_root\") if err := os.Mkdir(pivotDir, 0777); err != nil { return fmt.Errorf(\"mkdir error: %v\", err) } if err := syscall.Mount(\"\", \"/\", \"\", syscall.MS_PRIVATE|syscall.MS_REC, \"\"); err != nil { fmt.Printf(\"mount / error: %v\\n\", err) return err } if err := syscall.PivotRoot(root, pivotDir); err != nil { return fmt.Errorf(\"pivotroot error: %v\", err) } if err := syscall.Chdir(\"/\"); err != nil { return fmt.Errorf(\"chdir error: %v\", err) } //卸载原rootfs 清除临时文件 pivotDir = filepath.Join(\"/\", \".pivot_root\") if err := syscall.Unmount(pivotDir, syscall.MNT_DETACH); err != nil { return fmt.Errorf(\"umount error: %v\", err) } return os.Remove(pivotDir)} 在上述函数中，我们首先为了使得老root和新root不再一个文件系统下，将root重新mount了一次，使得新老root不在同一个文件系统下。然后进行系统调用，更改当前目录，删除临时文件。 在此之后，就像之前的文件系统一样，我们挂载必要的，如proc等。我们得到了以根目录为虚拟环境的容器进程。 至于卸载方面，我们只需要umount我们所挂载的目录，并且删除文件夹，即可。在此也不过多阐述。 但我们需要的不仅是虚拟的环境，我们还有持久化的需求。这里我们引入数据卷的概念，来存放我们持久化的数据。 持久化mount –bind 就像标题所写，这里我们采用mount –bind的方法来进行持久化。mount –bind相当于将两个目录连接起来。我们可以在得到持久化的目录名后，使用bind将容器外的目录与容器内的目录连接起来。同时在最后退出的时候，先卸载对应目录，此时文件便留在了容器外的目录。我们便实现了持久化的目标。 同时我们要注意，我们需要增加新的command选项，解析字符串，在这里便不过多展示。 volume代码实现 这里展示的仅仅是开始mount和结束umount的过程，增加命令与解析由于篇幅暂不展示。原理如上述所说。由于go的异常处理，代码会显得颇为冗杂。但本意如上所示。 1234567891011121314151617181920212223242526272829303132333435func MountVolume(rootURL string, mntURL string, volumeURLs []string) error { //volumeURLs格式为 [容器外目录,容器内目录] parentURL := volumeURLs[0] if err := os.Mkdir(parentURL, 0777); err != nil { if exist, _ := PathExists(parentURL); exist == false { return fmt.Errorf(\"error in mkdir parentURL: %v\", err) } } containerURL := volumeURLs[1] containerVolumeURL := mntURL + containerURL fmt.Println(containerVolumeURL) if err := os.Mkdir(containerVolumeURL, 0777); err != nil { return fmt.Errorf(\"error in mkdir containerVolumeURL: %v\", err) } //挂载目录 cmd := exec.Command(\"mount\", \"--bind\", parentURL, containerVolumeURL)//绑定 cmd.Stderr = os.Stderr cmd.Stdout = os.Stdout if err := cmd.Run(); err != nil { return fmt.Errorf(\"Mount volume error :%v\", err) } return nil}func DeleteVolumeMountPoint(mntURL string, volumnURL string) error { //卸载 cmd := exec.Command(\"umount\", \"-v\", mntURL+volumnURL) cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr if err := cmd.Run(); err != nil { return fmt.Errorf(\"delete mount volume error : %v\", err) } return nil} 在完成这些工作后，我们可以尝试数据卷是否工作正常。下面是本机的一个运行实例。可以看见，在完成数据卷工作后，数据确实得到了持久化。 1234567891011121314151617181920212223242526root@wqy:/media/wqy/新加卷/projekts/Go/src/mydocker# sudo ./mydockerdev run -ti -v /volume:/containerVolume shstart runCommandNew parentmounting /home/wqy/mnt//containerVolume[/volume /containerVolume]your command is shstart initCommandreading user commandthe command is shmount start/home/wqy/mntpivot rootingthe current wd is // # lsbin etc root usrcontainerVolume home sys vardev proc tmp/ # cd containerVolume//containerVolume # lsa.txt/containerVolume # echo \"sfsfsf\" &gt;b.txt/containerVolume # exitwqy@wqy:/volume$ cat b.txtsfsfsf 镜像打包 镜像打包也是我们需要的一项功能。在这里我们提供一个简单的实现方法：在为退出前，将所有文件打包成tar保存到外面即可。 在具体实现上，我们还需要增加指令，解析参数。我们这里使用commit命令，在容器运行时候进行打包。 12345678910func commitContainer(imageName string) error { mntURL := \"/home/wqy/mnt/\" rootURL := \"/home/wqy/\" imageTar := rootURL + imageName + \".tar\" fmt.Println(imageTar) if _, err := exec.Command(\"tar\", \"-czf\", imageTar, \"-C\", mntURL, \".\").CombinedOutput(); err != nil { return fmt.Errorf(\"tar error: %v \", err) } return nil} 这里提供的简单的打包解决方案。同样，解析命令的操作便不在此展示。 至此，我们实现了一些与容器文件相关的简单操作。 下一步做什么 在下一步，我们将继续扩展容器的功能，实现一些常用的docker指令，使得我们的容器更加接近docker，可用性更强。在下一篇文章中，我们将探讨这些功能。 总结与后记 这属于容器化技术第二篇文章。本文只介绍了一些简单的文件功能以及实现。文章较上一篇篇幅明显减少，主要原因还是实现的功能不太复杂，原理也不需要过多介绍。完成时间也较于上一篇文章所预期的时间晚了整整一个星期。这期间也有参加比赛，拖了一下的缘故。 写完本文主要是对文件的知识有所回顾。在本文中，我尝试了第一次自己设计解决方案，如使用bind，这是在原本书上没有写的。书上的解决方案在本机上无法实现，便自己想了一个。后来才发现，docker也使用了这样的技术。 下一篇技术含量会比本篇要更高。但预计时间也更长，可能是一个月左右，敬请期待。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/"},{"title":"杂乱知识点","text":"一些杂乱的知识点 杂乱知识点 01目录TODO protobuf为啥快 数据压缩程度高 解析速度快 protobuf基本使用tag|value方法存储数据。tag中包含数据序号与数据类型。从而避免了json的字符串解析。tag生成办法： 123static int makeTag(final int fieldNumber, final int wireType) { return (fieldNumber &lt;&lt; 3) | wireType;} 在上述代码中，fieldNumber为序号，wireType为数据类型。有符号整型使用zigzag编码，减少了存储空间。非varint类型数字采用小端序列存储。字符串类型采用**tag|len|str|**方法存储。 有符号整型的压缩ZigZag主要是将无符号数字0,1,2,3转换为有符号数字0,-1,1,-2等。之后我们可以压缩数据。将32位数据每次取7位，如果非最低字节则补1,其余补0.然后将低字节与高字节反转。（小端） 断点调试原理断点调试，即在断点处插入int 3指令，OS向进程发送SIGTRAP信号，使得当前进程暂停，交给父进程去处理。 按下ctrl-c后会发生什么发送SIGINT信号给前台进程组所有进程，强行终止程序执行。 进程间通信IPC InterProcessCommunication 匿名管道PIPE 半双工，只能一个方向流动，固定读写端 只能有亲缘关系进程之间的通信 类似于文件，可以read write，但仅存于内存 命名管道FIFO 可以在无关进程之间交换数据 属于特殊的文件形式存在于文件系统中，有路径名 消息队列 包含消息类型，存在优先级，有特定格式 读取时候可以按类型读取 信号量 发送信号，主要用于同步进程 原子操作 可以计数 共享内存 最快，直接读内存，效率高 可以多进程同时操作，需要同步 通常和信号量同时使用 共享内存不需要涉及内核，所以最快 TOP-K问题 quick select：快排思想，省去一半 平均On 最坏On2 建堆 nlogk 使用priority_queue来建，默认是大于号 建堆可以分布式 可以哈希去重 B树与B+树B树 多叉树 关键词集合分布在整个树中 性能优异，等价于二分查找 关键词只出现在一个结点中 自动层次控制 B+树 用于数据库，文件系统等 数据稳定有序，自底向上插入，性能稳定 结点关键词只用于索引，不存储 叶子结点存储数据，并且添加链表指针 HTTP状态码见restful api 布隆过滤器使用k个哈希函数，将key映射成k个整数，然后将对应二进制位置为1。有一定概率判断出错。无法删除。 红黑树红黑树，自平衡的类平衡树，非严谨平衡。有以下特点 结点或黑或红 根是黑的 红色无法相连，黑色可以 根到所有叶子结点经过的黑色结点个数相同 插入结点过程 新插入的结点为红色 如果为根结点，则标记成黑色 如果parent不是黑色且不是root uncle为红 将parent and uncle标记为黑 祖父标记为红 与祖父相同颜色 uncle为黑 触发旋转 新结点为左左，则提绳子 左右，则将亲子换位，然后左左 右右同理 右做，则换位后右右 统计性能比avl更好 进程与线程 进程 系统进行资源调度和分配的基本单位，实现操作系统的并发。 进程内的线程共享堆，全局变量，静态变量，文件等。 进程之间同步基于IPC。 不同进程之间挂掉不影响 线程 CPU调度和分配的基本单位，实现进程内部的并发。 有独立的寄存器组，指令计数器，自己的栈。 线程之间同步基于内存。 同一进程的线程会相互影响 虚拟地址操作系统采用虚拟地址的方法，给予程序虚拟地址，由mmu翻译成物理地址，使得每个程序都认为自己独占了内存。好处： 抽象化，便于管理，分配，调度，便于利用碎片 扩大地址空间 便于共享 可以保护内存空间，难以访问到其他进程的内存坏处： 增加了开销，如翻译地址，额外的数据结构，磁盘io 可能浪费内存 缺页中断在malloc和mmap调用时候，只构建了虚拟地址，没有分配物理内存，当访问到的时候引起缺页异常，保护现场，分析原因，调用对应的处理函数，恢复。 系统锁 mutex互斥锁 读写都锁，统一时刻只能有一个访问 rwlock读写锁 写锁，可以有很多读，但写的时候不能读 spin自旋锁 同一时刻只有一个访问，但不会睡眠，而是自旋，一直保持活跃 RCU锁 写时候拷贝，对副本进行修改，在没有操作临界区时候去回调。 可重入锁 同一线程可以再次锁，不会死锁 乐观锁 认为拿数据的时候别人不会修改，读取的时候不会上锁。 在提交更新的时候使用版本号或者CAS算法来确定 CAS：当期望与实际符合的时候，才会更新替换，否则不会 悲观锁 在每次读取或修改都会上锁 不正确的代码容易导致死锁 进程状态创建-就绪-执行-等待-终止 死锁 互斥：资源只能被一个进程使用 请求与保持：在请求资源时候，不会放开自己已经持有的资源 不剥夺：不能强行剥夺 循环等待：各个进程循环等待 银行家算法：三个矩阵claimd allocated need，只要剩余不为负数则贷款给过去 几种io缓存IO：先拷贝到page cache，再拷贝到目标空间 效率较慢select poll epoll本质都是同步io，用于io复用select在socket被唤醒之后，进程从阻塞状态被加入工作队列，在工作队列中正运行的时候，会遍历一遍fd set来找到被唤醒的sock，从而处理。select调用后会阻塞，知道fd就绪或者超时，并且通过遍历fd数组找到目标fd。描述符数量一半为1024。 poll使用pollfd指针来实现，返回后采用轮询来返回就绪的fdepoll作用：先调用epoll create，然后用epoll ctl加入需要处理的sock，最后用epoll wait等待。在创建对象时候，会创建一个epollfd，用ctl来处理。当中断执行的时候，会加入到epollfd里面的readylist中。 epoll存在LT模式和ET模式，LT：应用程序不立即处理，ET则是立即处理。 BIO 同步阻塞 读取写入必须阻塞再一个线程里面完成，过程阻塞 NIO 同步非阻塞 不阻塞，而是反复查询 AIO 异步io 读取写入异步，内核读取了则发送信号 下一个排列算法基本原则：把右边的稍微大一点的元素挪到前面来，并且使它不会到过于前面的位置。从右向左，找到第一个ai小于ai+1的i，我们可以得知从i+1到末尾是完全降序的。再从右往左找到第一个大于ai的j。交换ai与aj，这时候ai+1到n是完全降序，因此然后将ai+1到末尾变成reverse，使其变成升序，也就是后半字典序最小，即为下一个排列。 丑数二分如何找到比x小的，可以被abc整除的数的个数：使用集合，x/a+x/b+x/c-x/lcm(ab)-x/lcm(ac)-x/lac(bc)+x/lcm(abc)即可。根据此原则，可以二分答案，找到模糊的界。再根据该数，求出精确的边界。由n-min(n%a,n%b,n%c)可以得到。 为什么要等2MSL的时间，time_await状态才会结束 为了可靠地终止TCP连接。最后一次ACK可能会传输失败，因此需要等待。 TCP分节可能会因为路由器异常而迷路，此时可能会有迟来的TCP分节到达，需要在到达的时候保证不返回，及时丢弃。 如何处理time_await过多的状态MSL时间常用是30s，1min和2min。因此对于高并发短连接业务来说，会消耗大量端口，而且2MSL时间相对于业务逻辑过长。因此需要处理。在系统设置中开启重用和快速回收。 如何查看进程ps指令，或者进proc查pid，netstat显示网络链接 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E6%9D%82%E4%B9%B1%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"Raft项目总结","text":"raft作为相当有效的分布式算法的一个实现，较paxos更容易理解，也更加简便。本文将阐述raft相关的知识点，从而对raft算法有更深刻的理解。 前置知识： go 选主策略raft与paxos算法类似，都需要通过选主来保证一致性。但较paxos选主而言很明显，raft简化了选主过程。 计时器与状态改变在raft中，每个节点都需要维护一个计时器。当计时器到时间后，便需要改变自身状态，开始一轮选举。状态有Follower，Candidate，Leader三种，所有节点最初默认为Follower。在计时结束后，进入选举，成为Candidate。若收到大多数票，选举成功，则成为Follower。若选举被中断，比如收到了任期更高的节点发来的信息，则转换为Follower。 对于计时器而言，每次重置都会增加一个随机延迟，这是为了减少选举中的冲突，如同一时期许多节点都开始选举。这样的办法提高了选举安全性的保证，即同一时间只会选出一个Leader。 投票投票是原论文中相当详细的一部分，论文中列出的表很好地诠释了投票的进行过程，并且详细介绍了参数，这里给出一个投票RPC结构体的实现。 123456789101112type RequestVoteArgs struct { Term int CandidateID int LastLogIndex int LastLogTerm int}type RequestVoteReply struct { Term int VoteGranted bool} 与论文中保持一致，在征求投票参数中，Term表示自己的任期，ID用于标识自己，LastLogIndex与LastLogTerm涉及到后续的日志复制，是用来在任期相同时候来标识哪个结点更新的，从而更好选出Leader。返回值中，Term用于Candidate更新自己任期，如遇到任期更高的可以直接变成Follower，VoteGranted则用于表示是否投票。 进入选举之后，首先增加自己的Term，然后进行征求投票，向其他节点发送RPC请求，得到响应并且处理。任期是得到投票的关键。只有在当前节点与节点网络中过半节点一样新，才会被选举为Leader。这为后续的日志一致性提供了保证。 获得半数以上票则当选，非常自然而然地保证了选举Leader的唯一性。当无法获得半数以上投票时候，要么在接受其他节点信息的时候转变身份，要么计时器到期，进入新的选举。 心跳机制心跳机制是用于维护Leader地位的机制。当一个节点转变为Leader之后，会定期向其他节点发送空请求，使得其他节点能及时重置自己的计时器，避免进入选举状态。心跳机制也可以用于恢复之前失去连接的节点。如果心跳能够接通，则可以将之前的节点转换状态为Follower。 对于选举，更多的细节可以参考原论文。此处只是给出基本原理。 日志复制作为分布式系统，日志的一致性是必须要保证的一点。Raft实现日志复制的方法也不难理解。 日志表示 下面是单个日志的具体项的Go实现。实际存储使用切片即可。 1234type Log struct { Command interface{} Term int} 可以看出，日志不光包含朴素的指令信息，还包含日期信息，这是raft系统最主要的辨别日志的方法。当一个日志的任期与日志所在的位置（即Index索引）完全相同时候，才能认为是相同的。这也是用于主从日志保证一致性的策略。 日志一致性上面描述的日志的表示，这里我们将描述如何应用日志特性。 首先，日志只能从Leader接收，并且只能由Leader发向Follower。我们将日志区分为两种状态：未提交的，与已经 提交的。我们要确认的一致性，便是每个节点的committed的日志的一致性。 首先要确认的是，一条日志，只有存在于节点网络的过半节点中才会被提交，这意味着由网络隔离所导致的孤立节点网络中的日志可能会被多个机存储，但只要机器数量少于一半，则绝不会被提交。其次，就像之前所说，当Candidate与过半节点一样新的时候才会保证被选为Leader，这意味着Leader总是拥有最新最全的日志。由于消息传递的单向性，只能由Leader向Follower，因此Follower所能提交的日志总是Leader日志的一部分，这也保证了一致性。 在Leader内部会维护一个matchIndex与nextIndex，前者表示节点已经与本机匹配了的日志，后者表示下一个将要传递给该机器的日志索引。在选出新Leader时候，前者会被初始化为0,后者被初始化为本机日志长度减1。在本地日志与Leader发过来的日志对不上时候（这里的对不上，就是任期号与位置对不上），Leader便会改变该机器的nextIndex值，使其减少，直至对的上为止。当日志对上之后，Leader可以采用批量传递的方法，一次传递多个log，来提高效率，并且覆盖该节点的日志。传递日志数量取决与nextIndex的维护方式。每当日志复制完成，都会更新两个列表的值。最后，根据matchIndex值，可以得到一个已经确认复制完成的的列表。就我个人而言，我选择了根据该列表中位数的方法来确认该提交的日志。 同样，本文只是粗略概括，详细的一致性证明可以参考原论文的描述。 日志压缩日志无法无限地增长，因而我们需要压缩技术。在raft中，我们使用快照的方法来进行压缩。 快照技术快照技术理解并不困难，本质上便是合并已经提交的日志，对状态机进行合并，仅仅保留日志内最后一个任期与最后一个索引。 在实现上来说，通常每个服务器都是独立地建立快照，而不是由Leader统一创建。后者的开销与io效率更为低下。Leader偶尔也需要向落后的Follower发送快照来保证一致性，虽然开销看似很大，但在实际使用过程中，Follower的正常工作保持更新，会很少需要这些开销，因此这种开销是可接受的。 总结raft作为面向理解的算法，解决了paxos晦涩难懂的缺点，理解上并不困难，在实际工程运用中也相当实用。我自己亲手实现了个raft，由于一些代码规范的原因没有过多展示，但确实感觉对于分布式的理解更为增进了一步。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/raft%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"title":"编译原理做题版","text":"本文主要为编译原理的题目做法解答，基于mooc题目。人人都是做题家！ 编译原理做题版第二章 文法与语言写出语言文法对应的所有句子的集合，也就是文法所能推导出来的所有句子的集合。写出即可。 构造语法树根为产生式左部，下面从左到右组合成为产生式右部，构建即可。 如何生成目标串产生式推导，使用=&gt;连接即可。 二义性对于同一句子，是否存在两棵不同的语法树，可判断二义性。 给出语言的上下文无关文法上下文无关文法： 左侧必须为非终结符 且满足1型文法|β|&gt;=|α|无特定技巧，注意递归思想，注意数据范围，使用独特方法规范数据范围即可。 给出语言的三型文法三型文法： 右侧为左线性或者右线性，即只能aA与a，或只能Aa与a。也无特定技巧，注意三型文法规范。 第三章 词法分析画DFADFA状态是确定的，每一个输入对应确定的下一个状态，没有ε边。注意该点。进行绘画即可。 构造DFA首先需要NFA，这时候需要观察题干，得到NFA的所有字母，所有状态，转换关系，开始状态，结束状态。 然后将转换关系，绘制成NFA表格。 得到NFA表格后，扩充状态，如x状态在输入1后能进入x或y状态，则将xy状态加入表格，继续执行该过程，直至结束。 得到该表格后，将终止结点与非终止结点分为两个集合，在根据输入的不同，继续划分集合，直到无法再分。得到最简DFA。 画出图，即可。 写正规式注意星号，或号用法。 第四章 自顶向下语法分析first集求法first集合含义便是该非终结符所能产生的第一个字符，按照此规则去找。A-&gt;a则只有a，A-&gt;Ba则观察B是否成产生ε，如果能则将First(B)与a加入集合，不能则只加入First(B)，没有a。多个非终结符推出ε则以此类推。注意，epsilon本身也可以进入first集合。 follow集求法follow集合意义是该非终结符后面所有能接的第一个字符。那么观察产生式右边。比如A，如果只有S-&gt;Aa则follow只有a，如果只有S-&gt;A并且最后到了结束则加入#，如果S-&gt;AB，则将first(B)放入follow(A)，如果B能推出ε或者A为右部，则将follow(S)放入follow(A)。 select集合构建select集合是针对产生式的，注意。S-&gt;AB如果产生式右部不是空串，则为first(S)，AB可以推出空串，则first(S)∪follow(S)-ε LL(1)文法判断对于相同左部的产生式而言，产生式的select集合不相交。 预测分析表纵轴为产生式左部，横轴为输入符号，中间为对应产生式。 消除左递归对于A-&gt;Aα|β而言，为直接左递归，可以改写为A-&gt;βA’ A’-&gt;αA’的等价形式。存在间接左递归，可以先带入化成直接左递归后处理。 提取左公因子对于A-&gt;aB1|aB2|……|aBn|y 可以提取左公因子后，得到A-&gt;aB|y B-&gt;B1|B2|……|Bn 注意，消除左递归并且提取左公因子后不一定为LL(1)文法。 第五章 自底向上语法分析firstvt求法注意区别于first集合，firstvt求法：T-&gt;a…则加入a，T-&gt;R…则加入firstvt(R),T-&gt;Ra…则加入firstvt(R)与a。如此递归。 lastvt求法与firstvt类似，T-&gt;…a则加入a，T-&gt;…R则加入lastvt(R)，T-&gt;…aR则加入a和lastvt(R)，如此递归。 算符优先级判断对于ab而言，a=b。对于aAb而言，a=b，a小于firstvt(A)，lastvt(A)大于b，如此扫描。对于画表而言，横纵都是终结符，大小比较注意横纵关系。没有冲突则为算符优先级文法。 短语，句柄，素短语，最左素短语短语：子树的叶子从左到右句柄：最左的只有两层的子树的叶子从左到右素短语：至少包含一个非终结符的，与其他素短语不相交的短语最左素短语：语法树内最左的一个。 分析过程画表，观察栈顶和输入字符，比较关系，当遇到大于号和小于号配对时候则规约，不然移进。 第六章 LR分析法FSM构建首先增加拓广文法：增加个开头。将点放在拓广文法右部开头，如果是非终结符，则在方框内增加该非终结符的产生式，并将点放在右部开头。将点后续相同符号的，引出一条线指向新方框，方框内移动点到该符号后面，并和上面处理点后非终结符一样。迭代此过程，直到所有状态结束。 分析表构建注意ACTION表和GOTO表，如果点后为终结符则action(k,a) = Sj，k为当前表的标号，a为该中介符号j为后续表的标号。如果点后为非终结符A，则goto(k,A) = j如果项目为规约项目，则对于任何终结符a,Action(k,a)=rj，rj为目标产生式。注意这个a是任意a。如果结束了，则放入acc其他为error 分析表使用如果右边为si，则单纯地改变状态。如果右边为ri，则先将栈内符号可规约的符号弹出，状态置为剩余的栈顶部符号所存在的状态，根据此状态和规约出来的非终结符进行跳转。如此循环，直到结束。 LR(0)判断点后为终结符，则为移进项目。点后为非终结符，则为待约项目。点后为结束，则为规约项目。移进，规约同时存在会冲突。规约，规约存在也会冲突。 SLR(1)判断对于移进项目的非终结符b，规约项目的不同产生式左部B，C，如果b和Follow(B) Follow(C) 互不相交，则为SLR(1)文法，判断时候根据输入字符在这三者哪个里面决定移进还是规约。 第七章 语法制导的翻译标出属性值根据语义，带入语法树即可。 翻译成三地址码TAC三地址码 OP A1 A2 A3 类似汇编 注意操作变量个数 第八章 代码优化分基本块程序的第一个语句；goto的目标语句；跟在条件转移语句后面的语句 按照此切分 流图有向边：能到达则画有向边 根据go 语句执行顺序来确定 找循环D(N) 必经结点集合，指从开始到这个点，绕不开的结点的集合 当存在a-&gt;b的边，而且a的必经结点有b，则为回边回边a-&gt;b 循环入口为a 出口为b 先放入入口 再放入出口，直到栈顶的前驱都是a为止，找到循环（类似BFS） DAG优化将所有右边的，意义相同的变量放在DAG一个结点中，以操作符的方法增加边或结点，构造DAG，然后根据图，重新命名变量，重新构造式子，最后根据需要引用什么来赋值 第九章 目标代码生成根据TAC序列生成目标代码先翻译代码，然后尽量使用寄存器。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%81%9A%E9%A2%98%E7%89%88/"},{"title":"JS学习笔记","text":"本文主要为JS的学习笔记，基于MDN的文档，尤其是A_re-introduction_to_JavaScript。 JS学习笔记基础类型JS包含以下类型： Number String Boolean Symbol（ES2015新增） Object Function Array Date RegExp null undefined 数字 在JavaScript中，除了BigInt，不存在整数类型，都是IEEE754的double类型，都是浮点数。 存在NaN Not a Number，也存在Infinity和-Infinity两个特殊值，可以用isFinite来判断。 字符串 都是UTF-16的编码单元的序列，每一个编码单元由16位二进制数来表示，由一个或两个编码单元来表示一个字符。 可以用.length属性（而不是方法）来获取长度。 其他类型 null表示空值，undefined表示未定义未从初始化的值，未初始化的变量就是undefined类型。 JS存在布尔类型，false 0 空字符串“” NaN null undefined都会被转换为false。可以用Boolean显示转换，或在if中隐式转换。 变量存在三种声明变量方法，let const var。 let 声明块级作用域的本地变量，可选地初始化值。 const 声明不可修改的常量，在定义域内可见。 var 使用var在声明的整个函数都是可见的，没有块作用域的限制。 运算符使用==运算符能够自动类型转换，如果不需要则使用===运算符。类似的还有!=和!==运算符。 控制结构if else，while do-while和c语言类似。 for循环可以和c语言类似，但也存在不同的两种循环：for-of和for-in循环。 1234for (let value of array){ //do sth with the value //用于数组值} 12345for (let property in object){ //do sth with the object property //用于遍历对象 //遍历数组会遍历数组所有可枚举属性，如method和name，不要遍历数组} switch可以基于数字或者字符串，记得break。 对象可以简单理解未“名称-值”对，类似字典。在js中，除了核心类型，core object，一切都是对象。名称部分是字符串，值可以是一切数据类型。 创建空对象方法，其中更推荐第二种，因为JSON格式： 12var obj = new Object();var obj = {}; 创建对象实例如下： 123456789var obj = { name: \"carrot\", _for: \"MAX\", details:{ color:\"orange\", size:12 } } 访问方法支持如下： 12obj.details.colorobj[\"details\"][\"size\"] 第二种方法有点在于可以被看做字符串，但可能无法在后期被编译器优化。 创建对象可以用函数，如下所示: 12345678910111213function Person(name,age){ this.name = name; this.age = age;}function makePerson(first, last) { return { first: first, last: last };}var you = new Person('you',25) 数组数组是特殊的对象，以数字为类型名，只能用[ ]访问，包含特殊的属性：length，他比最大索引值大1。 创建数组传统方法如下： 123456var a = new Array();a[0] = \"dog\";//或者var a = [\"dog\",\"cat\"];a[100] = \"fox\";a.length；//101 注意第二种，length的值，他比最大索引值大1。访问不存在的数组索引，会得到undefined。 除了传统for，for-of，还可以用forEach方法.如下所示： | 参数 | 描述 | | :———————————– | :———————————————————– | | function(currentValue, index, arr) | 必需。 数组中每个元素需要调用的函数。currentValue必需。当前元素index可选。当前元素的索引值。arr可选。当前元素所属的数组对象。 | | thisValue | 可选。传递给函数的值一般用 “this” 值。 如果这个参数为空， “undefined” 会传递给 “this” 值 | 调用如下： 12345678var arr = [1, 2, 3, 4, 5];arr.forEach(function (item) { if (item === 3) { return; } console.log(item);}); 增加元素用.push。还有些其他方法，查表就行。 函数没有返回值的函数会返回undefined，调用函数没有提供足够参数会被undefined替代，传入过多参数会被忽略。 函数访问了函数体内为arguments的内部对象，包含所有参数。如下实现avg的方法： 123456789function avg(){ var sum = 0; for (var i = 0, j = arguments.length;i&lt;j;i++){ sum+= arguments[i]; } return sum/ arguments.length;}console.log(avg(1,2,3,4,5,6));//3.5 可以使用剩余参数操作符，来实现上述功能： 123456789101112function avg(...args){ var sum = 0; for (var value of args){ sum += value; } return sum/ arguments.length;}console.log(avg(1,2,3,4,5,6));avg.apply(null, [2, 3, 4, 5]);//使用apply来将数组传为参数列表,第一个参数为被当作this看待的对象。numbers = [2,3,4,5]avg(...numbers)//展开语法 js也可以创建匿名函数。也可以给函数命名来递归调用。 注意this指针的问题，this的上下文可变， 如果在一个对象上使用点或者方括号来访问属性或方法，这个对象就成了 this 。 举例如下： 1234567891011121314151617function makePerson(first, last) { return { first: first, last: last, fullName: function() { return this.first + ' ' + this.last; }, fullNameReversed: function() { return this.last + ', ' + this.first; } }}s = makePerson(\"Simon\", \"Willison\");s.fullName(); // \"Simon Willison\"s.fullNameReversed(); // Willison, Simonvar fullName = s.fullName;fullName(); // undefined undefined .prototype是可以被所有实例共享的对象，当访问某个实例没有定义的属性时候，会检查.prototype里面是否存在。使用如下： 12345678910function Person(first, last) { this.first = first; this.last = last;}Person.prototype.fullName = function() { return this.first + ' ' + this.last;}Person.prototype.fullNameReversed = function() { return this.last + ', ' + this.first;} 对于new，可以有下面的类似实现，注意apply： 1234567function trivialNew(constructor, ...args) { var o = {}; // 创建一个对象 constructor.apply(o, args); return o;}var bill = trivialNew(Person, \"William\", \"Orange\");var bill = new Person(\"William\", \"Orange\"); call函数可以用来设置this，用例如下： 12345678function lastNameCaps() { return this.last.toUpperCase();}var s = new Person(\"Simon\", \"Willison\");lastNameCaps.call(s);// 和以下方式等价s.lastNameCaps = lastNameCaps;s.lastNameCaps(); 内部函数函数内部可以定义函数，，而且可以访问父作用域的变量。如下所示： 123456789function parentFunc() { var a = 1; function nestedFunc() { var b = 4; // parentFunc 无法访问 b return a + b; } return nestedFunc(); // 5} 这种方法可以减少全局变量，避免污染命名空间。 闭包闭包样例如下： 123456789function makeAdder(a) { return function(b) { return a + b; }}var add5 = makeAdder(5);var add20 = makeAdder(20);add5(6); // 5+6=11add20(7); // 20+7=27 当调用makeAdder时创建了作用域对象，带有属性a，然后makeAdder创建一个函数并返回。闭包就是函数与其被创建时候带有的作用域对象的组合。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"React学习笔记","text":"本文主要为react的学习笔记，基于react文档。 React学习笔记JSX简介基本用法：使用{}，在大括号中放入任何有效的JavaScript表达式。 12const name = 'a';const element = &lt;h1&gt;Hello {name}&lt;/h1&gt;; 或者诸如2+2，user.firstName，formatName(user)等表达方法。 JSX本身也是表达式，转为普通的JS函数调用，取值后得到JS对象。可以在if，for中使用JSX，当参数传入，以及返回JSX。 123456function getGreeting(user){ if(user){ return &lt;h1&gt;Hello,{formatName(user)}&lt;/h1&gt;; } return &lt;h1&gt;Hello Stranger&lt;/h1&gt;;} 和html类似，可以使用属性或者在属性值用大括号插入js表达式（注意，不要引号，引号和大括号只有一个）。 1const elem = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt; JSX可以防范XSS注入，会进行转义，所以不用担心。 12const title = response.potentiallyMaliciousInput;const elem = &lt;h1&gt;{title}&lt;/h1&gt;; 在使用中，Babel会将JSX转译为React.createElement()函数调用，转化为基本的React元素。 元素渲染元素是构成React应用的最小砖块，描述了屏幕上看到的内容。开销不大。 将React元素渲染倒根DOM节点，只需要一起传入ReactDOM.render()中： 12const elem = &lt;h1&gt;hello world&lt;/h1&gt;;ReactDOM.render(element,document.getElementById('root')); React元素为不可变对象，更新UI的唯一的方式是创建全新的元素，并且传入ReactDOM.render()： 12345678910function tick(){ const elem = ( &lt;div&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;h2&gt;It is {new Date().toLocaleTimeString()}&lt;/h2&gt; &lt;/div&gt; ); ReactDom.render(elem,document.getElemById('root'));}setInterval(tick, 1000); 但在实践中，只调用以此ReactDOM.render()，注意这点。 ReactDOM会将元素以及子元素与之前的状态进行比较，只进行最小的更新。 组件与Props可以用JS函数或者ES6的类来定义组件，接收props（属性），返回React元素。如下两种方法是等效的： 123456789function Welcome(props){ return &lt;h1&gt;hello {props.name}&lt;/h1&gt;;}class Welcome extends React.Compoent { render(){ return &lt;h1&gt;hello {this.props.name}&lt;/h1&gt;; }} 在使用中，组件可以是react元素： 1const elem = &lt;Welcome name='2'/&gt; 当React元素为用户子当以自建时候，JSX所接收的属性以及子组件会转化为单个对象props传递给组件。 组件名字必须大写字母开头，小写字母被认为是原生DOM标签。 props是只读的，这意味着不改变入参，有着纯函数性质。 State与生命周期state与props类似，但state是私有的，并且完全受控于当前组件。 class组件应当始终使用props参数调用父类的构造函数。在构造函数中，state被赋初值。，使用setState进行更改。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Clock extends React.Component{ //构造函数 初始化 constructor(props){ super(props); this.state = { date: new Date(), }; } //更新函数 tick(){ this.setState({date: new Date()}); } //生命周期方法，在渲染到DOM中后运行 componentDidMount(){ this.timerID = setInterval( ()=&gt;this.tick(),1000 ); } //清除计时器 componentWillUnmount(){ clearInterval(this.timerID); } render(){ return ( &lt;div&gt; &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt; &lt;/div&gt; ); }}function App() { return ( &lt;div&gt; &lt;Clock/&gt; &lt;Clock/&gt; &lt;Clock/&gt; &lt;/div&gt; );}ReactDOM.render( &lt;App /&gt;, document.getElementById('root')); 当&lt;Clock/&gt;被传给ReactDOM后，会调用构造函数，初始化state，之后调用render方法，渲染输出，然后调用ComponentDidMount()方法向浏览器请求设置计时器，每秒调用tick()方法，tick()使用setState()更新，React便会更新DOM。组件被移除后，调用componentWillUnmount()方法卸除计时器。 不要直接修改state，这样不会重新渲染组件。只能在构造函数赋值。 state和props可能异步更新，可以用在setState()中传函数解决，如下所示： 1234// Correctthis.setState((state, props) =&gt; ({ counter: state.counter + props.increment})); state的更新可能被合并。 state可以作为props向下传递。 事件处理事件采用小驼峰方法命名，使用JSX的时候传入函数。必须显式采用preventDefault来阻止默认行为。如下所示： 123456789101112function ActionLink() { function handleClick(e) { e.preventDefault(); console.log('The link was clicked.'); } return ( &lt;a href=\"#\" onClick={handleClick}&gt; Click me &lt;/a&gt; );} e是一个合成事件。 在初始化时候应当绑定this，作为js特性，避免锅。 条件渲染使用if-else或逻辑运算符来控制渲染。 12345678910111213141516render() { const isLoggedIn = this.state.isLoggedIn; let button; if (isLoggedIn) { button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;; } else { button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;; } return ( &lt;div&gt; &lt;Greeting isLoggedIn={isLoggedIn} /&gt; {button} &lt;/div&gt; ); } 如果不想渲染，可以直接返回null。 1234function WarningBanner(props) { if (!props.warn) { return null; } 注意，生命周期方法还是会调用。 列表和key使用map()方法将数组映射成&lt;li&gt;&lt;/li&gt;，记得在映射的时候指定key值，用于辨析元素是否改变，添加，删除。 123456const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li key={number.toString()}&gt; {number} &lt;/li&gt;); key应当独一无二，用于标识。不建议用索引来当key值，但这是默认做法。 key在兄弟结点中必须唯一，但全局不一定唯一。 表单可以用onChange传入函数来控制组件维护的state document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"迁移博客的碎碎念","text":"本文主要是一些把博客迁移到hexo过程中发生的各种技术问题。 前言由于之前的博客太丑了，阅读体验极差，响应式布局像个傻逼一样（电脑横屏的文章布局和手机一样，字贼大，将浏览器窗口侧边收紧后阅读体验反而变好），我决定迁移博客。 迁移准备博客全部在github上，所以只要找到一个博客系统，能够兼容之前的markdown就行了。如果没有兼容，至少改动不需要太多。由于在github page上，那么存在以下几个备选方案： Hugo:拿GO写的静态站点生成器 Hexo:基于Node.js的博客框架 jekyll:基于ruby的静态博客网站生成器 以上就是几个备选方案，或许存在我不知道的备选方案（比如自己写？），所以我没有考虑。 Why hexo？ 没什么原因，因为hugo没听说过，jekyll忘了怎么拼写（虽然之前用的就是jekyll，但我还是懒得部署本地ruby环境）。 选择完hexo之后，就可以看看博客主题，毕竟我不会前端，还是拿别人写好的比较好。 Hexo官网主题提供了许多可供选择的主题，可以直接点进仓库看，可以自己部署，但我更喜欢直接fork别人仓库后改文章代码，网页配置之类的东西，毕竟简单（懒）。 我用的是icarus，仓库地址在这里，注意这个地址是site分支，也就是实际网站源码的分支。下载完源码之后记得git切分支。 环境准备Node.js和Hexo的安装就不多说了，官网很详细。同时在clone完上面仓库，切换到site分支后，进到对应文件夹，执行以下命令安装依赖。 1npm install 他会根据package.json文件去安装依赖。虽然有些依赖可能已经过时，但能用就行。这个过程可能很长，记得换源。（我自己都没换） 安装完成后，执行以下命令启动服务器： 1hexo server 也可以简写为hexo s，这时候访问localhost:4000就应该可以访问到页面了。 小插曲安装完hexo后，电脑的ms-setting没有了。这个的直接后果是个性化，显示设置这些右键的设置选项打不开，会报错说找不到。电脑的开始界面点不开，搜索界面搜索到的软件全部打不开，但是桌面都很正常，应用软件也都打得开。 最初我怀疑是path被搞丢了的问题，但是其实不是，但还是记录以下，这里是path搞丢了的解决方案： Win+R进入到运行，输入regedit，进入到注册表编辑器 进入到HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Session Manager\\Environment，找到path，复制。 右键点击我的电脑，属性，高级系统设置，环境变量，去里面找到path，进行比对。不同就恢复以下。 这可能是一个path丢失的解决方案，但并没有解决我的问题。于是随便搜了一下。我执行了以下步骤，但具体哪一个步骤真正解决了问题，我也不知道： Win+X，可以用管理员模式点开powershell，这个应该不依赖ms-setting。 执行sfc /scannow，扫描并修复损坏或丢失系统文件。 执行shutdown -r重启。 虽然最后解决了问题，但再次说一下，我也不知道以上哪个步骤真正解决了问题，仅供参考。 部署和配置回到主题，完成运行之后，我们需要更改配置，来供自己使用。更改配置在_config.yml里面，具体选项有着具体的文档解释，反正可以运行看效果，所以可以随便试试。本博客采用的主题除了这一个yaml文件外，还有=_config.post.tml和_config.icarus.yml文件，这些主要看文档怎么写和自己多试试。 插曲2在本地运行调试之后，我发现个严重的问题，本地访问需要20s。这个问题挺好排查的，因为本地不可能这么慢。点开F12看调试框，可以看到有个叫fontawsome的css文件需要联网获得，并且failed。这样就存在了访问慢的问题。 解决方法是在配置文件中改CDN，具体参考yaml文档的解释。 部署在yaml中设置type: git，repo: 远程git仓库，branch: 分支就行，记得设置到master分支才有效。 由于我们安装了别人的依赖，所以不需要再安装deploy。在设置完成后，执行以下： 1hexo deploy 等待即可。不出以外的话应该会成功。出意外的话github会给你发邮件。 配置这里简单介绍一些配置。 toc可以开启目录。需要提前配置。 categories设置分类。tags设置文章tag。 mathjax我自己的使用方法是在文章前面head里面加cdn来设置的。也有模板提供的解决方法，具体查模板文档就行。 题外话 algoliaalgolia是个前端搜索插件，好用是好用，但部署过程有些复杂，导致我收了不知道多少个github邮件说失败。这里简单介绍一下。 实际解决方案： 先说实际解决方案——用别人的api key。自己申请的key由于硬编码到——config.yml中，因此会被爬虫爬到（三分钟就被警告了），并且会被发邮件警告。所以用别人的key是最好的。 就我自己的话，是用的别人的api key，抄的别人的github action来用的，好处是省心，坏处是有些缺德。 理论解决方案： 首先注册algolia账号。它的官网访问速度很迷，所以慢慢等。注册之后需要填公司，瞎填就行。 新建一个index，自己命名一下，然后在左边找到api key栏目，新建一个带各种权限的api key。 在yaml中设置各种选项，如下： 123456algolia: applicationID: 'your applicationID' apiKey: 'your apiKey' adminApiKey: 'your adminApiKey' indexName: 'your indexName' chunkSize: 5000 这里api key就是刚才申请的，其他的照抄即可。 除此之外，还要设置环境变量，如下所示： 1export HEXO_ALGOLIA_INDEXING_KEY=apiKey 不是很懂它的两次apiKey，由于我们硬编码到yaml中了，所以必定会被爬虫爬到。所以还是用别人的。 在完成环境变量后，安装hexo-algolia插件，如下： 1npm install hexo-algolia --save 然后运行即可。 注意：我没试过理论方法，毕竟被github发了一万个邮件，所以不保证正确性。觉得懒的可以直接抄github action就行。 总结和其他整个过程花了我两天还是一天，总之比预想要快，因为blog的一些标签都是兼容的，这就很好办，没有过多的迁移成本。 但也存在一些问题，比如我之前的blog的格式就存在很多问题，显示上不好看，但无伤大雅。一些硬编码的链接也出现了问题，比如目录错误之类的，有时间慢慢解决吧。（也就是不解决了） 同时还有个不知道是bug还是feature的东西，在渲染markdown table的时候渲染失败，两个减号会被渲染成unicode 2013字符。暂时解决方法是通过typora的开发者界面复制html代码，然后在raw标签中直接粘贴进去。虽然不优雅，但可行。 换了博客主题写作心情也会变好。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"title":"Gaman游戏评测系列#0：目录与杂谈","text":"我决定开始写游戏评测，分享一些我自己的游戏理念 。 没人看也写。 杂谈写游戏评测的想法主要起源于内心的愧疚感。当我耗费时间去玩游戏，但得到的却只有即时的愉悦感，但耗费了更多的时间。我认为认真做过的事就需要认真对待，认真花费时间玩过的游戏，就需要认真地剖析一番，留下点什么东西，于是诞生了写游戏评测的想法。 我自己玩过的游戏，不能算多，但也不能算少，自我初中开始接触单机游戏开始，也算是玩了八年游戏。而且自初中时候我就开始长期关注互联网游戏媒体，了解了不少游戏知识，曾经一度想做游戏但被游戏业界的待遇劝退了。对于“评测”而言，我认为相当一部分的价值取决于作者自身的经历，作者自身对行业，对产品的理解有多少。不去调查便没有发言权，没有真正体会过就不能给出评价，因此我自己写评测的游戏，都是我自己本人玩过几十小时以上的。“几十小时”在我看来，虽然不能让你磨练游戏的技术，但至少对游戏的系统，机制有了一个彻底的了解，对于游戏的剧情而言也至少通关了一次，了解了来龙去脉。这些东西在我看来，了解了这些，就足以能够算“了解”了一款游戏，至少对于游戏能给出一个全面的判断。 “评测”除去真正地想了解一款产品之外，还是寻求肯定，寻找共同感的好去处，这些也是一些评测有着传播效应，流行起来的原因。就我自己而言，我自己写评测不能说完全独立，不被他人的观点所影响，但我会结合第一手体验。好玩有好玩的道理，坏有坏的道理，这些会在理念部分详细阐述。 系列标题Gaman来自古英语的game，取这个名字纯属一时兴起，需要一个标志。 游戏除了评测文章外我还会给出一个评分，毕竟打分也是评测的一部分，全是文字的文章不好看。 理念以下是我评测游戏的一些核心理念，这些构成了评测游戏的基本标准。 游戏是给人带来快乐的 这一点是最为核心的，最为重要的一点。游戏最主要的功能便是给人带来快乐，即时性的也好，回味性的也罢，但最主要的目的不能脱离于此。“快乐”是一个相当主观的判断，基于此会引发各种讨论，各有各的价值判断，但对于游戏而言，带来快乐这一基本理念不变。这个理念意味着人们共识的”痛苦“意味着烂游戏，比如游戏经典之作：沙漠巴士，是百分百的烂游戏。无聊的操作在人们的共识中，是一种痛苦。 玩游戏，而不是被游戏玩 这一点是基于上一点衍生出来，对于“快乐”的理解。许多人为了游戏废寝忘食，定闹钟准时参加活动，或许他们能够在这过程中得到快乐，但在我评测的理念中，这一点是很严重的减分项。游戏是给人玩的，这意味着自我的主导权。以“上班”的方式玩游戏，还不如去上个班，至少还能获得拿钱的快乐。不被运营，策划喂屎，拥有对于游戏的主导权，这是我对游戏是否好玩的一个理解。同样，游戏难度的突然陡增，过于困难导致不肝不氪玩不了，这种行为也属于被游戏玩，在我对游戏的理解里面也属于减分项。 宣发无关 宣发是游戏发行的一个环节，而不是游戏自身的一部分。现在的游戏界各种各样的宣发层出不穷，宣发经费足能够给予游戏足够的关注度，因此只要游戏质量不算太差，收益相对而言就会很不错。但我个人评测游戏则会忽略宣发，因为这不是游戏本身的一部分。这意味着游戏与宣发不匹配的时候，我还是会认真研究游戏本身。宣发与游戏自身不配位的现象出现也很多，比如最近最为出名的《赛博朋克2077》。 不同类的游戏不同地看待，同类地游戏比较地看待 不同的游戏侧重点不同，但同类游戏往往存在许多相似之处，因而会相互比较。不同类的游戏会按照类别来看待，比如手机游戏会更加偏重于便携性，能否随时随地地玩。剧情主打的游戏会更加看重剧情，玩法游戏的游戏会更加看重玩法。现在许多的游戏在玩法上颇为类似，因而会更加注重类似玩法的不同点，相互比较，这是评价的核心准则。 评分构成不同的游戏存在不同的部分，但对于茫茫众多的游戏也存在相通的部分，游戏的评分主要由以下几个方面构成。当然，有些游戏比如gal game在玩法上无法过多延展，因而在玩法上不会做评价。因此游戏的评测是基于以下方面的子集构成。 剧情 对于有剧情的游戏而言，游戏的故事性是评判游戏的主要部分之一，但也不是全部，比如《王者荣耀》也有剧情，但没人在乎。剧情的评分主要基于合理性和故事性，合理性意味着剧情不能过于超出常识，不会被喂屎，至少自身是基本合理贯通的。故事性则是对剧情更高层面的追求，比如剧情自身存在的矛盾冲突（文学意义上的），情感描绘，转折，内涵等。剧情平淡的游戏可以接受，但内涵丰富的作品，表现形式合理的作品，一定是优秀的作品。 人物 人物在大体上是依托剧情而存在的，并且由剧情而体现。我一度在思考要不要把人物但列出来，但现在的游戏，或许是快餐化的影响，人物往往被抽象出了剧情。简单来说，存在的不是“人物”，而是“人设”。但是好的人设在营销上依然是讨喜的，有着商业的价值。游戏的人物不像小说一般，现代丰富的多媒体技术给予了游戏人物新的存活方式。比如立绘，比如模型，这些都是人物的一部分。在评价的过程中不能忽视这一部分，因此人物被单独列了出来。 玩法 游戏最为核心的系统与机制，也是构成游戏是否“好玩”的主要因素。虽然大部分游戏机制有着趋同发展的态势，但有趣的机制往往是维持游戏生命的重大因素。无趣的机制，即使出再多的活动，收集要素之类的东西，也不会好玩。对于我而言，剧情优秀的游戏往往品味一次就足够，但“好玩”的游戏则可以一直玩下去。当然，不同的游戏有着不同的特色，在具体评判的时候也会进行权重的比对。 画面 好的画面使得玩游戏称为一种享受，但就我个人而言，糟糕的，过时的画面，只要游戏玩法有趣，仍然可以玩很长时间。只要画面不是过于辣眼睛，我认为都是可以接收的范围。画面在评测中往往属于加分项。 音乐 音乐与画面类似，好的音乐是构成游戏氛围的一部分，比如恐怖游戏中的配乐插入。除去音乐，音效也是游戏的很重要的一部分，这一点体现在比如PT的广播，婴儿哭声等。目前我自己还没有遇到过配乐极其糟心的游戏，因此音乐也是加分项。 体验 体验是个杂项，区别于画面与音乐，体验是除去这些因素之外，游戏本身的体验，比如游戏的优化，各种bug，或者是游戏的流程感受，任务设置，难度梯度，或者是游戏的肝度，氪度，这些属于单独拿出来讲会比较少，但整合起来又有些多的东西，我决定整合到体验之中。糟心的体验，比如恶性bug无法通过剧情，绝对是减分项，而良好的体验往往不能称为加分项。体验算是一个游戏的基本素养，至少，一个游戏不能让你觉得恶心。 目录汇总的目录，便于查找。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Gaman/gaman%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B%E7%B3%BB%E5%88%97-0%EF%BC%9A%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%9D%82%E8%B0%88/"},{"title":"枪炮 病菌与钢铁读书笔记","text":"记录一些枪病钢里面的事与观点。 前言巴布亚新几内亚：澳大利亚北部，印度尼西亚东部，与印尼接壤，曾经是联合国托管地。 观点： 不同民族通过征服，流行病和灭绝种族的大屠杀来形成世界。 理解大屠杀不是为了辩护，而是为了了解因果链，从而打破。 认知测试往往测量文化学习，而不是智力。 对于新几内亚人，长期生活在人口稀少，谋杀，部族战争，智力的优势更有可能遗传下来，反而是欧洲的法制，警察，人口稠密的社会，使得传染病成为了主要死因。 欧美儿童接收大量电视，广播，电影的娱乐，而新几内亚人往往接受积极的活动，例如谈话和游戏。 北欧民族对欧亚大陆文明没有重要的贡献，而是接收欧亚大陆发展的先进东西。 复杂的灌溉系统往往自中央集权之后才到来。 第一部分 从伊甸园到卡哈马卡第一章 走上起跑线观点： 对澳大利亚新几内亚的占林是重要事件，从亚洲大陆到澳大利亚至少要渡过8个海峡，最宽的一个至少50英里宽，隔海无法相望，需要水运工具才能实现。 对澳大利亚移民也意味着人类第一次大规模灭绝大型哺乳动物，在人类到达后全部消失了。 北美也曾经有大型哺乳动物，但现在多数大型哺乳动物也灭绝了。 渡过白令海峡也是重要事件，西伯利亚终日严寒，白令海峡曾经有陆桥，但也需要御寒技术。 巴西佩德罗弗达拉洞穴壁画下面有粗糙石器，类似炉灶里的木炭用碳14测定为35000年前，但可能石器是由悬崖撞击，木炭是由森林火灾。 毛利人祖先到达新西兰之后，花了几百年发现了石材，灭绝了恐鸟，形成了社会。 第二章 历史的自然实验。查塔姆群岛：新西兰以东500英里。 莫里奥里人：原住民。 事件： 1835年，近900毛利人入侵了查塔姆群岛，莫里奥里人准备提议和平共享资源，但毛利人已经全面进攻，将人变成奴隶，杀死并且煮人。 莫里奥里人与世隔绝，狩猎为生，只掌握简单的技术和武器，维持着少的人口数量，彼此和睦相处，放弃战争，甚至阉割男婴减少人口过剩的潜在冲突。 毛利人则是人口稠密的农民族群，从事残酷的战争，有着武器与装备，农业养活了手艺人，首领，士兵，使得制作工具来打仗，艺术创作，农业。他们能组织劳动力建设大型灌溉系统，形成了阶级，阶级内部通婚，划分为部落单位和地区，最后形成原型帝国，常备军事设施。 六种环境可变因素影响了差异：岛屿气候，地址类型，海洋资源，面积，地形的破碎和隔离程度。 岛屿气候：波利尼西亚从热带分布到亚热带，到新西兰的不冷不热。夏威夷群岛有着高山，雨量因地而异，有些地方只能勉强发展农业。 地址类型：环状珊瑚岛，隆起的石灰岩，火山岛，陆地碎块，以及类型的混合。有些岛屿完全没有石头，也没有淡水，但新西兰有着一系列矿物，火山石也可以提供打制石器的原料。较高海拔的火山岛带来了雨水，较低岛屿会因为火山灰而土壤肥沃，火山岛也有所不同。 海洋资源：多数岛屿由浅水和礁石包围，有着鱼和有壳水生动物，但也有岛屿由于岩石多海岸陡峭，海产很少。 面积变化很大，从岛屿到新西兰微型大陆，有的有着陡峭山壁，有的则平缓地形。 隔离程度也有变化，有些岛屿可以定期航行，有些相距甚远。 波利尼西亚能够提供世界人类社会差异性的一个剖面，农业，矿物，能利用的资源是其社会差异性的决定因素之一。 第三章 卡哈马卡的冲突西班牙征服者皮萨罗与印加帝国皇帝阿塔瓦尔帕的冲突。 二者会面之后，修士将圣经递给阿塔瓦尔帕，阿塔瓦尔帕不知道书如何翻开，修士伸手帮忙，阿塔瓦尔帕勃然大怒，不愿意帮忙，向修士打了一拳，翻开后发现无惊异之处，于是把书扔出去，总督发出信号，西班牙部队开始屠杀印第安人。 在西班牙对印加的征服中，枪炮只有次要作用，钢刀，长矛匕首是屠杀的重点。此外还有战马，铁甲锁子甲，钢盔，能够抵御印第安人棍棒的打击。 马匹改变战争源自于公元前四千年在黑海背面的大草原对马的驯化，知道第一次世界大战骑兵的地位才结束。 西班牙人带来的天花杀死了印加皇帝和大多数朝臣，又杀死了印加皇帝的指定继承者，使得需要皇位之争，皮萨罗察觉到了印加帝国的分裂态势，并利用起来。 有免疫力的民族将疾病传染给没有免疫力的民族能够起到决定性的作用。天花的流行在西班牙第一次进攻失败后蹂躏了阿兹特克人。美洲土著人大多死于此原因。英国人移民悉尼后也是如此。疟疾等疾病也阻碍了欧洲人殖民。 皮萨罗的到来依赖航海技术的发展，国家的行政组织能够提供资金，技术，装备。西班牙的文字使得西班牙涌入了新大陆。 阿塔瓦尔帕人由于没有文字，情报只能通过口头得来，观察的情报难以确认。新大陆对于旧大陆的情报难以得知，并且天真地相信交付赎金后就会放掉自己。 文化修养使得西班牙人继承了人类行为和历史的大量知识，阿塔瓦尔帕则没有了解过这些。 第二部分 粮食生产的出现和传播第四章 农民的力量农民能够战胜狩猎部落。狩猎已经逐渐消失了。粮食生产是枪炮，病菌，钢铁发展的先决条件之一。 能够获得更多可消化的卡路里意味着有着更多的人，野生的动植物大多数无法消化，因此发展农业要比狩猎采集，每英亩地能够养活更多的人。 驯化的动物能够提供肉，奶，肥料，拉犁。野生物种越多，可驯化的越多。驯化的动植物变成粮食，从而产生了人口稠密的社会，这意味着技术，文字，阶级以及流行病。病菌也因为从驯化的动物身上的病菌演化而来，流行病便诞生。 粮食生产带来定居，缩短生育间隔，使得人口稠密。定居社会也会诞生贮藏粮食的人材，诞生不生产粮食的人，例如国王，官员，专职军人。 驯化品种也有别的作用，比如纤维能制作衣服，网，绳子，葫芦容器等。 驯化哺乳动物成为了陆路交通的主要运输手段。马，好牛，驯鹿，狗拉雪橇等。 马是战略资源，例如匈奴人的进攻。 人类专化病菌如天花麻疹由动物病菌突变而来，在征服战争中起到了决定性的作用。 第五章 历史上的穷与富粮食可能在有些干旱退化的土地上形成，后来才到肥沃的农田上发展起来。 年代是否校正通常由大小写区分的，BC为校正后，bc为校正前。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/%E6%9E%AA%E7%82%AE-%E7%97%85%E8%8F%8C%E4%B8%8E%E9%92%A2%E9%93%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"C++ Primer学习笔记","text":"本文主要是读C++ Primer，记录一些没关注到的细节，或者没学到的东西。 第一章 开始除了cin cout，还有cerr输出警告和错误信息，clog输出运行时一般性信息。 endl结束当前行，将与设备关联的缓冲区刷到设备中。保证到目前为止所产生的所有输出都写入到输出流中，而不是停留在内存中等待写入流。 拓展：缓冲区又称为缓存，内存空间的一部分。在内存空间中预留了一定的存储空间缓冲输入或输出。CPU可以直接读取内存而不是从磁盘 中读，减少磁盘读写次数，提高运行速度。 全缓冲：标准IO缓存满之后才实际进行IO操作； 行缓冲：遇到换行符才之际IO操作； 不缓冲：如stderr。 可以使用flush endl ends来刷新缓冲区。 第二章 变量与基本类型char是否带符号由编译器决定。其他字符类型可以用扩展字符集，如wchar_t,char16_t,char32_t。其中wchar_t可以确保存放最大扩展字符集的任意一个字符，16和32则为unicode服务。 初始化和赋值是完全不同的操作。初始化是赋予初始值，赋值则是先擦除在用新值替代。 列表初始化：用花括号初始化，如下： 1234int a = 0;int a = {0};int a{0};int a(0); 如果初始值可能丢失信息，则用列表初始化时候编译器会报错。 默认初始化：对于函数体内部的内置类型变量不被初始化，函数外的变量初始化为0。每个类各自决定初始化的方式。 c++支持分离式编译，因此定义和声明需要区别开来。声明使得名字为程序所知道，定义创建与名字关联的实体。 如果想声明而非定义，则用extern并且不显式初始化。变量只能被定义一次，但可以被多次声明。 建议：在第一次使用变量前定义它。这样方便好找。 引用创建了对象的别名，定义时候会和初始值绑定在一起，无法重新绑定到另一个对象。 所有指针都应该初始化，而且应当在定义了对象之后再定义指向它的指针。 void*指针可以存放任意对象的地址，但不能操作。可以进行函数的比较，或者赋值给另一个void*。也可以强转类型后操作。 12int *p1, p2;//只有p1是int*类型 p2是intint *p1, *p2；//正确 默认状态下，const对象只在文件内生效。如果需要共享，则extern const来使用。 无法通过const引用来改变值，但可以通过其他引用改变值。 引用类型必须与所引用对象类型一致，除非是字面值。 const在前，是指向常量的指针。const在后，是常量指针。前者无法通过该指针改变变量值，后者无法改变指针的指向，也就是地址不变。 constexpr常量表达式指可以在编译过程中得到计算结果的表达式。函数体外定义的变量地址不变，能用来初始化constexpr指针。这时候相当于地址不变的常量指针。 可以用typedef和using来声明类型别名。 auto通常会忽略顶层const（通道）保留底层const。需要顶层的话则要显式声明。 引用用auto也需要显式声明。 decltype可以用来推断类型，而不计算值。 123456int *p = 5;int a = 6;decltype(*p) //int&amp;decltype((5))//intdecltype(a)//intdecltype((a))//int&amp; 双层括号里面放变量 只能是引用 decltype在加括号和不加括号时候类型不同。 第三章 字符串 向量和数组每个函数，变量名字都需要独立的using声明。头文件不应该包含using声明，避免冲突。 用等号执行的拷贝初始化，不用等号执行的直接初始化。 触发getline函数的换行符被丢弃掉了，得到的string不含换行符。 在cctype里面有各种处理字符的函数，比如ispunct(c)检测标点符号。 列表初始化只能花括号，不能圆括号。 vector运行时应当能高效快速添加元素，因此设定大小没什么必要。 只能对已经存在的元素执行下标操作。 只需要读的话，可以用cbegin()常量迭代器。 可以用箭头运算符和empty()来检测是否为空。 12(*it).empty();it-&gt;empty(); 对容量的操作会导致迭代器失效。 除了方法，还可以用begin(),end()函数。得到尾后指针（指向并不存在的元素，位于容器尾元素的下一位置），可以以数组为参数。 两个指针相减得到ptrdiff_t类型，和size_t类似，但可能有负数。 第四章 表达式除非比较对象是布尔类型，否则不要用true，false来进行比较。 字面值是右值，算数表达式是右值。 除非必须，否则不要用递增递减运算符的后置版本，由于需要保存原始值，因此产生不必要浪费。 sizeof存在两种形式，求类型的大小和求表达式结果的类型大小。 12sizeof expr;sizeof (type); 对数组求sizeof会得到整个数组所占空间的大小，对string或者vector则只返回固定部分大小。 隐式转换：比int小的整型值提升到较大的整数类型，在条件中非布尔值转换为布尔类型，初始化时候转换成变量类型，右侧运算对象转换成左侧运算对象的类型。算数运算多种类型会转换成同种类型，函数调用会发生类型转换。 命名的强制转换： 123456789int j;void* p;static_cast&lt;double&gt;(j);//有明确定义的类型转换，主要不包含底层const，都能用static_cast。static_cast&lt;double*&gt;(p);const char *pc;char *p = const_cast&lt;char*&gt;(pc);//const_cast只能改变运算对象的底层const，不能改变表达式类型int *ip;reinterpret_cast&lt;char*&gt;(ip);//位模式提供较低层次上的重新解释，依赖于机器dynamic_cast;//将基类指针或者引用安全地转换到派生类 第五章 语句throw表达式：用throw标识遇到了无法处理的问题，raise了异常。 try语句块：用try处理异常，以try开始，一个或多个catch子句结束。抛出的异常会被catch处理。 异常类：用于在throw表达式和catch子句之间传递异常的具体信息。 1234567try{ statements;}catch(runtime_error err){ handle;}catch(exception-declaration){ handle;} 异常类： 12345678910exception;//常见问题runtime_error;//只有运行时才能检测出来的问题range_error;//运行时错误：结果超出了有意义的值域范围overflow_error;//计算上溢出underflow_error;//计算下溢出logic_error;//逻辑错误domain_error;//参数对应结果值不存在invalid_argument;//无效参数length_error;//超出长度out_of_range;//逻辑错误 超出有效范围 异常类型有what()成员函数，返回c风格字符串，提供文本信息。 第六章 函数分离式编译：将.cpp文件编译成.o文件，然后将.o文件链接出可执行文件。如果需要更改，则针对更改了的文件编译一份.o文件再链接即可。 可以用引用作为参数来返回所需要信息。 尽量使用常引用。 不允许拷贝数组，数组作为形参会转换为指针。但可以以数组的形式标识参数。 argc标识数组中字符串的数量，argv表示c风格字符串数组。 如果实参数量位置但是全部实参类型相同，可以使用initializer类型形参，如下所示: 1234567891011void teststring(initializer_list&lt;string&gt; li){ for(const auto &amp;i:li){ cout&lt;&lt;i&lt;&lt;\" \"; } cout&lt;&lt;endl;}int main(){ string s1 = \"az\"; teststring({s1,s1,s1});//注意大括号} 省略符形参以及使用: 123456789101112131415161718#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdarg&gt;using namespace std;void testNum(int count,int beforeNumber,...){ va_list arg; va_start(arg,beforeNumber);//对齐到省略号前的参数 for(int i=0;i&lt;count;i++){ cout&lt;&lt;va_arg(arg,int)&lt;&lt;endl;//参数为va_list，参数类型 } va_end(arg);//释放va_list}int main(){ testNum(5,0,0,2,4,4,5);} 不要返回局部对象的引用或者指针。 返回值为左值的函数： 12345678910char &amp;getString(string&amp; s, int index){ return s[index];}int main(){ string s = \"123456\"; cout&lt;&lt;s&lt;&lt;endl; getString(s,3) = '5'; cout&lt;&lt;s&lt;&lt;endl;} 注意参数不能为常量引用，返回值也不能为常量引用。 return可以为大括号括起来的列表，注意返回值类型要能列表初始化。 main函数也有返回值，在&lt;cstdlib&gt;中有定义了两个变量：EXIT_FAILURE和EXIT_SUCCESS。 声明返回数组指针的函数如下所示： 1int (*func(parameter_list))[array_len]; c11可以使用尾置返回类型，如下所示： 1auto func(int i) -&gt; int(*)[10]; 还可以用decltype来声明返回类型： 123456789int odd[] = {1,3,5,7,9};int even[] = {2,4,6,8,10};decltype(odd) *arrPtr(int i){ return (i%2)?&amp;odd:&amp;even;}int main(){ auto i = arrPtr(3); cout&lt;&lt;i[0][3]&lt;&lt;endl;// 7} 引用和常引用是不同的参数，可以重载函数。 有一些编译器定义的常量字符串可以使用： 12345cout&lt;&lt;__func__&lt;&lt;endl;cout&lt;&lt;__FILE__&lt;&lt;endl;cout&lt;&lt;__LINE__&lt;&lt;endl;cout&lt;&lt;__TIME__&lt;&lt;endl;cout&lt;&lt;__DATE__&lt;&lt;endl; 对于函数指针而言，以下两种等价： 12p = func;p = &amp;func; 返回值可以为函数指针，可以通过using来帮助定义。 第七章 类可以在变量前加mutable，这样即使是const成员函数也能修改它。 返回*this时候如果不返回引用，则会拷贝。 用赋值符号当构造函数的时候，不能赋值给常量和引用。 初始化列表顺序不确定。 c11有委托构造函数，可以用自己的其他构造函数来构造。 可以加explicit来防止隐式转换。explicit只应该出现在声明，出现一次就行。 聚合类：都是public，没有构造函数，没有类内初始值，并且没有virtual函数，可以用花括号初始化。 当类所有数据成员都是字面值，且包含constexpr构造函数，类内初始值没有或者是常量表达式，自带析构函数的可以成为字面值常量类。 第八章 IO库IO库有三种： 123456#include &lt;iostream&gt;//istream wistream读 ostream wostream写 iostream wiostream读写#include &lt;fstream&gt;//文件#include &lt;sstream&gt;//字符串 IO对象没有拷贝和赋值。 io库有条件状态，如崩溃，操作失败，eof等。 程序崩溃则缓冲区不会刷新。 我们可以将一个istream关联到ostream上，如默认cin总关联到cout上。这样cin时候会刷新cout缓冲区。 文件流对象时候允许接收文件名字符串为构造参数，创建ifstream并打开该文件。 如果定义了空文件流对象，可以随后用open关联到文件流。 流存在文件模式，如app每次写之前均定位到文件末尾等。 第九章 顺序容器迭代器范围是左闭合右开。 标准库array具有固定大小。 如果容器是vector或string，则存储空间重新分配后所有迭代器，指针，引用都失效。没重新分配则指向之后的迭代器，指针引用会失效。 deque插入首尾之外的位置都会失效。如果首尾，则只有迭代器会失效。 对于list和forward_list，添加元素都有效。 删除元素后，list和forward_list其他位置迭代器有效,deque则首尾之外全失效，删尾巴会尾后迭代器失效，其他不影响。删除首则都不影响。对于vector或string则之前的有效。 每次插入后重新调用end()来便于不失效。 string有find rfind find_first_of find_last_of find_first_not_of find_last_not_of搜索操作。 stack queue priority_queue属于适配器，可以接收已有的容器类型，也可以更改容器类型。 第十章 泛型算法迭代器使得算法不依赖于容器，但算法依赖于元素类型操作。泛型算法只运行于迭代器之上，不会改变底层容器大小。 算法只读不改变元素，如find,count,accumulate等。 equal接收三个迭代器，第一个序列的头，第一个序列的尾，第二个序列的头（因为元素数量至少要一样多）。 fill可以写入元素 ，但首先要创建元素。 unique返回迭代器，不重复的在前面，重复的在后面。算法不增加删除，因此要在之后erase。 插入迭代器：可以用来插入元素。 流迭代器：绑定子啊输入输出流上，可以遍历关联的IO流。 移动迭代器：不是拷贝而是移动元素。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/c-primer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"图解HTTP读书笔记","text":"本文主要是看图解HTTP书的一些学习笔记。 第一章 Web与网路基础URI：由某个协议方案表示的资源的定位标识符，协议方案即http ftp等。 URL表示资源的地点，URI表示某一互联网资源，URL是URI的子集。 URI格式： http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1 http://为协议方案名，如telnet，user:pass为登录信息，可选项，如用户名密码，www.example.jp为服务器地址，/dir/index.htm为带层次的文件路径，与UNIX文件系统类似，uid=1为查询字符串，ch1为片段表示符，表示已获取的资源中的子资源。 第二章 简单HTTP协议HTTP请求报文第一行：方法 URI 版本号 响应报文第一行：版本号 状态码 原因短语 如200 OK HTTP不保存状态，使用URI定位资源。 GET用于请求访问已经被URI识别的资源。 POST传输实体主体。 PUT传输文件，保存到URI指定的位置，一般网站不适用该方法。 HEAD与GET一样，但不反悔报文主体。 DELETE删除，PUT相反。 OPTION查看支持的方法。 TRACE让Web服务器之前的请求通信环回给客户端。 CONNECT要启用使用隧道实现TCP通信，主要使用SSL和TLS加密后传输。 HTTP1.1由持久连接，只要任意一端没有明确断开，则保持连接。减少重复连接的开销。 管线化：并行发送多个请求，接收多个响应。 HTTP是无状态协议，保存状态可以使用Cookie技术，服务端发送Set-Cookie字段来通知客户端保存Cookie。 第三章 HTTP报文里面的HTTP信息空行CR+LF，用于区分首部和主体。 实体可以经过gzip等编码压缩再传送。 1.1有传输编码的机制，只定义作用于分块传输。 multipart/form-data 在Web表单文件上传时候使用。 multipart/byteranges 状态码206 响应报文包含多个范围的内容的时候使用。 多部分对象集合时候，需要在首部字段加上content-type 获取内容可以只请求一部分。 Accept Accept-Charset等用于协商返回最合适的内容，如英文中文页面。 内容协商有服务器驱动协商（服务器根据发送的信息判定协商），客户端驱动协商（JS自动选择），透明协商（各自进行协商）。 第四章 状态码1XX：信息性状态码，表示正在处理。 2XX：成功状态码，表示正常处理完毕。 3XX：重定向状态码，表示需要进行腹甲草错来完成请求。 4XX：客户端错误状态码，服务器无法处理请求。 5XX：服务器错误状态码，服务器处理请求出错。 只要遵循定定义，自行创建也没有问题。 200 OK，表示正常处理。 204 No Content，表示处理成功，但没有资源可返回。 206 Partial Content，表示对资源某一部分的请求处理成功。 301 Moved Permently，永久重定向，URI已经更新。 302 Found，临时重定向，资源对应的URI将来可能该百年，书签不会变。 303 See Other，明确应当采用GET，301，302禁止将POST变成GET。 304 Not Modified，资源找到，但未找到符合条件的请求。 307 Temporary Redirect，和302相同。 400 Bad Request，表示请求报文有语法错误。 401 Unauthorized，表示需要有认证信息。 403 Forbidden，明确拒绝访问。 404 Not Found，表示无法找到请求的资源，也可以拒绝请求。 500 Internal Server Error，执行请求时候发生了错误。 503 Service Unavailable，超负载或停机维护。 第五章 与HTTP协作的Web服务器单服务器可以用虚拟主机假想有多台服务器，发送HTTP请求时候必须在首部完整指定主机名或域名的URI。 代理：有转发功能的应用程序。 网关：转发其他服务器通信数据的服务器，就像自己拥有资源的服务器一样处理。 隧道：客户端和服务器之间中转。 代理服务器不改变请求UR，会写入Via信息。 代理服务器分是否使用缓存和是否修改报文，缓存代理保存缓存，透明代理不做加工。 网关可以将HTTP请求转化为其他通信协议，提高安全。 隧道不会解析HTTP请求，保持原样。 缓存服务器有缓存有效期，到期会请求新资源。 缓存可以存在浏览器，称为临时网络文件。 第六章 HTTP首部Content-Type表示对象类型，比如text/html 首部字段分为通用，请求，响应，实体首部字段。最后针对报文实体部分使用的首部。 Cache-Control，控制缓存行为，有public所有人都能cache，private只给那个人cache。 no-cache防止从缓存中返回过期资源。可以指定位置，那个位置不要cache。 no-store表示请求响应包含机密信息，不进行缓存。 第七章 HTTPShttp+加密+认证+完整性保护=https SSL层位于http层与tcp层中间，独立于HTTP，SMTP，Telnet都能用。 通信过程： 客户端发送client hello开始ssl，包含ssl版本，加密组件（加密算法密钥长度）列表。 服务端发送server hello，包含ssl版本与加密组件列表。 服务端发送certificate报文，有公钥整数。 服务端发送server hello done，握手协商结束。 客户端用client key exchange回应，包含随机密码串，用公开密钥加密。 客户端发送change cipher spec报文，提示服务器，之后通信会用之前的随机串加密 客户端发送finished，包含全部报文整体校验值，正确解密即成功。 服务端发送change cipher spec。 服务端发送finished。 交换完毕后，开始http。 应用层发送数据会带上报文摘要，保证完整性。 敏感数据才使用https通信，需要节省开销，证书费用。 第八章 确认访问用户身份的认证session管理与cookie应用 将用户id，密码发给服务器。 服务器发放sessionID，记录状态。 客户发送带sessionID的cookie请求。 验证SessionID判定对方是否为真实用户。 第九章 基于HTTP的功能追加协议Ajax使用脚本进行通信，只更新局部页面。 Comet会挂起响应，直到服务器更新。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E5%9B%BE%E8%A7%A3http%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"Bomb Lab解析","text":"前置知识： 汇编 GDB Bomb Lab解析前言 Bomb lab是《深入理解计算机系统》配套实验之一。可执行程序包含着“炸弹”，必须输入六个正确的字符串来进行拆弹。字符串必须通过对程序的汇编码进行分析来得到。本文通过分析拆弹流程，对反汇编技术技巧进行总结。 准备 进入CSAPP LAB 官网进行文件的下载。自学者点击self-study handout下载tar压缩包。解压后得到3个文件，Bomb可执行文件，Bomb.c主函数文件，与README。 安装gdb进行反汇编准备。 观察主函数文件，根据函数来打断点。例如在第一阶段主函数有： 1234input = read_line(); phase_1(input); /* Run the phase */phase_defused(); /* Drat! They figured it out! * Let me know how they did it. */ read_line()该行在文件第73行，就可以先命令行执行gdb bomb，再break 73来打断点，在执行run之后，就会在该地方停顿下来，便于调试。常用gdb指令：i r xxx 查看xxx寄存器存储的信息。x xxx查看xxx内存位置的值。该指令可以带参数来改变值的输出格式。disas xxx将xxx函数或者xxx内存位置的函数反汇编。可以查看对应函数的汇编码。 phase_1 第一阶段的炸弹，主函数代码如上所示。对phase_1函数进行反汇编，可以得到如下： 123456780x0000000000400ee0 &lt;+0&gt;: sub $0x8,%rsp0x0000000000400ee4 &lt;+4&gt;: mov $0x402400,%esi0x0000000000400ee9 &lt;+9&gt;: callq 0x401338 &lt;strings_not_equal&gt;0x0000000000400eee &lt;+14&gt;: test %eax,%eax0x0000000000400ef0 &lt;+16&gt;: je 0x400ef7 &lt;phase_1+23&gt;0x0000000000400ef2 &lt;+18&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000400ef7 &lt;+23&gt;: add $0x8,%rsp0x0000000000400efb &lt;+27&gt;: retq rsp为栈顶指针，第一行减去栈顶指针是为函数留出栈空间，可以忽略。 第二行mov了一行数据，并且后面调用了strings_not_equal函数。eax为函数返回值，test函数用于检测返回值是否为0。后面je指令为0则跳转到+23即add行，不为0则爆炸。 那么我们猜测0x402400位置存放了字符串。当输入字符串和该字符串相同则不爆炸。通过x指令可以看出该内存位置为： 12(gdb) x /s 0x4024000x402400: \"Border relations with Canada have never been better.\" 输入该字符串，即可拆弹成功。 phase_2 同上，对phase_2反汇编可以得到如下： 123456789101112131415161718192021222324252627Dump of assembler code for function phase_2: 0x0000000000400efc &lt;+0&gt;: push %rbp 0x0000000000400efd &lt;+1&gt;: push %rbx 0x0000000000400efe &lt;+2&gt;: sub $0x28,%rsp 0x0000000000400f02 &lt;+6&gt;: mov %rsp,%rsi 0x0000000000400f05 &lt;+9&gt;: callq 0x40145c &lt;read_six_numbers&gt; 0x0000000000400f0a &lt;+14&gt;: cmpl $0x1,(%rsp) 0x0000000000400f0e &lt;+18&gt;: je 0x400f30 &lt;phase_2+52&gt; 0x0000000000400f10 &lt;+20&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000400f15 &lt;+25&gt;: jmp 0x400f30 &lt;phase_2+52&gt; 0x0000000000400f17 &lt;+27&gt;: mov -0x4(%rbx),%eax 0x0000000000400f1a &lt;+30&gt;: add %eax,%eax 0x0000000000400f1c &lt;+32&gt;: cmp %eax,(%rbx) 0x0000000000400f1e &lt;+34&gt;: je 0x400f25 &lt;phase_2+41&gt; 0x0000000000400f20 &lt;+36&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000400f25 &lt;+41&gt;: add $0x4,%rbx 0x0000000000400f29 &lt;+45&gt;: cmp %rbp,%rbx 0x0000000000400f2c &lt;+48&gt;: jne 0x400f17 &lt;phase_2+27&gt; 0x0000000000400f2e &lt;+50&gt;: jmp 0x400f3c &lt;phase_2+64&gt; 0x0000000000400f30 &lt;+52&gt;: lea 0x4(%rsp),%rbx 0x0000000000400f35 &lt;+57&gt;: lea 0x18(%rsp),%rbp 0x0000000000400f3a &lt;+62&gt;: jmp 0x400f17 &lt;phase_2+27&gt; 0x0000000000400f3c &lt;+64&gt;: add $0x28,%rsp 0x0000000000400f40 &lt;+68&gt;: pop %rbx 0x0000000000400f41 &lt;+69&gt;: pop %rbp 0x0000000000400f42 &lt;+70&gt;: retq End of assembler dump. 汇编码较上个阶段明显变长，这里分段解析。 可以看到首先调用了read_six_numbers来进行数据的读取。可以猜测并证实该函数作用为读取6个数，并放入栈中。 第一个引爆出现在cmpl 0x1 (rsp)后。即将栈顶元素与1相比较，不相等则爆炸。那么可以得到，第一个数为1。 在jmp之后将0x4(%rsp)与0x18(%rsp)存放了起来。根据一个数占4个字节可以得出，前者为存放下一个数值到rbx，后者为六个数的边界。 再次jmp之后可以看出，eax存放了rbx的前一个数，并且乘以2了。cmp即将前一个数×2与本数字相比较，不相等则爆炸。那么可以得到后一个数是前一个数的2倍的规律。 后面的代码不言而喻，依次进行数的比较，最后边界检查，到达边界则退出。那么可以得到拆弹代码： 11 2 4 8 16 32 phase_3 首先看代码： 1234567891011121314151617181920212223242526272829303132333435360x0000000000400f43 &lt;+0&gt;: sub $0x18,%rsp0x0000000000400f47 &lt;+4&gt;: lea 0xc(%rsp),%rcx0x0000000000400f4c &lt;+9&gt;: lea 0x8(%rsp),%rdx0x0000000000400f51 &lt;+14&gt;: mov $0x4025cf,%esi0x0000000000400f56 &lt;+19&gt;: mov $0x0,%eax0x0000000000400f5b &lt;+24&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000400f60 &lt;+29&gt;: cmp $0x1,%eax0x0000000000400f63 &lt;+32&gt;: jg 0x400f6a &lt;phase_3+39&gt;0x0000000000400f65 &lt;+34&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000400f6a &lt;+39&gt;: cmpl $0x7,0x8(%rsp)0x0000000000400f6f &lt;+44&gt;: ja 0x400fad &lt;phase_3+106&gt;0x0000000000400f71 &lt;+46&gt;: mov 0x8(%rsp),%eax0x0000000000400f75 &lt;+50&gt;: jmpq *0x402470(,%rax,8)0x0000000000400f7c &lt;+57&gt;: mov $0xcf,%eax0x0000000000400f81 &lt;+62&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f83 &lt;+64&gt;: mov $0x2c3,%eax0x0000000000400f88 &lt;+69&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f8a &lt;+71&gt;: mov $0x100,%eax0x0000000000400f8f &lt;+76&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f91 &lt;+78&gt;: mov $0x185,%eax0x0000000000400f96 &lt;+83&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f98 &lt;+85&gt;: mov $0xce,%eax0x0000000000400f9d &lt;+90&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f9f &lt;+92&gt;: mov $0x2aa,%eax0x0000000000400fa4 &lt;+97&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400fa6 &lt;+99&gt;: mov $0x147,%eax0x0000000000400fab &lt;+104&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400fad &lt;+106&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000400fb2 &lt;+111&gt;: mov $0x0,%eax0x0000000000400fb7 &lt;+116&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400fb9 &lt;+118&gt;: mov $0x137,%eax0x0000000000400fbe &lt;+123&gt;: cmp 0xc(%rsp),%eax0x0000000000400fc2 &lt;+127&gt;: je 0x400fc9 &lt;phase_3+134&gt;0x0000000000400fc4 &lt;+129&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000400fc9 &lt;+134&gt;: add $0x18,%rsp0x0000000000400fcd &lt;+138&gt;: retq 代码依旧很长，分部分进行解析。 最开始调用了sscanf，sscanf的字符串可以通过前面的mov指令猜出，位于0x4025cf。查看可以得知，该字符串为：“%d %d” 读取了两个数，加上前面两个lea指令，可以猜出数存放在0x8(rsp)和0xc(rsp)。 第一个引爆在cmp 0x1 eax，可以得知这是根据sscanf返回值来爆炸。当sscanf匹配数字大于1则不爆炸。 跳转后进行了cmpl $0x7,0x8(%rsp)，即第一个值和7进行比较。大于则爆炸。即第一个输入值需要小于等于7。 下一个将第一个值存入eax，并使用jmp跳转。jmpq star0x402470(,%rax,8)。我们可以先看看0x402470存放的是什么： 12(gdb) print *(0x402470)$1 = 4198268 4798268 = 0x400f7c，即下一行。那么根据地址可以得到，该跳转是利用第一个输入的值作为索引进行跳转，跳到对应指令。 下面结构都是类似的，将一个常数放入eax，并且跳转到与0xc(rsp)进行比较。相等则不会爆炸。以f7c行举例，对应值为0xcf=207那么可以得到一个解为： 10 207 phase_4 同上，看代码： 123456789101112131415161718192021220x000000000040100c &lt;+0&gt;: sub $0x18,%rsp0x0000000000401010 &lt;+4&gt;: lea 0xc(%rsp),%rcx0x0000000000401015 &lt;+9&gt;: lea 0x8(%rsp),%rdx0x000000000040101a &lt;+14&gt;: mov $0x4025cf,%esi0x000000000040101f &lt;+19&gt;: mov $0x0,%eax0x0000000000401024 &lt;+24&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000401029 &lt;+29&gt;: cmp $0x2,%eax0x000000000040102c &lt;+32&gt;: jne 0x401035 &lt;phase_4+41&gt;0x000000000040102e &lt;+34&gt;: cmpl $0xe,0x8(%rsp)0x0000000000401033 &lt;+39&gt;: jbe 0x40103a &lt;phase_4+46&gt;0x0000000000401035 &lt;+41&gt;: callq 0x40143a &lt;explode_bomb&gt;0x000000000040103a &lt;+46&gt;: mov $0xe,%edx0x000000000040103f &lt;+51&gt;: mov $0x0,%esi0x0000000000401044 &lt;+56&gt;: mov 0x8(%rsp),%edi0x0000000000401048 &lt;+60&gt;: callq 0x400fce &lt;func4&gt;0x000000000040104d &lt;+65&gt;: test %eax,%eax0x000000000040104f &lt;+67&gt;: jne 0x401058 &lt;phase_4+76&gt;0x0000000000401051 &lt;+69&gt;: cmpl $0x0,0xc(%rsp)0x0000000000401056 &lt;+74&gt;: je 0x40105d &lt;phase_4+81&gt;0x0000000000401058 &lt;+76&gt;: callq 0x40143a &lt;explode_bomb&gt;0x000000000040105d &lt;+81&gt;: add $0x18,%rsp0x0000000000401061 &lt;+85&gt;: retq sscanf与上个阶段一样，比较返回值并且跳转。同时将第一个数与0xe进行比较，可以得到不大于0xe才能不爆炸。 然后将0xe，0x0和数组第一个值放入相应寄存器，调用func4，最后检查返回值是否为0。可以看出需要继续解析func4。func4代码如下： 123456789101112131415161718192021220x0000000000400fce &lt;+0&gt;: sub $0x8,%rsp0x0000000000400fd2 &lt;+4&gt;: mov %edx,%eax0x0000000000400fd4 &lt;+6&gt;: sub %esi,%eax0x0000000000400fd6 &lt;+8&gt;: mov %eax,%ecx0x0000000000400fd8 &lt;+10&gt;: shr $0x1f,%ecx0x0000000000400fdb &lt;+13&gt;: add %ecx,%eax0x0000000000400fdd &lt;+15&gt;: sar %eax0x0000000000400fdf &lt;+17&gt;: lea (%rax,%rsi,1),%ecx0x0000000000400fe2 &lt;+20&gt;: cmp %edi,%ecx0x0000000000400fe4 &lt;+22&gt;: jle 0x400ff2 &lt;func4+36&gt;0x0000000000400fe6 &lt;+24&gt;: lea -0x1(%rcx),%edx0x0000000000400fe9 &lt;+27&gt;: callq 0x400fce &lt;func4&gt;0x0000000000400fee &lt;+32&gt;: add %eax,%eax0x0000000000400ff0 &lt;+34&gt;: jmp 0x401007 &lt;func4+57&gt;0x0000000000400ff2 &lt;+36&gt;: mov $0x0,%eax0x0000000000400ff7 &lt;+41&gt;: cmp %edi,%ecx0x0000000000400ff9 &lt;+43&gt;: jge 0x401007 &lt;func4+57&gt;0x0000000000400ffb &lt;+45&gt;: lea 0x1(%rcx),%esi0x0000000000400ffe &lt;+48&gt;: callq 0x400fce &lt;func4&gt;0x0000000000401003 &lt;+53&gt;: lea 0x1(%rax,%rax,1),%eax0x0000000000401007 &lt;+57&gt;: add $0x8,%rsp0x000000000040100b &lt;+61&gt;: retq func4代码使用了递归，不是很容易理解，这里我对着每一行翻译了一下，写了个c语言程序，代码如下： 1234567891011121314151617181920212223242526int func4(int edx,int esi,int edi){ int eax = edx; eax-=esi; int ecx = eax; ecx=(unsigned int)ecx&gt;&gt;0x1f; eax+=ecx; eax&gt;&gt;=1; ecx = esi*1+eax; if(ecx&lt;=edi) { eax = 0; if(ecx&gt;=edi) { return eax; }else{ esi = ecx+1; eax = 2*func4(edx,esi,edi)+1; } } else{ edx = ecx-1; eax = 2* func4(edx,esi,edi); } return eax;} 由于是一行一行翻译的，理解不困难。第一个数必定小于等于11，那么可以直接带入值遍历进行计算，实践得出返回值为0的情况。当输入为0 1 3 7时候返回值为0。 接下来代码不需要过多解释，即验证第二个数是不是为0。那么可以得到一个解： 10 0 phase_5 代码如下： 12345678910111213141516171819202122232425262728293031323334353637380x0000000000401062 &lt;+0&gt;: push %rbx0x0000000000401063 &lt;+1&gt;: sub $0x20,%rsp0x0000000000401067 &lt;+5&gt;: mov %rdi,%rbx0x000000000040106a &lt;+8&gt;: mov %fs:0x28,%rax0x0000000000401073 &lt;+17&gt;: mov %rax,0x18(%rsp)0x0000000000401078 &lt;+22&gt;: xor %eax,%eax0x000000000040107a &lt;+24&gt;: callq 0x40131b &lt;string_length&gt;0x000000000040107f &lt;+29&gt;: cmp $0x6,%eax0x0000000000401082 &lt;+32&gt;: je 0x4010d2 &lt;phase_5+112&gt;0x0000000000401084 &lt;+34&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000401089 &lt;+39&gt;: jmp 0x4010d2 &lt;phase_5+112&gt;0x000000000040108b &lt;+41&gt;: movzbl (%rbx,%rax,1),%ecx0x000000000040108f &lt;+45&gt;: mov %cl,(%rsp)0x0000000000401092 &lt;+48&gt;: mov (%rsp),%rdx0x0000000000401096 &lt;+52&gt;: and $0xf,%edx0x0000000000401099 &lt;+55&gt;: movzbl 0x4024b0(%rdx),%edx0x00000000004010a0 &lt;+62&gt;: mov %dl,0x10(%rsp,%rax,1)0x00000000004010a4 &lt;+66&gt;: add $0x1,%rax0x00000000004010a8 &lt;+70&gt;: cmp $0x6,%rax0x00000000004010ac &lt;+74&gt;: jne 0x40108b &lt;phase_5+41&gt;0x00000000004010ae &lt;+76&gt;: movb $0x0,0x16(%rsp)0x00000000004010b3 &lt;+81&gt;: mov $0x40245e,%esi0x00000000004010b8 &lt;+86&gt;: lea 0x10(%rsp),%rdi0x00000000004010bd &lt;+91&gt;: callq 0x401338 &lt;strings_not_equal&gt;0x00000000004010c2 &lt;+96&gt;: test %eax,%eax0x00000000004010c4 &lt;+98&gt;: je 0x4010d9 &lt;phase_5+119&gt;0x00000000004010c6 &lt;+100&gt;: callq 0x40143a &lt;explode_bomb&gt;0x00000000004010cb &lt;+105&gt;: nopl 0x0(%rax,%rax,1)0x00000000004010d0 &lt;+110&gt;: jmp 0x4010d9 &lt;phase_5+119&gt;0x00000000004010d2 &lt;+112&gt;: mov $0x0,%eax0x00000000004010d7 &lt;+117&gt;: jmp 0x40108b &lt;phase_5+41&gt;0x00000000004010d9 &lt;+119&gt;: mov 0x18(%rsp),%rax0x00000000004010de &lt;+124&gt;: xor %fs:0x28,%rax0x00000000004010e7 &lt;+133&gt;: je 0x4010ee &lt;phase_5+140&gt;0x00000000004010e9 &lt;+135&gt;: callq 0x400b30 &lt;__stack_chk_fail@plt&gt;0x00000000004010ee &lt;+140&gt;: add $0x20,%rsp0x00000000004010f2 &lt;+144&gt;: pop %rbx0x00000000004010f3 &lt;+145&gt;: retq 分步骤来进行解析。首先可以看到调用了string_length，后面检测了输入长度是否为6。即输入长度为6的字符串。 经过一番跳转，到达了movzbl (%rbx,%rax,1),%ecx。经过查看可以得知rbx存放的是输入的字符串，rax为索引，最开始为0，然后经过传输后，到达了and 0xf edx。即将该字符ascii码与0xf取与，即取后四位。 然后movzbl 0x4024b0(%rdx),%edx，即以and后的值索引并覆盖该寄存器，在该内存位置可以看到字符串为： 12(gdb) print (char*) 0x4024b0$2 = 0x4024b0 &lt;array&gt; \"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\" 覆盖寄存器后另一个mov，即将该字符放入栈。在之后指进行六次循环，得到新的六个字符。 在得到新字符串后又调用了string_not_equal，而目标字符串则在0x40245e，查看可以得知： 12(gdb) print (char*) 0x40245e$3 = 0x40245e \"flyers\" 那么该输入的字符串，后四位所形成的索引需要构成flyers新字符串。以0开始计数，flyer分别在原字符串的位置是9 15 14 5 6 7 。 经过查表可以得知，要使ascii后四位等于上述数列，一个可行的答案为： 1)/.%&amp;' phase_6 最长以及六个炸弹中最难的一个。我写了一套完整的注释来方便理解。如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091100x00000000004010f4 &lt;+0&gt;: push %r140x00000000004010f6 &lt;+2&gt;: push %r130x00000000004010f8 &lt;+4&gt;: push %r120x00000000004010fa &lt;+6&gt;: push %rbp0x00000000004010fb &lt;+7&gt;: push %rbx0x00000000004010fc &lt;+8&gt;: sub $0x50,%rsp0x0000000000401100 &lt;+12&gt;: mov %rsp,%r130x0000000000401103 &lt;+15&gt;: mov %rsp,%rsi0x0000000000401106 &lt;+18&gt;: callq 0x40145c &lt;read_six_numbers&gt;0x000000000040110b &lt;+23&gt;: mov %rsp,%r14 栈顶放到r140x000000000040110e &lt;+26&gt;: mov $0x0,%r12d 0放到r120x0000000000401114 &lt;+32&gt;: mov %r13,%rbp r13放到rbp0x0000000000401117 &lt;+35&gt;: mov 0x0(%r13),%eax *r13放到eax0x000000000040111b &lt;+39&gt;: sub $0x1,%eax eax减10x000000000040111e &lt;+42&gt;: cmp $0x5,%eax eax和5比大小0x0000000000401121 &lt;+45&gt;: jbe 0x401128 &lt;phase_6+52&gt; eax小于等于5则不炸。0x0000000000401123 &lt;+47&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000401128 &lt;+52&gt;: add $0x1,%r12d r12加一0x000000000040112c &lt;+56&gt;: cmp $0x6,%r12d 0x0000000000401130 &lt;+60&gt;: je 0x401153 &lt;phase_6+95&gt; r12等于6则跳到95 边界检查0x0000000000401132 &lt;+62&gt;: mov %r12d,%ebx r12放进ebx0x0000000000401135 &lt;+65&gt;: movslq %ebx,%rax ebx放进rax0x0000000000401138 &lt;+68&gt;: mov (%rsp,%rax,4),%eax *（4乘rax+rsp）放进eax/第ebx个数放进eax0x000000000040113b &lt;+71&gt;: cmp %eax,0x0(%rbp) 边界检查0x000000000040113e &lt;+74&gt;: jne 0x401145 &lt;phase_6+81&gt; 第ebx个数与第r13存放的数不相等则跳过0x0000000000401140 &lt;+76&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000401145 &lt;+81&gt;: add $0x1,%ebx ebx加一0x0000000000401148 &lt;+84&gt;: cmp $0x5,%ebx 比较ebx和50x000000000040114b &lt;+87&gt;: jle 0x401135 &lt;phase_6+65&gt; 小于等于则跳到650x000000000040114d &lt;+89&gt;: add $0x4,%r13 r13加40x0000000000401151 &lt;+93&gt;: jmp 0x401114 &lt;phase_6+32&gt; 跳到32ebx为内层循环变量j。r12为外层循环变量i。for(i=0;i&lt;=5;i++){ if((*r13)-1&lt;=5) not explode; for(j=i+1;j&lt;=5;j++) { if((*r13)!=(*(rsp+j))) not explode; } r13++;}0x0000000000401153 &lt;+95&gt;: lea 0x18(%rsp),%rsi 数组的末尾放进rsp放进rsi0x0000000000401158 &lt;+100&gt;: mov %r14,%rax r14放进rax 数组开头放入rax0x000000000040115b &lt;+103&gt;: mov $0x7,%ecx 0x7放进ecx0x0000000000401160 &lt;+108&gt;: mov %ecx,%edx ecx放进edx0x0000000000401162 &lt;+110&gt;: sub (%rax),%edx edx减去rax值0x0000000000401164 &lt;+112&gt;: mov %edx,(%rax) edx值存入rax值0x0000000000401166 &lt;+114&gt;: add $0x4,%rax rax地址加40x000000000040116a &lt;+118&gt;: cmp %rsi,%rax 比较rax和rsi0x000000000040116d &lt;+121&gt;: jne 0x401160 &lt;phase_6+108&gt; 不等于则跳回108a[i] = 7-a[i]0x000000000040116f &lt;+123&gt;: mov $0x0,%esi esi归零0x0000000000401174 &lt;+128&gt;: jmp 0x401197 &lt;phase_6+163&gt; 跳到1630x0000000000401176 &lt;+130&gt;: mov 0x8(%rdx),%rdx edx+8的值放进edx0x000000000040117a &lt;+134&gt;: add $0x1,%eax eax+10x000000000040117d &lt;+137&gt;: cmp %ecx,%eax 比较ecx和eax0x000000000040117f &lt;+139&gt;: jne 0x401176 &lt;phase_6+130&gt; 不等于则跳回1300x0000000000401181 &lt;+141&gt;: jmp 0x401188 &lt;phase_6+148&gt; 跳到1480x0000000000401183 &lt;+143&gt;: mov $0x6032d0,%edx 0x6032d0放到edx 0x0000000000401188 &lt;+148&gt;: mov %rdx,0x20(%rsp,%rsi,2) edx放进*(rsp+2*rsi)+0x200x000000000040118d &lt;+153&gt;: add $0x4,%rsi rsi+40x0000000000401191 &lt;+157&gt;: cmp $0x18,%rsi 边界检查0x0000000000401195 &lt;+161&gt;: je 0x4011ab &lt;phase_6+183&gt; 跳到1830x0000000000401197 &lt;+163&gt;: mov (%rsp,%rsi,1),%ecx 把rsp+rsi放进ecx rsi为0 4 8 16 32 640x000000000040119a &lt;+166&gt;: cmp $0x1,%ecx 比较ecx和1 比较数组值0x000000000040119d &lt;+169&gt;: jle 0x401183 &lt;phase_6+143&gt; 数组值小于等于1则跳回1430x000000000040119f &lt;+171&gt;: mov $0x1,%eax eax放成10x00000000004011a4 &lt;+176&gt;: mov $0x6032d0,%edx 0x6032d0放进edx0x00000000004011a9 &lt;+181&gt;: jmp 0x401176 &lt;phase_6+130&gt; 跳到130130-139 循环使得edx = 0x6032d0+8*a[i]然后放入*(rsp+2*rsi+0x20) rsi为数组的索引 0x00000000004011ab &lt;+183&gt;: mov 0x20(%rsp),%rbx rsp+20放进rbx0x00000000004011b0 &lt;+188&gt;: lea 0x28(%rsp),%rax rsp+28放进rax0x00000000004011b5 &lt;+193&gt;: lea 0x50(%rsp),%rsi rsp+50放进rsi0x00000000004011ba &lt;+198&gt;: mov %rbx,%rcx rbx放进rcx0x00000000004011bd &lt;+201&gt;: mov (%rax),%rdx rax值放入rdx0x00000000004011c0 &lt;+204&gt;: mov %rdx,0x8(%rcx) rdx放入rcx值+80x00000000004011c4 &lt;+208&gt;: add $0x8,%rax rax+80x00000000004011c8 &lt;+212&gt;: cmp %rsi,%rax 比较rsi和rax 边界检查0x00000000004011cb &lt;+215&gt;: je 0x4011d2 &lt;phase_6+222&gt; 相等则跳入2220x00000000004011cd &lt;+217&gt;: mov %rdx,%rcx rdx放进rcx0x00000000004011d0 &lt;+220&gt;: jmp 0x4011bd &lt;phase_6+201&gt; 跳回2010x00000000004011d2 &lt;+222&gt;: movq $0x0,0x8(%rdx) rdx+8置零类似于链表操作。rdx = *rax *(rcx+8) = *rax rax+=8 rcx = rdx 按照数组的顺序重新连接链表。0x00000000004011da &lt;+230&gt;: mov $0x5,%ebp ebp放50x00000000004011df &lt;+235&gt;: mov 0x8(%rbx),%rax rbx+8值放进rax0x00000000004011e3 &lt;+239&gt;: mov (%rax),%eax rax值放进eax0x00000000004011e5 &lt;+241&gt;: cmp %eax,(%rbx) 比较eax和rbx值0x00000000004011e7 &lt;+243&gt;: jge 0x4011ee &lt;phase_6+250&gt; rbx值大于等于eax则跳到2500x00000000004011e9 &lt;+245&gt;: callq 0x40143a &lt;explode_bomb&gt;0x00000000004011ee &lt;+250&gt;: mov 0x8(%rbx),%rbx rbx+8值放入rbx0x00000000004011f2 &lt;+254&gt;: sub $0x1,%ebp ebp减去10x00000000004011f5 &lt;+257&gt;: jne 0x4011df &lt;phase_6+235&gt; 如果不为0则跳回235 遍历链表，保证链表的遍历顺序为数组的降序。0x00000000004011f7 &lt;+259&gt;: add $0x50,%rsp0x00000000004011fb &lt;+263&gt;: pop %rbx0x00000000004011fc &lt;+264&gt;: pop %rbp0x00000000004011fd &lt;+265&gt;: pop %r120x00000000004011ff &lt;+267&gt;: pop %r130x0000000000401201 &lt;+269&gt;: pop %r140x0000000000401203 &lt;+271&gt;: retq 具体注释如上，该阶段使用了类似于链表的操作。通过输入六个数字，然后使用7减去每个数字，再将数字的索引顺序匹配为链表的连接顺序，再观察链表里的值实现降序排列。 再本次中，链表的值如下所示： 12345678(gdb) x /12xg 0x6032d00x6032d0 &lt;node1&gt;: 0x000000010000014c 0x00000000006032e00x6032e0 &lt;node2&gt;: 0x00000002000000a8 0x00000000006032f00x6032f0 &lt;node3&gt;: 0x000000030000039c 0x00000000006033000x603300 &lt;node4&gt;: 0x00000004000002b3 0x00000000006033100x603310 &lt;node5&gt;: 0x00000005000001dd 0x00000000006033200x603320 &lt;node6&gt;: 0x00000006000001bb 0x0000000000000000 由于使用32位寄存器，只用看后八位进行排序。39c&gt;2b3&gt;1dd&gt;1bb&gt;14c&gt;0a8 即为3 4 5 6 1 2 。在进行7-之后可以得到答案： 14 3 2 1 6 5 隐藏关卡 实在写不动了，据说是个二叉树。我放弃了。 总结与心得 本次实验主要是熟悉了汇编语言以及反汇编流程，熟悉了gdb的使用。最开始做lab的时候，我对汇编完全没有任何了解，从最开始的每一行都需要百度，到最后理解了每一行的含义，我确实了解了很多计算机相关知识。总而言之我自己认为这次收获还是很大的。有人说汇编是最后的底线，我之前一直觉得汇编对于我这种写高级语言的没什么关系，毕竟编译器优化后的汇编本来就很难读得懂，但现在觉得只要默认不优化的情况下，多了一种找bug的方法。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/bomb-lab%E8%A7%A3%E6%9E%90/"},{"title":"2020 6.824 lab1解析","text":"前置知识： go linux 2020 6.824 lab1解析前言 本系列主要是对mit课程6.824的lab进行解析，包括部分原理的讲解以及代码的实现。主要使用go来进行编写。本文讲解的是lab1，根据给定的代码框架来实现MapReduce结构。 介绍 6.824是mit的分布式系统课程，而该课程的实验也就是lab目的为通过给定的代码框架来实现通用的分布式系统。该课程lab在2020年进行了部分更新，例如本次的lab1就进行了大改，与前几年几乎完全不同，因此以往网络上的各路教程也就过时了。详细课程资源可以到6.824官方网站进行查看。 本文的lab1实现的是MapReduce架构，作为谷歌在2003年发表的论文，为现在的分布式计算思想提供了很明确的方向。它继承于函数式编程的思想，并且在谷歌内部真正进行了实现与运用。本文便根据给定的代码框架以及论文思想，来实现这么一个模型。 原理简介 MapReduce如上文所说，源于函数式编程思想，简单来说Map对应“映射”，Reduce对应“归约”，前者将数据切分从而映射到键值对（key-value对）组，后者将键值对组进行整理归纳，并整合到输出文件。该算法的优势在于优秀的并行化，可以使用多台计算机来应对计算规模的增加，从而节省时间。 但在具体原理上，我们还需要阅读谷歌发表的那篇论文从而了解更多细节。该论文写的很好，在实现细节不理解的情况下建议多读几遍。但在这里还是简述一下论文的观点。 论文中提供了编程模型的实现：通过master机器来统筹工作，通过worker机器来进行具体的map或者reduce工作。master给worker分配map或者reduce工作，worker接收到map工作时便读取对应数据，执行map工作，将map完成后的键值对组存于磁盘，并且通知master完成工作。当master了解到所有map工作完成后，便通知worker进行reduce工作。worker接收到指令后便读取磁盘上的对应键值对。然后通常先对键值对组进行排序，然后进行reduce工作，并存于输出文件中。同样，在master了解到所有文件已经reduce完成后便可以进行退出。 下面本文的实验也将基于上述模型来实现。 准备工作 进入lab1官网，官网的准备工作说的相当清楚。要准备linux环境，go环境，然后下载实验文件。这里需要一些基本的linux知识，不过官网已经将步骤给的相当清楚了。再次不过多赘述。 实验目标与流程 从官网可以看到，lab1的实验目标是完成mr文件夹中的master.go rpc.go worker.go三个文件，并且在main文件夹中通过mrmaster.go来创建一个master，通过执行多次mrworker.go来创建多个worker来运行。同时实验也给定了一个串行的结果正确的文件mrsequential.go，可以来参考以及改bug。在实验最后，我们需要对写好的文件进行测试。文件给了我们一个shell脚本test-mr.sh，该脚本会执行真正的应用程序以及给定各种实验场景，我们的目标是通过该测试。 在mr文件夹中，rpc.go负责master与worker之间的通信。这里可能需要rpc的一些知识来理解，但在本次实验中可以简单理解为worker以rpc.go内的结构体为参数，调用master.go文件中的函数来与master进行通讯。在master和worker的文件内也给定了样例，并且在worker内部还封装好了call函数，即使不理解rpc也可以学样例编写程序。 在worker文件中，可以看到Worker的参数为两个func，即map和reduce两个函数，这是在创建worker时候就给定的，那么我们可以想到在worker函数内部，我们需要主动找master要工作。同时在完成工作后，我们也需要找master汇报工作，同时接受下一份工作，直到master让你休假（但休假完还是要上班）或者master卷款跑路。（太资本主义了） 在master文件中，可以看到初始化master时候给定了文件名序列以及reduce后文件的数量。毫无疑问，我们先要把这些存起来。然后根据上述worker的工作流程，master的工作也可以确认：接受worker的工作请求，查看手里有啥空闲的工作，有map就给map，map活都接完但是没干完的就让员工先休假，等到map活干完再来分配reduce工作。reduce工作都干完了就可以卷款跑路（调用Done函数return true）了。（太资本主义了） 工作流程基本如上，虽然很形象，但接下来，我们需要具体用代码去实现它。 RPC.go master与worker要通过rpc进行通讯，那么我们先来规范好通讯协议，知道员工该告诉老板啥，老板该告诉员工啥，才能更好地展开工作。在这里，我们将worker发给master的数据称为请求，反过来称为相应。 首先，无论是map工作还是reduce工作，无论是分配工作还是汇报工作，都要通过文件来进行。master需要告诉worker去读取哪个文件，worker需要告诉master哪个文件已经完成了。因此在请求和相应二者中，可以确定的一项是filename。数据类型这里选用的是string。 其次，除了工作地点也就是文件名之外，还要汇报工作类型，是map还是reduce。所以无论是请求还是相应，都需要有表示工作类型的数据。这里我在请求中使用Status进行表示，同时也可以表示worker自己完成了工作还是在休假；响应中使用JobName进行表示。数据类型均为string。或许有些英语不准确但问题不大。 我们可以得到以下代码： 1234567891011type RPCArgs struct { Status string Filename string}type RPCReplys struct { JobName string Filename string NReduce int NMap int} 这里args为请求，replys为响应。在响应中多了两项，是为了worker更好地工作而传送的，在介绍worker时候会进行介绍。 master 明确沟通协议后，master的工作就很明确了：存储各种工作状态，分配工作，接受汇报工作并且改变工作的状态，并在所有工作结束自己退出。我们先根据上述描述了解master需要存什么。 首先，MakeMaster参数中的filenames和nReduce肯定是要存的，毫无疑问。 其次，需要存储各个工作的状态。在这里可以使用数组来表示，0表示未分配，1表示工作中，2表示已完成。这样做的另一个好处是在工作时间过长的时候可以重新把该工作设置为未分配，从而达到容错的效果。这里需要两个数组，mapTasks []int 和 reduceTasks []int。 第三，标志工作完成的标识符。这里用的mapDone和reduceDone两个int来标识。这也是确认工作完成来切换到reduce工作的标志。于是我们可以得到以下声明： 12345678910type Master struct { // Your definitions here. filenames []string mapTasks []int32 reduceTasks []int32 nReduce int nMap int mapDone int reduceDone int} 可以看到多了个nMap，也是为了worker便于工作而存放的。 MakeMaster函数便不用多说，进行初始化即可。 确定完协议后，就需要真正的函数来进行通信处理。这里使用的函数我命名为GetJob，接受参数如下： 1func (m *Master) GetJob(args *RPCArgs, reply *RPCReplys) error 确定协议后就需要做事了。首先我们来接受worker的汇报工作，如果他完成的工作叫map，则找到他完成的工作，划掉工作。具体代码如下： 12345678if args.Status == \"map\" { for index, value := range m.filenames { if args.Filename == value &amp;&amp; atomic.LoadInt32(&amp;m.mapTasks[index]) == 1 { atomic.StoreInt32(&amp;m.mapTasks[index], 2) break } }} 横向有点长，主要是因为会有多个线程同时访问数组，要保证数组操作的原子性，从而调用函数。reduce代码基本一样，不过多赘述。 接收汇报后便要先检测工作干完没有，干完了就可以直接结束。没干完就继续发配。这里检测是否完成与终止master进程的函数一样，调用了Done函数。 Done函数遍历工作池，如果所有工作都做完了，则删掉MapReduce的中间产生的键值对组，返回true值。否则返回 false。这里写的麻烦了点，而且删掉中间产物也不应该由master来做，在shell测试脚本中由shell来清空了中间产物。但最终可以过测试就行。 12345678910111213141516171819202122232425262728293031func (m *Master) Done() bool { ret := false m.mapDone = 1 m.reduceDone = 1 for _, value := range m.mapTasks { if value != 2 { m.mapDone = 0 break } } for _, value := range m.reduceTasks { if value != 2 { m.reduceDone = 0 break } } if m.mapDone == 1 &amp;&amp; m.reduceDone == 1 { ret = true fmt.Println(\"Done jobs\") for i := 0; i &lt; m.nReduce; i++ { for j := 0; j &lt; m.nMap; j++ { f, err := os.OpenFile(\"mr-\"+strconv.Itoa(i)+\"-\"+strconv.Itoa(j), os.O_RDWR|os.O_TRUNC, 0666) if err != nil { fmt.Println(err) } f.Close() } }//删掉中间产物 } return ret} 在结束条件确认之后，身为master便可以尽情发配工作了。发配工作流程是，检测第一个未分配工作，如果有则分配下去并且开始计时，计时结束如果未完成说明遭受了意外完成不了，重新变为未分配。如果完成了则一切安好。如果所有工作都分配了但有的未完成，便可以先叫员工休假。代码如下： 1234567891011121314151617181920if m.mapDone == 0 { index := m.getMapIndex()//手动封装的函数，找到第一个为0的数组索引，否则返回-1 if index != -1 { reply.JobName = \"map\" reply.Filename = m.filenames[index] reply.NMap = index//在map时候传送index数，在reduce时候传输nmap总数，便于中间文件的命名 atomic.StoreInt32(&amp;m.mapTasks[index], 1) go func() { time.Sleep(time.Duration(10) * time.Second) if atomic.LoadInt32(&amp;m.mapTasks[index]) != 2 { atomic.StoreInt32(&amp;m.mapTasks[index], 0) } }()//计时器，完成了则安好，未完成则改成未分配 } else { reply.JobName = \"free\"//休假 reply.Filename = \"\" } } reduce同理，不过多赘述。至此，我们完成了master与worker所需要通信的所有东西……除了函数返回值。我们需要返回一个error类型。我选择的是干脆返回一个nil。 不要忘了nMap和nReduce两个通信参数，在接下来的部分会用到。 至此，master部分结束了，接下来讲解worker部分。 worker worker部分我们需要完成的也就是主要的Worker函数，也就是那个接收两个函数为参数的函数。我们需要完成的也很简单：循环调用GetJob来联系Master，接收到map活则干map，接收到reduce活则干reduce，接收到暂停任务则sleep一下，如果联系不到则说明Master工作已经完成，干脆自己也退出就行。 worker主要部分也就确定了。一个大循环体，最开头是联系Master获得任务，代码如下： 123if call(\"Master.GetJob\", &amp;args, &amp;reply) == false { return } 注意，go是没有while的，你需要使用for循环。 接收到map工作后，先打开老板给的文件名，读取文件，将文件调用map函数，得到一个键值对组，存入中间文件中。中间文件的命名便有讲究：采用将key哈希成数字，然后对nReduce进行取余计算，这样可以保证相同的key计算值是一样的，同时也保证了分布式计算的正确性。将此数字作为中间文件名的一部分，同时另一部分采用map的号码，也就是传输过来的NMap号，来构成二元组。这样即保证了每个map任务的结果互不干扰，在一个map任务挂掉后重新执行该map，能够直接清空文件并再次编写。当进行reduce任务的时候，由于map数字是固定的，便于索引。 由于在mrsequential.go中实现了串行的MapReduce，因此可以复制粘贴一部分代码到里面。具体代码如下： 123456789101112131415161718192021222324252627282930313233else if reply.JobName == \"map\" { filename := reply.Filename file, err := os.Open(filename) if err != nil { log.Fatalf(\"cannot open %v\", filename) } content, err := ioutil.ReadAll(file) if err != nil { log.Fatalf(\"cannot read %v\", filename) } file.Close() kva := mapf(filename, string(content))//读取文件，调用map var files []*os.File for i := 0; i &lt; reply.NReduce; i++ { f, err := ioutil.TempFile(\"./\", \"tmp-map*\")//建立临时文件，可以保证程序意外退出后能够直接清空 if err != nil { fmt.Println(err) } files = append(files, f) } for _, kv := range kva { name := ihash(kv.Key) % reply.NReduce//哈希操作 f := files[name] fmt.Fprintf(f, \"%v %v\\n\", kv.Key, kv.Value)//将key相同的放进一个文件 } for index, value := range files { value.Close()//保存临时文件，同时改名为正式的中间文件的名字。也就是NMAP的作用 os.Rename(value.Name(), \"mr-\"+strconv.Itoa(index)+\"-\"+strconv.Itoa(reply.NMap)) } args.Status = \"map\" args.Filename = filename reply = RPCReplys{} } 代码不短，但有注释，很容易理解。 到reduce部分，reduce部分干的活便是打开reduce号对应的所有中间文件，读取他们，并对他们进行排序。然后，同样是为了容错，根据reduce号建立输出文件的临时文件。然后，遍历排序过的键值对组，将key值相同的文件，调用reduce函数归纳整理，将结果输出到临时文件中。最后，重命名临时文件到正式文件。 与map相同，由于在mrsequential.go中有对排序的实现以及文件名字命名的规范，文件内容的规范，我们也可以复制粘贴过来。具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051else if reply.JobName == \"reduce\" { var kvs []KeyValue var kv KeyValue filecode := reply.Filename for i := 0; i &lt; reply.NMap; i++ { filename := \"mr-\" + filecode + \"-\" + strconv.Itoa(i) ifile, err := os.OpenFile(filename, os.O_RDONLY, 0666)//根据reduce号计算中间文件名字，读取所有中间文件 if err != nil { log.Fatalf(\"cannot read %v\", filename) } for { _, err := fmt.Fscanf(ifile, \"%v %v\", &amp;kv.Key, &amp;kv.Value) if err != nil { fmt.Println(err) break } kvs = append(kvs, kv) } ifile.Close() } fmt.Println(\"len =\", len(kvs)) sort.Sort(ByKey(kvs))//对键值对组排序，ByKey可以参考mrsequential.go oname := \"mr-out-\" + reply.Filename ofile, err := ioutil.TempFile(\"./\", \"out-tmp*\")//临时文件，便于出错时直接丢弃 if err != nil { fmt.Println(\"output error\") } else { i := 0 for i &lt; len(kvs) { j := i + 1 for j &lt; len(kvs) &amp;&amp; kvs[j].Key == kvs[i].Key { j++ } values := []string{} for k := i; k &lt; j; k++ { values = append(values, kvs[k].Value) } output := reducef(kvs[i].Key, values) fmt.Fprintf(ofile, \"%v %v\\n\", kvs[i].Key, output) i = j } } ofile.Close()//这一部分参考mrsequential.go os.Rename(ofile.Name(), oname)//重命名 args.Status = \"reduce\" args.Filename = reply.Filename reply = RPCReplys{}} 至此，worker基本完成了。还有个休假部分，简单的sleep就行，不过多赘述。 整个MapReduce实验便完整地完成了。 测试 代码写完当然要测试。在lab1的官网上，给了我们一个很好的各种测试办法。具体可以参考官网。这里说说最终测试。 最后我们要执行的，是test-mr.sh的shell脚本。测试总共五项：测试word count程序，测试indexer程序，map并行化测试,reduce并行化测试以及容错测试。前两个是应用测试。中间两个我也不知道怎么测的，我也没看Shell源码，反正直接过了。最后一个容错测试值得多说几句。在现实生活中会遇到各种各样的错误，在上面实现的容错，也就是通过master在分配工作后检测给定时间内是否完成，未完成则重新分配，只能解决worker挂掉的问题。本次测试的也是如此。但现实生活中，可能master也会挂掉。这些问题在论文中提供了解决的思路。同时在论文中也有着多种优化的技巧与思路，所以论文值得多读几遍。 在执行完test-mr.sh最后，会有如下输出。如果你的结果和以下一样，恭喜你，你完成了本次实验。 12--- crash test: PASS*** PASSED ALL TESTS 总结 现在是凌晨2.15，写本博客比预先构想所花的时间要更长。写6.824的计划其实半年前学完go就想写了，但由于各种原因拖到最近才写完，从下载6.824到写完lab1过掉所有test只花了两天时间，和预想差不多。写本文花了两个半多小时。半年前最开始动手的时候感觉相当的迷茫，不知道从何下手，先是对go不熟悉，怕各种错误糊一脸，然后是对项目文件的不熟悉。这个过程中，仔细看官网，读论文，搜资料着实起到了很大的帮助。也幸亏MapReduce论文看了好几遍，让我交上了信息检索课的作业。 总之，正确早日写完6.824，不要留坑。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/2020-6-824-lab1%E8%A7%A3%E6%9E%90/"},{"title":"初探容器化：隔离，限制与docker run","text":"本文为容器化技术系列文章的第一篇。本文将介绍容器化中的隔离，限制的原理，并且实际编写一个类docker应用，并且实际执行docker run命令。 前置知识 Linux Go 初探容器化：隔离，限制与docker run目录 前言 隔离 Namepspaces 系统 Go的系统调用 限制 Cgroups技术 Cgroups实战 docker run 基本结构 实战docker_run 下一步做什么 总结与后记 隔离Namepspaces 系统： Namespaces 系统是linux对于系统资源的一种抽象，它使得进程认为在同一namespaces系统下的进程之间能够互相感知，而对namespace外一无所知，从而实现隔离的效果。 linux最新版本中，根据不同的功能，实现了7个namespace系统，如下所示： NamespaceConstantIsolatesCgroupCLONE_NEWCGROUPCgroup root directoryIPCCLONE_NEWIPCSystem V IPC, POSIX message queuesNetworkCLONE_NEWNETNetwork devices, stacks, ports, etc.MountCLONE_NEWNSMount pointsPIDCLONE_NEWPIDProcess IDsUserCLONE_NEWUSERUser and group IDsUTSCLONE_NEWUTSHostname and NIS domain name 详情可见man namespaces。具体命名空间数量由linux版本决定，在这里，由于只实现简易版本，我们只使用到IPC Network Mount PID User UTS这几个namespace。在内核版本3.8之后，这几个namespace都可用。 在man文档中，给了我们几种系统调用的方法，分别是： clone：创建新进程，根据flag数，为每一个flag创建一个namespace，将进程封入进去。 setns：将调用的进程封装进已经存在的namespace里面。 unshare：将正在调用的进程封装进由flags确立的新的namespaces里面。 ioctl:查看namespaces的信息。 文档中给出了这些信息，但我们不一定需要使用裸露的api，go为我们封装了它。 Go的系统调用： 在go的syscall库中，为我们封装了系统调用。我们可以通过设置SysProcAttr结构体，来进行系统调用。该结构体定义如下： 12345678910111213141516171819type SysProcAttr struct { Chroot string // Chroot. Credential *Credential // Credential. Ptrace bool // Enable tracing. Setsid bool // Create session. Setpgid bool // Set process group ID to Pgid, or, if Pgid == 0, to new pid. Setctty bool // Set controlling terminal to fd Ctty (only meaningful if Setsid is set) Noctty bool // Detach fd 0 from controlling terminal Ctty int // Controlling TTY fd Foreground bool // Place child's process group in foreground. (Implies Setpgid. Uses Ctty as fd of controlling TTY) Pgid int // Child's process group ID if Setpgid. Pdeathsig Signal // Signal that the process will get when its parent dies (Linux only) Cloneflags uintptr // Flags for clone calls (Linux only) Unshareflags uintptr // Flags for unshare calls (Linux only) UidMappings []SysProcIDMap // User ID mappings for user namespaces. GidMappings []SysProcIDMap // Group ID mappings for user namespaces. // GidMappingsEnableSetgroups enabling setgroups syscall. // If false, then setgroups syscall will be disabled for the child process. // This parameter is no-op if GidMappings == nil. Otherwise for unprivileged // users this should be set to false for mappings work. GidMappingsEnableSetgroups bool AmbientCaps []uintptr // Ambient capabilities (Linux only) } 在结构体中，我们着重关注Cloneflags,Unshareflags,UidMappings,GidMappings,这些在namespaces系统中，可能会用得到。 下面是一个小demo，用于展示如何使用SysProcAttr去创建进程并且封入新的namespace里面。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"syscall\" \"os/exec\" \"os\" \"fmt\")func main(){ cmd:=exec.Command(\"sh\") fmt.Println(\"start namespace demo\") cmd.SysProcAttr = &amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS|syscall.CLONE_NEWIPC|syscall.CLONE_NEWPID|syscall.CLONE_NEWNS|syscall.CLONE_NEWUSER, UidMappings: []syscall.SysProcIDMap{ { ContainerID: syscall.Getuid(), HostID: syscall.Getuid(), Size: 1, }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: syscall.Getgid(), HostID: syscall.Getgid(), Size: 1, }, } } cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr if err:=cmd.Run();err!=nil { log.Fatal(err) } fmt.Println(\"end namespace demo\")} 在demo，创建了子进程，启动了一个sh，并且封入了各个namespace中。在这个demo中，可以尝试各种指令来尝试隔离性，如ps -ef。 限制Cgroups技术 Namespace技术保证了各个进程的隔离。而若要添加诸如内存大小的限制，我们需要学习cgroups技术。 Control cgroups，通常称为cgroups，是linux内核提供的特性，它能使进程被组织进hierarchical groups，可以用来限制和监视各种资源的使用。内核的cgroup接口通过伪文件系统cgroupfs来调用。分组操作在cgroup内核中实现，而资源跟踪和限制则是通过资源类型子系统来实现。 cgroup 是绑定到通过 cgroup 文件系统定义的一组限制或参数的进程的集合。 subsystems 是修改cgroup进程的行为的内核组建。各式各样的子系统能够用来执行一些操作，诸如限制cpu时间或者内存。subsytems也被成为资源控制器。 控制器的cgroup按层次结构排列。 通过在cgroup文件系统中创建，删除和重命名子目录来定义此层次结构。 在层次结构的每个级别，都可以定义属性（例如，限制）。 cgroup提供的限制，控制和计费通常在定义属性的cgroup之下的整个子层次结构中都有效，例如，后代不能超过在层次结构中较高级别上放置在cgroup上的限制cgroups。 Cgroups实战 环境需要 stress程序 用于模拟系统负载较高场景 首先我们创建文件夹，并且把cgroup挂载进去。执行一下命令： 12345root@wqy:/home/wqy# mkdir cgroup-testroot@wqy:/home/wqy# sudo mount -t cgroup -o none,name=cgroup-test cgroup-test ./cgroup-testroot@wqy:/home/wqy# ls ./cgroup-test/cgroup.clone_children cgroup.sane_behavior release_agentcgroup.procs notify_on_release tasks 可以看到，在我们挂在完成后，文件内创建了一些默认的文件。其中cgroup.clone_childred代表子cgroup是否继承父cgroup的cpuset cgroup.procs代表树中当前节点所有进程组id notify_on_release代表最后一个进程退出后是否执行release_agent release_agent是个路径 用于退出后自动清理 tasks表示cgroup下的进程id。 我们可以在此文件夹中增加新的cgroup来进行测试。执行以下指令： 12345678910111213141516171819202122root@wqy:/home/wqy/cgroup-test# sudo mkdir cgroup-1root@wqy:/home/wqy/cgroup-test# sudo mkdir cgroup-2root@wqy:/home/wqy/cgroup-test# tree.├── cgroup-1│&nbsp;&nbsp; ├── cgroup.clone_children│&nbsp;&nbsp; ├── cgroup.procs│&nbsp;&nbsp; ├── notify_on_release│&nbsp;&nbsp; └── tasks├── cgroup-2│&nbsp;&nbsp; ├── cgroup.clone_children│&nbsp;&nbsp; ├── cgroup.procs│&nbsp;&nbsp; ├── notify_on_release│&nbsp;&nbsp; └── tasks├── cgroup.clone_children├── cgroup.procs├── cgroup.sane_behavior├── notify_on_release├── release_agent└── tasks2 directories, 14 files 可以看到，在添加子cgroup后，子cgroup继承了属性。 接下来，我们为进程加入限制。我们将创建一个stress程序，占用200m内存，观察限制前与限制后是否有区别。 1stress --vm-bytes 200m --vm-keep -m 1 执行以上指令，在本机的top中可以看到，%MEM项目为2.6,即200M。接下来，加上限制。 12345678root@wqy:/home/wqy/cgroup-test# mount |grep memorycgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)root@wqy:/home/wqy/cgroup-test# cd /sys/fs/cgroup/memory root@wqy:/sys/fs/cgroup/memory# sudo mkdir test-limit-memoryroot@wqy:/sys/fs/cgroup/memory# cd test-limit-memory/root@wqy:/sys/fs/cgroup/memory/test-limit-memory# sudo sh -c \"echo \"100m\" &gt;memory.limit_in_bytes\" root@wqy:/sys/fs/cgroup/memory/test-limit-memory# sudo sh -c \"echo $$ &gt; tasks\"root@wqy:/sys/fs/cgroup/memory# stress --vm-bytes 200m --vm-keep -m 1 在上述命令中，我们通过mount和grep找到了memory所在的挂载点，在挂载点创建了子cgroup：test-limit-memory，将内存限制写入了限制文件，将本进程写入了task，最后执行了指令。通过top命令可以看到 %MEM项目为1.3,即100M。我们成功实现了限制内存使用。 在完成了namespace隔离demo和cgroup限制demo后，我们即将用go语言，将这些整合在一起，实现简单的隔离限制程序。 docker_run 该部分代码仓库：github:mydockerpractice 具体为main.go subsystem cgroupmanager container四个部分。 基本结构 在实现简易的docker run之前，我们需要理清思路：我们即将要编写的文件，how it works。 功能 实现命令行解析参数 包括命令种类如run 资源限制如-m 在指定run命令后 使用namespace创建子进程 并且执行命令行给予的程序 在指定限制之后 能使用cgroup加入限制 解析文件可以由第三方库来实现，这里使用的是github.com/urfave/cli，在上述vendor文件夹中可以找到。 实战docker_run 首先，我们来确认主函数功能：启动cli，绑定各种参数，进行解析。剩下事务交给其他模块来做。我们可以得到以下主函数： 1234567891011121314151617181920212223242526272829package mainimport ( \"github.com/urfave/cli\" \"fmt\" \"os\" \"strings\" \"io/ioutil\" _ \"github.com/Sirupsen/logrus\" container \"mydocker/container\" subsystem \"mydocker/subsystem\" cgroupmanager \"mydocker/cgroupmanager\")const usage = `mydocker is a simple container.`func main(){ app := cli.NewApp() app.Name = \"mydocker\" app.Usage = usage app.Commands = []cli.Command{ initCommand, runCommand, } if err:= app.Run(os.Args); err!=nil { fmt.Println(err) } } 可以看到，我们定义了两个启动命令init和run，分别是初始化容器和启动程序。我们将在下面介绍两个指令的功能。 runCommand以及Run函数：runCommand解析参数并且传递给Run函数。Run函数使用NewParentProcess创建了带namespace的进程，创建了cgroup管理程序，配置了限制，应用到进程上，并且将程序指令写入pipe，便于namespace的进程调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var runCommand = cli.Command{ Name : \"run\", Usage : \"Create a container\", Flags : []cli.Flag{ cli.BoolFlag{ Name : \"ti\", Usage: \"enable tty\", }, cli.StringFlag{ Name : \"m\", Usage : \"limit the memory\", }, }, Action: func(context *cli.Context) error { fmt.Println(\"start runCommand\") if len(context.Args()) &lt; 1 { return fmt.Errorf(\"Missing container command\") } var cmdArray []string for _, arg := range context.Args() { cmdArray = append(cmdArray, arg) } tty := context.Bool(\"ti\") resConf := &amp;subsystem.ResourceConfig{ MemoryLimit: context.String(\"m\"), } Run(tty, cmdArray, resConf) return nil },}/*Run command start a parentprocess with namespacestart a CgroupManagerset the configstore the command*/func Run(tty bool, commandArray []string, resConf *subsystem.ResourceConfig){ parent, writePipe := container.NewParentProcess(tty) if err:= parent.Start(); err!=nil { fmt.Println(err) return } cgroupManager := cgroupmanager.NewCgroupManager(\"mydocker-cgroup\") defer cgroupManager.Destroy() cgroupManager.Set(resConf) cgroupManager.Apply(parent.Process.Pid) sendInitCommand(commandArray, writePipe) parent.Wait()} 注意上述NewParentProcess，这是完成程序隔离的重要函数。在下面我们会讲解它。 12345678910111213141516171819202122232425262728293031323334353637383940/*NewParentProcess function:creates a child precess with namespaces, run itself in the process, create a pipe and file for the Run fucntion to write*/func NewParentProcess(tty bool) (*exec.Cmd, *os.File){ fmt.Println(\"New parent\") readPipe, writePipe, err := NewPipe() if err!=nil { fmt.Printf(\"pipe error %v\\n\",err) return nil,nil } cmd := exec.Command(\"/proc/self/exe\",\"init\") cmd.SysProcAttr = &amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWNET |syscall.CLONE_NEWUSER, UidMappings: []syscall.SysProcIDMap{ { ContainerID: syscall.Getuid(), HostID: syscall.Getuid(), Size: 1, }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: syscall.Getgid(), HostID: syscall.Getgid(), Size: 1, }, }, } if tty { cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr } cmd.ExtraFiles = []*os.File{readPipe} return cmd, writePipe} 这便是NewParentProcess的全貌。它启动了一个子cmd，套上了namespace隔离，并且最终要的一点，它使用了以init参数exec /proc/self/exe 这相当与它在子进程中以init参数调用它自己，重新启动。这会覆盖掉当前的数据，堆栈，PID等，从而实现了使用指定的run进程覆盖掉init进程的办法。就这样，我们便得到了一个守护进程以及一个被隔离的容器进程。 该函数返回了writePipe，便是方便将指令传达给子进程。它使用了ExtraFiles属性，意味着在创建子进程时候会额外携带该句柄。在操作系统中，几乎总是分配最小的可用句柄。由于0 1 2为标准输入输出错误句柄，这样在子进程中，就可以直接打开3号句柄获取指令。（虽然硬编码非常不优雅） 在隔离之后，我们还要为其加上限制。这一部分功能是由CgroupManager来完成。这里只实现了内存的限制，我们来从内存，观察CgroupManager是如何工作的。 1234567891011121314151617181920212223242526272829303132type CgroupManager struct { Path string Resource *subsystem.ResourceConfig}func NewCgroupManager(path string) *CgroupManager{ return &amp;CgroupManager{ Path: path, }}func (c *CgroupManager) Apply(pid int) error { for _, subSysIns := range(subsystem.SubsystemIns) { subSysIns.Apply(c.Path, pid) } return nil}func (c *CgroupManager) Set(res *subsystem.ResourceConfig) error { for _, subSysIns := range(subsystem.SubsystemIns) { subSysIns.Set(c.Path, res) } return nil}func (c *CgroupManager) Destroy() error{ for _, subSysIns := range(subsystem.SubsystemIns) { if err:= subSysIns.Remove(c.Path); err!= nil { fmt.Printf(\"error in remove cgroup %v\\n\",err) } } return nil} 可以看到，CgroupManager包含了路径以及资源限制的配置ResouceConfig。而在Run函数中可以看到，CgroupManager实现了Apply,Set,Destroy等方法，这些方法本质上是将ResouceConfig传递给subsystem文件中的SubsystemIns，使用SubsystemIns的多态方法进行调用。 接下来我们来观察subsystem文件声明，来观察它是如何限制资源的。 12345678910111213141516171819202122package subsystemtype ResourceConfig struct { MemoryLimit string CPUShare string CPUSet string}type Subsystem interface { Name() string Set(path string, res *ResourceConfig) error Apply(path string, pid int) error Remove(path string) error}var ( SubsystemIns = []Subsystem{ //&amp;CPUSetSubSystem{}, &amp;MemorySubSystem{}, //&amp;CPUSubSystem{}, }) 在这里可以看出，SubsystemIns是一个Subsystem数组，其中包括MemorySubSystem。Subsystem接口规定了实现的方法，Name,Set,Apply,Remove。 接下来让我们以MemorySubSystem为例子，观察具体的限制是如何实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*Set functionwrite the memory limit into the cgroup path*/func (s *MemorySubSystem) Set(cgroupPath string, res *ResourceConfig) error { if subsysCgroupPath, err := GetCgroupPath(s.Name(),cgroupPath,true); err == nil{ if res.MemoryLimit != \"\" { if err := ioutil.WriteFile(path.Join(subsysCgroupPath, \"memory.limit_in_bytes\"), []byte(res.MemoryLimit),0644); err != nil { return fmt.Errorf(\"set cgroup memory failed %v\",err) } } return nil } else { return err }}/*Apply functionJoin a process into a cgroup*/func (s *MemorySubSystem) Apply(cgroupPath string, pid int) error { if subsysCgroupPath, err := GetCgroupPath(s.Name(),cgroupPath,false); err == nil { if err := ioutil.WriteFile(path.Join(subsysCgroupPath, \"tasks\"),[]byte(strconv.Itoa(pid)),0644); err!=nil { return fmt.Errorf(\"set cgroup proc fail %v\",err) } return nil } else { return fmt.Errorf(\"get cgroup %s error: %v\",cgroupPath,err) }}/*Remove functionremove the cgroup path*/func (s *MemorySubSystem) Remove(cgroupPath string) error { if subsysCgroupPath, err := GetCgroupPath(s.Name(),cgroupPath,false); err == nil { return os.Remove(subsysCgroupPath) } else { return err }}/*Name functionget its name*/func (s *MemorySubSystem) Name() string{ return \"memory\"} 此处代码有注释，不过多赘述。本质上和之前的demo一样，写入限制文件，将进程放进去，和移除该进程限制所在的文件夹。在这里GetCgroupPath作用是根据mountinfo找到cgroup限制的文件夹，并创建子目录。具体代码可以在仓库内查看。 就此，限制系统demo便完成了。接下来我们来观察init指令执行后，该进程会如何运行。 1234567891011var initCommand = cli.Command { Name : \"init\", Usage : \"Init the process\", Action: func(context *cli.Context) error { fmt.Println(\"start initCommand\") cmd := readUserCommand() err := container.RunContainerInitProcess(cmd[0],cmd[1:]) return err },} 回到主进程。在创建子进程并且以init为参数执行了/proc/self/exe后，相对应接收的便是init指令。上面可以看到，init指令读取了之前的参数，并且初始化了容器进程。读取指令就像之前所说一样，可以采用fd=3的硬编码打开读取。 接下来我们来看看RunContainerInitProcess该如何运行。 123456789101112131415161718192021222324252627282930313233/*RunContainerInitProcess function:mounts the essential environment, read the command stored by the NewParentProcess,run the commands*/func RunContainerInitProcess(command string, args []string) error{ fmt.Printf(\"the command is %s\\n\",command) fmt.Println(\"mount start\") err :=syscall.Mount(\"\",\"/\",\"\",syscall.MS_PRIVATE|syscall.MS_REC,\"\") if err!=nil { fmt.Println(err) return err } defaultMountFlags := syscall.MS_NOEXEC | syscall.MS_NOSUID | syscall.MS_NODEV err = syscall.Mount(\"proc\", \"/proc\",\"proc\", uintptr(defaultMountFlags),\"\") if err!=nil { fmt.Println(err) return err } command,err = exec.LookPath(command) if(err!=nil){ fmt.Printf(\"error in finding %s \\n\",command) fmt.Println(err) return err } argv := append([]string{command},args...) if err := syscall.Exec(command, argv, os.Environ()) ; err!=nil { fmt.Printf(\"exec error is %v\\n\",err) return err } return nil} 可以看到，该函数接收两个参数，command和args，首先实现了chroot防止proc不释放，然后将proc挂载了进来，便于在容器内实现各种操作。之后，使用LookPath解析了指令，并且exec了程序。至此，我们实现了资源的限制，资源的隔离，并且在完成这些配置后运行了程序。一个简单的docker run项目便如此完成了。 下一步做什么 在docker中，除去隔离与限制，最显著的特点便是它的image镜像功能。这能大大减少部署环境的难度。在下一篇文章中，我们将探讨如何实现这一功能。 总结与后记 本篇文章讲解了如何实现一个隔离并且进行限制的小docker程序。在这其中主要熟悉了各种系统调用的作用与使用方法，以及如何进行实现。由于篇幅问题，本文省略了一部分工具代码，具体代码还需要参考仓库内。在仓库中有各种demo的实现。 本文对系统调用的知识主要来自对man文档的翻译，可能存在欠缺。因此有不足的地方欢迎指正。 本篇文章起于11.12，完成于11.16，由于各种原因存在一些拖延，但整体完成时间较长。本文主要也是我自己对于代码的一个复习于归纳。 下一篇文章不存在意外的话预计不会耗费多余一周的时间。敬请期待。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E5%88%9D%E6%8E%A2%E5%AE%B9%E5%99%A8%E5%8C%96%EF%BC%9A%E9%9A%94%E7%A6%BB%EF%BC%8C%E9%99%90%E5%88%B6%E4%B8%8Edocker-run/"},{"title":"白帽子谈web安全读书笔记","text":"本文主要为白帽子谈web安全的读书笔记，用于记录。 白帽子谈web安全第一章 概述安全三要素： 机密性：数据加密，不被泄露。 完整性：数据完整，不被篡改。 可用性：保护资源随需求而得。 安全评估流程：资产阶级划分-&gt;威胁分析-&gt;风险分析-&gt;确认解决方案 威胁分析：伪装 篡改 抵赖 信息泄露 拒绝服务 提升权限 第二章 浏览器安全同源： 浏览器js使用同源策略来防护。不能跨域访问资源。 “同源”依据包括：域名或ip地址，子域名，端口，协议。 DOM cookie XMLHttpRequest以及一些插件如flash都会有着同源策略。 沙箱： 沙箱泛指资源隔离模块谷歌浏览器采用沙箱机制，多进程来限制代码执行。但一些第三方插件如flash，java等不受sandbox管辖，成为浏览器攻击热点。 恶意网站拦截： 基于页面特征识别，在服务端进行模型建立处理，使用黑名单，与安全厂商合作，推送黑名单。 EV证书：数字证书颁发机构与浏览器厂商一起打造的，增强对安全网站的识别。 第三章 XSS跨站脚本攻击：使用html注入篡改网页，插入恶意脚本 反射型XSS：将用户输入的数据反射给浏览器，需要诱使用户点击恶意链接才能攻击成功。非持久性XSS。 存储型XSS：写下包含恶意js的博客，发表后所有访问博客的都会执行代码。又叫持久型XSS。 DOM Based XSS：修改页面DOM节点来实现 cookie劫持 先xss访问远程脚本并且加载，再利用image的src，利用url参数中加入cookie来访问目标域名。只需要访问留下日志，即可窃取。 构造get post请求 get与上述类似，用过img的src来构造get请求。 post则使用js，构造表单（用js或者直接写html），或者用XMLHttpRequest来构造。 除了一般cookie以外，还可以通过观察network，构造sid之类的，进行模拟访问来获取消息。 xss钓鱼 xss将验证码url发到远程服务器，等待接收并且返回给xss来绕开验证码。 使用xss用js在界面画出伪造的登录框，发送密码到服务器。 浏览器以及用户软件识别 观察UA或者使用版本判断代码来识别浏览器版本。 通过新建控件来判断用户是否安装软件，如新建ActiveX空间XunLeiBHO.ThunderIEHelper来判断是否安装了迅雷软件。 还可以通过第三方软件来观察，如Flash的system.capabilities来找到硬件信息。 firefox的插件可以通过查询DOM来找到。 chrome插件可以通过访问chrome://flashgot/skin/icon32.png来查询。 通过CSS观察链接颜色来看是否访问过网站。 通过XSS调用Java Applet接口获取本地真实ip地址，本地网络信息。 攻击平台 Attack API：总结了许多XSS Payload归纳成api BeEF：有控制后台，攻击者可以在后台控制前端，展示完整XSS攻击过程。 XSS Proxy：嵌套ifrane实时远程控制背XSS攻击的浏览器。 调试JS Firebug Fiddler HttpWatch 浏览器Debugger XSS构造与攻击 使用字符编码，如GBK下两个字符在Unicode下被认为为一个字符，绕开系统安全检查。 绕开长度限制，如使用event或者将payload写在别出，再获取payload。 local.hash不会在http包发送，可以藏代码。 可以用注释将html代码注释掉，如第二个文本框允许写入更多细节，那么可以通过注释打通两个文本框。 通过base标签表示链接的base地址，使用这个标签来访问外部js。 window.name没有特殊字符限制，可以实现数据的跨域传输。也可以缩短payload长度。 通过flash构造http请求来威胁服务器。 使用存储型XSS嵌入反射型XSS进行攻击 Flash可以嵌入ActionScript脚本来攻击。 XSS防御 HttpOnly 可以防止js读取到cookie 输入检查，使用白名单或黑名单检查格式，而且必须在服务端检查，而非客户端。 可以使用输出检查，编码或者转义来实现，比如使用编码函数，在多个地方用多种编码 富文本中event应当被禁止，用白名单，使用开源项目来帮助检查。 第四章 跨站点请求伪造CSRF跨站点伪造请求，称为CSRF。 cookie策略 session cookie：临时cookie 在浏览器关闭后cookie就失效了 保存在浏览器进程的内存空间 third-party cookie：在服务器expire时间之后cookie才会失效 保存在本地 如果从一个域的页面加载另一个域的资源，IE safari会阻止third-party cookie发送 firefox chrome不会 P3P头不会拦截第三方cookie发送，用于广告等跨域访问 ，可以加以利用。 跨站点post 可以构造好一个form表单，用js自动提交，甚至隐藏在不可见的iframe的窗口中。 FLASH CSRF Flash也能有多种方法发送网络请求。 CSRF防御 验证码：强制用户进行交互，完成最终请求。但不能给所有操作都加上验证码。 referer check：检查referer来源，但由于不能什么时候都获取到referer。 Token：业界最主要做法。在链接中加入Token=randomblablabla值 token值不可预测，从而实现鉴别。可以放在cookie和session中，检查是否一致。token在一个用户的有效生命周期，在成功提交过后，应当消耗掉。 第五章 点击劫持使用一个透明的iframe覆盖，欺骗进行点击。使用CSS控制alpha通道进行实现。 flash也可以点击劫持，通过flash游戏诱导点击按钮变化，最后一步步操作打开了用户摄像头。 图片也可以劫持，通过调整图片css到任意位置，点击就会到钓鱼网站。 拖拽劫持：拖拽处隐藏iframe，拖拽完成后同时完成数据传输。 触屏劫持：触屏，离开屏幕，滑动都是事件，可以利用，比如造一个假地址栏。 防御 frame busting 禁止iframe嵌套 但由于是用js写的，因而可以绕过它 还可以用sandbox限制js脚本执行。 用x-frame-options的http头，拒绝加载任何frame页面 第六章 HTML5安全新标签，新安全 通过新标签，如video audio来远程加载音频，绕过filter。 使用sandbox以及属性来控制同源访问，运行脚本等。 使用noreferer来不再发送referer。 使用canvas能够进行破解验证码。 w3c有跨域请求标准，需要带origin header来防止csrf。 postMessage允许没以恶个窗口对象往其他窗口发送文本消息，实现跨窗口消息传递。不受同源策略限制。但也可以用xss payload来实现iframe，用PostMessage给父窗口发送消息。 web stroage分为session storage和local storage，前者关闭则会失效，后者一直存在。使用kv对来进行操作。也受同源策略约束。 第七章 注入攻击用户能够控制输入，而且程序需要执行的代码拼接了用户输入的数据。 SQL注入 盲注：在没有错误回显的情况下完成攻击，虽然缺少调试信息，但可以构造简单语句观察页面是否变化。 Timing Attack：根据benchmark函数，观察时间长短来观察是否注入成功。可以利用各种数据库函数来获取有用信息。如果有写权限，甚至可以写入磁盘。 攻击技巧 用substring可以找对应版本。 可以用union select来确定表是否存在，列是否存在。 确定列存在后，可以用字符范围来读取表内信息。 可以用自动化工具sqlmap。 可以用load_file读取文件，用into_dumpfile写入文件，然后创建表导入数据来查看数据。 可以用用户自定义函数来获取系统权限，可以通过lib_mysqludf_sys提供的几个函数执行系统命令，如sys_eval和sys_exec，这些被集成到sqlmap中。 ms sql server可以用xp_cmdshell来执行系统命令，oracle可以用java。 存储过程本身可能存在注入漏洞，注意文本处理。 注意字符集的统一，避免各个字符集差异导致转义问题。 sql不开严格模式，遇到超长输入可能会截断，那么插入与admin同名数据后，根据逻辑可能就可以越权访问。 防御 有些escape只能转义部分字符，黑名单形式不太行。 预编译语句是防范注入的最好方法。 使用安全的存储过程也能抵抗sql注入。 检查数据类型可以防范注入。 使用安全函数可以对抗sql注入，比如编码函数。 最好方法是限制权限，如自定义函数，操作本地文件。 其他注入 XML注入，可以构造恶意数据来插入。 代码注入，主要发生在eval等不安全的函数上。jsp的include也能导致注入，多见于脚本语言。 CRLF注入，这俩是不同语义的分隔符，可以注入来改变语义，修改日志。 最后 数据与代码分离，在拼凑的地方进行安全检查即可。 第八章 文件上传漏洞上传了可执行脚本，通过脚本文件获取到了执行服务端命令的能力。 安全问题： 上传web脚本语言，服务器的web容器解释了脚本 上传了flash的策略文件crossdomain.xml，黑客用来控制flash在该域下的行为 上传了病毒木马文件，诱骗下载 上传钓鱼图片或者包含了脚本的图片，被当成脚本执行 上传文件作为入口，溢出后台处理程序 上传的文件能被Web容器解释执行，所在目录是web容器所覆盖的目录，用户能够通过web访问，而且没有被安全检查，格式化，图片压缩等。 绕开上传检查 在文件名后面添加一个%00的字符，在c php被认为是终止符，那么可以构造文件名绕开文件名后缀类型检查。 判断前十个字节通常能判断文件的真实类型，因此可以伪造文件头前256个字节，判断文件类型。 功能or漏洞 在apache曾经的文件解析中，会从后往前解析，直到遇到认识的文件名为止。 在IIS文件解析中，截断字符为分号；因此可以造脚本名。文件夹扩展名也存在问题，/.asp/文件夹下的文件都被解释为asp文件。 针对IIS，可以用PUT方法和MOVE方法，将文本文件改写为脚本文件。首先用OPTIONS来查看支持的方法，然后用PUT上传文本文件，然后使用MOVE改名。 php cgi路径解析存在问题，当访问xxx.com/a.jpg/x.php时候会把a.jpg当php解析。原因是解析地址名时候会向上递归。 302能跳转到钓鱼网站，而利用文件上传功能，通过传播这个文件的url进行钓鱼，在老版本的IE中会将图片当HTML执行。 设计文件上传 文件上传目录没有exec权限，作为静态文件处理。 判断文件类型，使用MIME Type 后缀名等用白名单方法，对于图片可以用压缩函数或者resize函数来破坏代码。 用随机数改写文件名，文件路径。 单独设置文件服务器的域名。 第九章 认证和会话管理认证用于辨认用户是谁，授权用于决定用户能做什么。 密码必须用不可逆的加密算法，单向散列函数加密存储在数据库中。 破解MD5后的方法：彩虹表，收集大量明文和MD5，来进行查找。可以通过加盐处理。 sessionID通常加密后保存在Cookie中，但也可能被窃取。 如果登录前后sessionID没有发生变化，则会发生session fixation问题，用户X可以诱导用户Y改变session状态来实现攻击。比如诱导点击URL。所以在登陆完成后需要重写sessionID。 session存在保持攻击，只要不停发起请求，就可以一直活下去。 有些时候session不会在服务端维护，用客户端的cookie的expire时间，但由于在客户端，因此很容易被攻击。 可以强制销毁session，或者当ip ua变化时候强制销毁重新登录。不允许多个session生效。 单点登录SSO：登录以此可以访问所有系统。这样可以集中风险，在重点使用多种方法，甚至委托给第三方。既是优点也是缺点。可以用OpenID框架来认证。 第十章 访问控制访问控制是某个主题对某个客体实施某种操作的限制。可以通过ACL访问控制列表来决定。 基于URL的访问控制，通过权限认证是否能访问url来实现。可以通过字典找到url来访问。 spring security支持基于url method 表达式的访问控制，配置文件复杂，学习维护成本较高。 用户-角色-权限 称之为垂直权限管理。 需要检查资源是否属于对应用户，虽然角色共享，但存在私有数据。因此也存在水平权限管理问题。 OAuth是不提供用户名和密码情况下，授权第三方应用访问Web资源的安全协议.用request token换access token，然后用access token访问资源。 可以使用外部OAuth库来进行使用。 第十一章 加密算法和随机数常见有分组加密和流密码加密。 流密码：基于异或操作，常见错误是对同一个密钥多次加解密，由于异或运算的特性决定。同样利用原理，可以构造和管理员一样的密文来越权，这个可以用消息验证码MAC验证是否被篡改。有时候存在弱随机问题，可以暴力破解。 WEP密码就是采用流密码的RC4，可以用暴力和等待初始化向量重复来执行。 ECB电码本模式，每个分组之间相对独立，可以观察出来。改变密文顺序也可以改变明文顺序，有其统计特征。 CBC链式加密模式，前后会互相关联。先将初始化向量和第一个分组异或完成并且DES完成，然后将结果与第二个分组异或。最后填充不正确则会抛出异常。 如果最后一个分组消息长度没有达到，则会填充，比如剩下5个字节则每个字节填充个5之类的。如果正好为8则加一个全为8的分组。 CBC模式破解：先根据密文长度，检查是8字节还是16字节。然后构造初始化向量，直到padding正确，这时候就能确定中间值的最后一位。同理，可以确定中间值的所有位，从此可以获得明文。 密钥管理 不要把密钥硬编码到代码里面。当代码广泛传播，或者逆向后会被泄露，能够访问到代码的人员也会泄露。正确做法是放在配置文件或者数据库中。并且减少访问权限。在生产环境中需要重新生产密钥，定期更换密钥，可以将所有密钥放在一个服务器中，通过服务来获取密钥，不屑道本地文件中，只加载到内存里。 伪随机数 openssl曾经只能以pid为seed，导致只有32768个种子，很快可以遍历key。 许多地方都用伪随机数。系统时间替代伪随机数容易生成问题，因为这适合时间顺序增长的。不要把时间函数当随机数用。 伪随机数存在种子，rand的范围非常小，只有32767。伪随机数种子确定后求的值是固定的。由于种子数量可能固定，因而可以遍历。当已知第一个值之后，可以猜测种子进行遍历。可以发送keep alive头，强制所有服务端使用同一php进程响应。 这些可以使用足够安全的随机数算法解决。 总结 不要用ECB 不要流密码 用HMAC-SHA1替代MD5 不要用相同key做不同事情 salt和初始向量要随机 用别人实现的加密算法 不要依赖系统的保密性 用CBC的AES256加密 用HMAC-SHA512检查 用带salt的SHA256进行Hash 第十二章 WEB框架安全在正确的地方做正确的事，Model层要解决的问题不要丢给view层。 在不同的场景需要不同的编码函数，比如存在一些场景，自动转码不够用，有些场景需要加入sql转码，xml转码，js转码等。 读写操作需要区分，在存在写操作需要注意CSRF。 在web框架中防csrf： session中绑定token 或者代为保存到cookie中 form中自动填入token字段 ajax自动添加token post时候验证token参数 控制HTTP头，管理好跳转函数，控制Location字段，使用封装好的cookie函数。 使用ORM应对SQL注入，预编译，找到动态变量来实现。 文件上传也用别人写好的。 spring security为Spring mvc提供许多安全功能，但缺乏XSS CSRF等。 Web框架自身也可能存在安全问题。 第十三章 应用层拒绝服务攻击DDOS：分布式拒绝服务，有SYN泛洪，UDP泛洪，ICMP泛洪。 应用层DDOS区别于网络层，TCP已经建立连接。比如在大流量网站siteA上插入iframe代码。 应对DDOS可以采用限制请求频率，但IP可以发生变化，或者大量僵尸机器。因此要做好性能优化，负载均衡，CDN，限制请求频率。 验证码可能存在遍历图片的破解方法，有时候根据sessionID生成的验证码未失效。但现在也存在机器识别。 防御DDOS可以让客户端解析一段js，并且给出正确的运行结果。还可以设置参数缓解DDOS。可以根据频率进行拦截。 并发连接数量存在上线，如果所有连接都被占用，就会拒绝服务。因而可以消耗资源。 HTTP POST用很慢的速度发包，连接不断开，可能导致资源耗尽。 使用XSS，写入一个超长cookie导致无法访问，也会导致拒绝服务。 正则写的不好也可能导致资源大量消耗，可能导致正则计算复杂度过高，从而攻击。 第十四章 PHP安全文件包含漏洞 PHP：include include_once require require_once fopen readfile JSP :java.io.File java.io.FileReader ASP：include file include virtual 当使用include，会被作为php代码执行，不会在意包含文件类型。当include通过动态变量包含文件，而且用户可以控制该变量，则可以利用。 php内核使用c语言，因此可以利用0字符截断。此外还可以利用最大字符长度，用./来构造目录。构造目录方法可以用编码来利用。 fopen fclose同样危险，因为可以读取敏感文件。 可以利用字符来遍历目录漏洞。可以用Open_basedir来限制。 PHP还能加载远程文件，构造URL来执行。 包含本地文件需要知道具体位置，可以包含session文件，他在/tmp目录下。也可以用包含日志文件，可以在凌晨去攻击日志。 位置可以用默认安装，自定义安装的各种目录来猜测。可以用自动化脚本来打。 目录位置完全猜不到，可以尝试错误回显，或者利用/proc/self/environ，看环境变量来完成攻击。 临时文件可以暴力猜文件名，可以利用这一点。 变量覆盖漏洞 变量未初始化而且能被控制，则很不安全。可以在url里面覆盖全局变量。 extract可以将变量从数组导入符号表，可以overwrite。 防御：先保证register_globals = OFF 防止各种可能造成变量覆盖的函数，记得初始化变量。 代码执行漏洞 小心危险函数，比如popen system passthru exec eval等。 第十五章 WebServer配置安全Apache httpd 检查Module安装情况，注意最小权限，减少不必要Module，注意Module的安全漏洞。 不要以高权限身份运行Apache，入侵后会获得高权限shell，apache本身会做危险操作。 Nginx Nginx要注意自身软件版本，合理配置文件，处理UA之类的来管控服务。 jBoss 管理后台功能强大，默认没有认证，有多种远程执行命令的方法。 Tomcat Tomcat后台也默认跑在8080，部署war包需要manager权限，可以脚本自动打。 读后感在第15章之后，都是一些更高层面的安全问题，我自己觉得这些层面的问题虽然也很重要，但缺乏细节，有些事情也不是开发岗能解决的事。我自己本人是后端开发岗，有些更高层次的问题不是属于我能解决的问题，所以没有阐述。 就我个人而言，我认为这本书还是相当有价值的，尽管我本人不写PHP，而且这本书也有些年头了，一些东西也过时了，但对于我这个完全没有什么安全经验的人，能够读懂，了解一些安全的内容，还是很有意思。 这本书介绍的一些例子很好地展示了一些攻击的手段，“黑客”自我从小以来一直是个很炫酷的称号，在阅读了这些手段之后我也觉得，一些手段着实是利用了人性，充满智慧，相当巧妙。能够想到这些手段的人或许是灵光一现，但也经历过相当的积累，我对此无比感慨。这些奇怪的手段，让这本书作为假期的消遣娱乐也算很有意思。 当然，对手段的了解也意味着对手段的防范，在书中其实提到不少，用第三方写好，经历过检验的安全库，用设计良好的框架来保护，这也是开发的一个技巧。在安全方面，如果自己水平不够，这也是一个很好的解决方法。 文章格式有些混乱，这也是我自己的笔记习惯，阅读不便请见谅。 2021年1月15日 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%B0%88web%E5%AE%89%E5%85%A8%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"操作系统课程学习","text":"本文主要是操作系统的一些学习笔记。 第一章 操作系统概述操作系统是控制软件，管理应用程序，限制软件资源，杀死应用程序。 资源管理，外设管理，资源分配。 层次在硬件之上，应用程序之下。 组件包括：CPU调度，物理内存管理，虚拟内存管理，文件系统管理，中断处理和设备驱动。 Kernel特征： 并发：一段时间内多个程序运行。 并行：一个时间点运行多个程序。 共享资源，给不同的应用程序。同时访问，互斥共享。 虚拟：多道程序设计技术，每个用户都觉得计算机专门服务。 异步：程序执行走走停停，但运行环境相同，OS保证运行结果相同。 微内核：只把最基础服务放入内核，其他服务放入用户态。 外核：由应用程序而不是操作系统管理硬件资源。 VMM：虚拟机监视器，跑在传统OS之下，虚拟出整个计算机，包含各种外设。因硬件资源过剩而诞生。 第二章 操作系统基础操作启动 DISK存放OS。 BIOS基本IO系统，让计算机启动后检测各种外设。检测完成后才能完成加载响应软件。 Bootloader：加载OS。 BIOS加典后从特定地址（x86 CS:IP = 0xf000:fff0 CS段寄存器 IP指令寄存器）加载bootloader。 BIOS加电后先POST加电自检，寻找显卡和执行BIOS。 然后从硬盘上加载Bootloader，在硬盘第一个引导扇区512KB。主要功能把OS从硬盘加载到内存。 x86上，将bootloader从引导扇区加载到0x7c00。CPU控制权交给bootloader。 bootloader：找到硬盘扇区，了解os长度，加载到内存。完成后跳到os起始地址，控制权交给os。 中断 异常 系统调用 操作系统：系统调用，异常，中断。 系统调用：主动向操作系统发出服务请求。 异常：非法指令或者坏的处理状态。 中断：来自外设，计时器或网络的中断。 内核是被信任的第三方，只有OS可以执行特权指令。 三者源头不同，处理时间不同。 中断异步，异常同步，系统调用异步或者同步。 响应：中断对应用程序不可见，异常会杀死应用程序或者重新执行。系统调用会等待和持续。 首先要知道中断或者异常是谁产生的。收到中断后查找中断表，保留现场，转到目标地址。 硬件需要设置各种事件中断标记，提供中断ID。 软件需要保存处理现场，处理中断服务，清除中断标记，重新执行服务。 异常也有异常编号，然后处理异常（杀死或重新执行），然后恢复现场。 系统调用：程序访问高层次API而非系统调用。如WIN32-API POSIX-API Java-API（非系统调用，而是JVM）。 系统调用需要维护序号，建立索引，系统调用接口进行调用，返回系统调用的状态以及其他返回值。用户不需要知道系统调用如何实现。 用户态：特权级低，无法访问特殊指令。内核态：可以执行任何指令。 应用程序和操作系统存在各自的堆栈，有转换的开销。 内核核心转换的开销：找到中断/异常/系统调用，并初始化开销。建立堆栈开销。验证参数的开销，内核态映射到用户态的地址空间的开销，需要更新页面映射权限。内核态有着自己独立的地址空间。内存拷贝存在开销。 第三章 连续内存分配层次 计算机主要结构有CPU 内存 外设。 内存有层次结构，操作系统无法更改L1 L2这些CPU的cache。 管理目标： 抽象：不用考虑物理内存，置用逻辑地址空间。 保护：独立地址空间。 共享：访问相同内存。 虚拟化：有着更多的地址空间。 管理内存不同方法：程序重定位，分段，分页，虚拟内存，按需分页虚拟内存。 操作系统依赖硬件，如MMU。 地址空间 地址生成 物理地址空间：硬件支持的地址空间。 逻辑地址空间：一个运行的程序所拥有的内存范围。 运行程序对程序而言地址仍然是逻辑地址。有映射关系。 MMU用来表示映射关系。 操作系统需要确保地址合法，找到界限寄存器，保证是否小于目标界限，否则产生异常。 连续内存分配 外碎片：分配单元之间无法使用的内存。 内碎片：分配单元内无法使用的内存。 fist fit/best fit/worst fit/ 压缩式碎片整理：调整位置，把程序挪到一些挨紧，开销大不大。 交换式：把硬盘当作内存后备，抢占等待的程序并回收内存，交换到硬盘。 第四章 非连续内存分配分段，分页，页表。 非连续分配优点：物理地址空间非连续，更好的内存利用和管理，允许共享代码和数据，允许动态加载动态链接。 缺点：开销大，软件或硬件转换虚拟地址-物理地址。 硬件方法：分段分页。 分段 分离和共享，将不同的段分散到不同的物理地址空间，如堆，栈，数据，text段。 分段寻址方案：访问内存需要段号和段内偏移，这俩可以放在两个寄存器，也可以放在单一地方。 段有段表，由操作系统建立，存逻辑段号和物理段号映射。 先检测Limit，再加上偏移形成物理地址。 分页 段尺寸可变，页大小不变。页划分物理内存到固定的大小，2的幂。frame表示物理，page表示逻辑。 MMU和TLB转换逻辑地址到物理地址。 帧包含帧号（f 有2eF个帧）和帧内偏移（S位）（f,o) ，得出物理地址2eS×f + o。 页与帧计算类似，但页号和帧号大小不一定对应。 页表 大数组。先查询flag，访问不存在的页时候会缺页异常，否则查到页号对应帧号。 存在问题，访问一个内存单元需要两次内存访问。页表可能非常大。 解决方法：缓存。间接访问，多级页表。 TLB：缓存近期访问的页帧转换表项。快表，在CPU中。页表存在内存中，会慢。 多级页表，对大地址寻址可以变成多级寻址。使得某一些不存在关系的数据不需要占用内存。 大地址空间问题：映射变得繁琐，让页表与物理地址空间相对应，而非逻辑地址空间大小相对应。 页寄存器：根据物理帧号对应页号。空间小，但双对应关系要更新。 可以使用关联存储，但关联存储硬件成本大。难以在单个时钟周期内完成。耗电。 可以使用哈希计算，可以硬件加速。查找时候可能碰撞，还需要类似TLB加速。 第五章 虚拟内存起因 更多的程序能跑在有限的内存内。软件增长速度比内存增长速度快。 有手动的覆盖技术，自动的交换技术和自动的虚拟存储技术。 覆盖技术 在比较小的内存中运行比较大的程序。将程序根据逻辑分类，划分为必要部分和可选部分。必要不放呢常驻内存，可选部分必要时候才装入内存，不存在调用关系的模块不必要同时装入内存，因此相互覆盖，共用分区。 交换技术 将暂时不能运行的程序送到外存，获得空闲内存。 需要考虑什么时候交换，只有不够且危险的时候交换。考虑交换区域的大小，能够够大。需要重定位，因此要动态地址映射。 虚存技术 目标：像覆盖技术一样，只把一部分放在内存中，从而运行比当前空闲内存还要大的程序。由操作系统自动完成。像交换技术一样，导出导入存储空间，获得更多空闲内存空间，但做得更好，只对进程部分进行交换。 程序需要有局部性。样例（二维数组遍历，缺页率问题）。 基本特征： 空间大，通过硬盘补充。 部分交换 不连续性 虚拟页式内存管理：将部分放入内存，如果不存在则发送缺页异常，从外存中调入内存。 需要在虚拟页表表项增加表项，如驻留位（在内存还是外存），保护位（能否访问，如只读），修改位（该页是否被写过，那么和在硬盘中内存数据不一样），访问位（用于置换算法）。 缺页中断：找空闲空间，如果没有则执行页面置换算法，选择页面，如果修改过则写入外存，没写过就抛弃，然后修改页表表项，之后将对应页写入到物理页面f中，修改驻留位，回到被中断的指令。 如何保存未被映射的页：能够简单识别在二级存储器中的页，或者用交换空间，用于存储未被映射的页面。 后备存储：虚拟地址空间页面可以被映射到一个文件某个位置，有代码段，动态链接段，其他段。 性能评估：访存时间×页表命中几率+缺页处理时间×缺页几率。 第六章 页面置换算法功能：选择页面被置换。 页面锁定：标志锁定位，不去管。 最优页面置换：基本思路，计算在它下一次访问之前，还需要等待多少时间。用模拟器跑一遍来换。 FIFO算法：驻留最长的页面淘汰。维护链表。性能较差，调出的可能是经常要访问的页面。会有belady现象 Belady现象：使用FIFO时候，分配的物理页面增多，缺页率反而提高。算法没有考虑动态特征。 LRU：最久未被使用。开销较大。 Clock页面置换算法：LRU的近似，对FIFO的改进。环形链表，从最老的页面开始访问，如果访问位是0则置换，如果访问位是1则置为0，并且继续。 二次机会法：脏页替换代价很大，需要修改clock算法，基于修改位和访问位，减少写回的次数。第一次把两个0的换回去，把01和10会变成00，第二次再换。 最不常用算法：LFU，算频率淘汰。 LRU算法符合栈算法特性，FIFO不符合，所以会有Belady算法。 全局页面置换算法：根据不同的页面算法扩展页容量。 工作集模型能用来表示局部性。 工作集：当前正在使用的逻辑页面的集合，参数为时间和窗口长度。 常驻集：进程实际驻留再内存中的页面集合。 我们希望这两个集合尽量交叉。当常驻集大小达到某个数目，分配过多物理页面缺页率也不会明显下降。 只要不属于工作集替换算法，就不保留，即使不缺页。 根据缺页率动态调整页缺失。 OS需要选择合适的常驻集，来防止抖动。 第七章 进程管理进程：一个具有一定独立功能的程序在一个数据集合上的一次动态执行的过程。 进程组成：代码，数据，PC计数器，寄存器，堆栈，系统资源如打开的文件。 程序是产生进程的基础，程序可以多次运行，进程是程序功能的体现，一个程序可对应多个进程，通过调用一个进程也可以包括多个程序。 进程有核心态和用户态区别。 进程可动态创建，结束，可以并发，独立性，制约性（资源抢占） 进程控制块：管理控制进程所用的信息集合。包含进程标识信息（本进程标识，产生者标识，用户标识），处理机状态信息保存区（保存进程运行现场，包括数据，地址，PC，状态，栈指针），进程控制信息（调度和状态信息，进程间通信信息，存储管理信息，进程所用资源，有关数据结构链接信息。） 控制块一般用链表来组织，可以动态删除动态创建。 进程状态：进程创建，进程运行，进程等待，进程唤醒，进程结束。 创建：系统初始化时候，用户请求创建新进程，正在运行的进程执行了创建进程的系统调用。 进程运行：让操作系统选择就绪进程，需要调度。 进程等待（阻塞）：系统服务无法马上完成，操作无法马上完成，需要的数据没有到达。进程只能自己阻塞自己，因为只有自己才知道合适需要等待事件发生。 进程唤醒：被阻塞进程资源可满足，等待事件到达，PCB被加入就绪队列。进程只能被OS或其他进程唤醒。 进程结束：正常，错误，致命错误（强制），被其他进程所杀（强制）。 基本状态：运行，就绪，等待。阻塞在事件发生能变到就绪，就绪在被调度能到运行，运行在时间调度后转到就绪，运行在缺少资源后阻塞。 进程不占内存空间 称为进程挂起 挂起:阻塞挂起状态 -等待事件出现 就绪挂起-只要进入内存，就能运行 阻塞到阻塞挂起:请求更多内存资源时候，会进行这种转换 就绪到就绪挂起:高优先级阻塞进程和低优先级就绪进程，会挂起低优先级就绪进程 运行到运行挂起:高优先级进程因为事件出现而进入就绪挂起，可能转到挂起状态 阻塞挂起可能转换为就绪挂起，但全在外存上，仅仅变了状态 就绪挂起到就绪:没有就绪进程或者挂起进程优先级高于就绪进程 阻塞挂起到阻塞:当一个进程释放足够内存，会把高优先级阻塞挂起进程放进内存 操作系统需要维护一组队列，来表示系统当中所有进程的当前状态 不同状态用不同队列管理 就绪队列 挂起队列 状态变化之后，从队列出来放进另一个队列 线程 独立运行的基本单位 并发执行并且共享地址空间 进程执行功能交给线程管理 一个线程崩溃，所有线程崩溃。 进程创建需要一些管理信息，进程可以直接重用 属于同一进程的线程有着一样的地址空间，切换线程很快，不需要切换页表。 同一进程共享资源，不需要通过内核通信。 用户线程:操作系统看不到的线程，由用户线程库来管理 内核线程:操作系统看得到，由操作系统管理 用户线程:在库中实现线程控制块，不依赖内核，由函数完成创建 终止 同步 调度 操作系统无法管理。有自定义算法，不需要用户态核心态转换 缺点:如果一个线程发起系统调用，整个进程都会等待。除非主动交出CPU使用权，否则其他线程无法运行。多线程时间片分得少。 内核线程:有操作系统完成内核创建，终止和实现，由内核维护进程和线程上下文，如windows。切换开销大。 轻量级进程: 内核支持的用户线程，一个进程可以有一个或者多个轻量级进程。 上下文切换:CPU状态，寄存器，栈指针等寄存器 fork之后返回俩返回值，exec加载程序取代当前进程，堆栈都会覆盖 fork开销高，exec后开销更高，因为fork需要拷贝内存信息，子进程可能关闭打开的文件和连接。 可以用vfork。也可以通过虚存管理COW，来实现。并不真实复制。 wait等待子进程结束，当子进程exit时候wait等待。当exit虽然无法在用户空间执行，父进程wait帮助释放子进程。 进程结束后调用exit，将结果作为参数，关闭所有文件，连接，释放内存，释放大部分操作系统结构，检查父进程是否存活(如果是，则进入僵尸状态，会保留结果。如果不是，则释放所有，进程死亡) 进程终止是最终的垃圾收集。 第八章 cpu调度选择进程，调度程序，什么时候调度。 调度条件:运行切换到等待，或者被终结 不可抢占:必须等待事件结束 可抢占:调度程序在中断被响应后执行，从运行切换到就绪，从等待切换到就绪，可以被换出。 执行模型：程序在CPU突发和IO中交替，CPU繁忙还是IO繁忙。CPU占用率波动。 调度算法：CPU占用率（CPU忙的时间比），吞吐量（单位时间完成的进程熟练），周转时间（一个进程从初始化到结束，包括等待时间的所有时间，等待时间（就绪队列中的总时间），响应时间（响应花费的总时间） 更快：高带宽，低延迟。 减少响应时间（输出尽快提供），减少平均响应时间波动（可预测性更重要），增加吞吐量（开销减少，系统资源高效利用），减少等待时间。 低延迟增加交互，高吞吐量保证效率。 FCFS先来先服务。简单，但时间波动较大，花费时间少的任务可能排在花费时间长的前面，IO和CPU之间可能重叠。 短任务优先：不可抢占（短任务到来之后不管，塞最前面），抢占（短任务来的时候调度）。 有最优平均等待时间，连续短任务可能会让长任务饥饿，短任务可用时候任何长任务CPU时间会增加平均等待时间。需要知道进程的执行时间，需要预知未来。 可以用公式预估进程执行时间。 最高相应比优先：考虑等待时间，防止无限期延迟。 轮询：让进程轮流占CPU，设置时间片。时间片设置困难，经验：维持上下文切换开销处于1%。 多级队列，不同队列用不同调度算法。前台轮询，后台FCFS之类的。 多级反馈队列，时间片随优先级别增加而增加，如果没有完成则降低优先级。IO密集型会很快执行，CPU密集型则优先级下降很快。 公平共享服务FFS：一些用户组比其他用户更重要，保证不重复的组无法垄断资源。 实时调度（面向实时系统），正确性依赖于时间和功能的OS。 强实时系统（必须完成），弱实时系统（尽量完成）。 多处理器调度：需要负载均衡。 优先级反转：环境强制高优先级 第九章 同步进程相对独立，则执行十确定的。不独立且不可重现，意味着bug可能间歇性发生。 临界区：访问共享资源的代码称为临界区。 互斥：没有多个资源访问临界区域。 死锁：都无法进行下去 饥饿：无限等待 进入临界区aquire锁，离开临界区release。 进入临界区禁用中断，离开临界区开启中断。但外部事件可能无法及时响应。临界区执行长短也无法确定。 基于软件：进入临界区 当硬件可以用原子操作，可以抽象硬件。 test and set：读取值，测试值是否为1，返回值且设置为1。 交换：交换两个内存里的值。 上述2个机器指令不允许被打断。 123456789//忙等待void acquire(){ while(test_and_set(value)){ spin(); }}void release(){ value = 0;} 无忙等待：spin时候加入队列，release时候取出队列。 第十章 信号量与管程信号量：p(): sem-1 除非sem&lt;0 v(): sem+1 如果sem&lt;=0则唤醒一个p。 信号量是整数，被保护（只能被p，v操作），p能阻塞，v不会。信号量是公平的。 有二进制信号量和整数信号量，给定一个可以实现另一个。 信号量可以实现同步，线程的执行需要另一个线程提供的结果，初始化为0，实现调度约束。 生产消费者模型：任何时间只能有一个线程操作缓冲区，缓冲区为空，消费者必须等待生产者。缓冲区满，生产者必须等待消费者。 每个约束都需要单独的信号量。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"title":"uCore lab 1","text":"本系列旨在完成uCore实验，通过实验了解操作系统的概念，从汇编，c语言编程的角度，以微观的视角了解操作系统的运行过程。本文为本系列第一篇，介绍机器启动到启动os的过程。 从机器启动到操作系统运行BIOS 启动计算机加电后先完成基本IO初始化和引导加载功能。系统软件初始化由BIOS与OS Bootloader完成。 BIOS是固化在计算机ROM上的软件，为上层软件提供最为底层的硬件控制与支持。CPU从0XFFFFFFF0开始执行，存放一条跳转指令，跳转到BIOS例行程序起始点，完成硬件自检和初始化后，选择启动设备读取第一扇区到内存的特殊位置0x7c00处，CPU控制权交给该地址，开始执行。 Bootloader启动过程Bootloader工作包括： 切换到保护模式，启用分段机制。 读取ELF执行文件的ucore操作系统到内存。 显示字符串信息。 把控制权交给操作系统。 保护模式与分段机制 当Intel 80386进入保护模式后才能充分发挥功能，提供更好的保护与更大的寻址空间。 实模式 当Bootloader接手工作后，PC处于实模式，可访问的物理内存空间不超过1MB，将内存看为分段的区域，代码和数据位于不同区域，此时指针指向的是实际的地址。可以通过修改A20地址线来完成转换。 保护模式 保护模式地址线才全部有效，可采用分段存储管理和分页存储管理，为存储管理保护提供了硬件支持。通过提供特权级和特权检查机制，实现资源共享又能保证安全。 在保护模式下有两个段表GDT和LDT可以有64TB逻辑空间，但实际空间还是只有4GB，ucore只用到了GDT。 分段存储管理机制 分段机制涉及4个关键内容：逻辑地址，段描述符，段描述符表，段选择子（段寄存器）。 分段地址转换：CPU将逻辑地址中段选择子作为段描述符号表的索引，找到段描述符，之后加上偏移值得到线性地址，后续可以将线性地址转换为物理地址。 段描述符内容如下： 段基地址：线性空间中段的起始地址，80386保护模式中任何一个段都可以从任何一个字节开始。 段界限：规定段的大小，80386保护模式下以20位表示，可以用字节为单位或者4K字节为单位。 段属性： 粒度位：即以字节为单位或4K字节为单位。 类型：代码段还是数据段。读写执行权限。段的扩展方向。 描述符特权级位：用于实现保护机制。 段存在位：如果非法则不能用来实现地址转换，产生异常。 已访问位：处理器访问该段时候自动设置。 全局描述符号表：保存多个段描述符的数组，但由于GDT不能有自己之内的描述定义，因此定义了特殊的段GDTR。 选择子：包含索引，表指示位（GDT还是LDT）和特权级。 保护模式下的特权级 保护模式下有四个，从0到3,主要保护内存，IO端口以及执行特殊机器指令的能力。对于ring 0之外运行这些指令会导致异常。 代码段寄存器的内容不能由mov等指令直接设置，只能被如JMP，INT，CALL指令间接设置。 代码段CPL字段的值同时等于当前的特权级别。 特权级比较：比较当前特权级与请求特权级的最大值，并与描述符特权级相比较。 地址空间 逻辑地址，物理地址，段描述符表，段描述符，段选择子。 逻辑地址-&gt;分段地址转换-&gt;线性地址-&gt;分页地址转换-&gt;物理地址。 硬盘访问概述 bootloader进入保护模式后下一步从硬盘加载并运行OS。IO操作通过CPU访问硬盘的IO地址寄存器完成。 访问硬盘流程： 等待硬盘准备好 发起读取扇区命令 等待硬盘准备好 扇区读到指定内存 ELF格式概述 ELF有三种主要类型，可执行文件，可重定位文件与共享目标文件（动态库）。 link address为链接器配置的内存地址，Load address为实际被加载到内存的位置，这俩不同会导致直接跳转位置错误，直接内存访问（只读数据或bss）错误，堆栈使用不受影响，但可能会覆盖程序数据段。动态链接库会存在不一样。 操作系统启动过程加载到内存后，os接管控制权，实验所完成的工作包括： 初始化终端 显示字符串 显示堆栈中多层函数调用关系 切换到保护模式，启用分段机制 初始化中断控制器，初始化时钟中断，实现中断 执行死循环 函数堆栈 函数调用可分为push指令入参，call指令，call指令暗含将下一跳指令地址压栈动作。函数体之前会有类似如下： 12pushl %ebpmovl %esp, %ebp 函数调用前会有如下数据顺序入栈：参数，返回地址，ebp寄存器。 中断和异常 有三种特殊中断产生是异步产生，产生时间不确定，与CPU无关，称为异步中断也叫外部中断，CPU执行期间检测到违法指令称为内部终端，也叫trap。 在保护模式下，收到中断（8259A）时候会暂停，跳转到相关例程中，处理完成后再跳回，需要中断描述符号表IDT负责找到关系，而IDT地址存在idtr寄存器中。 IDT是八字节描述符数组，中断号乘以8为IDT索引，LIDT和SIDT可以操作IDTR。 保护模式下最多有256个中断，0到31被异常使用，32到255用于自定义。 IDT gate description用于标识中断或trap，当用中断gate时候，会禁止中断，避免重复中断，使用trap gate时候会保持原样，不去禁止或打开。 CPU收到中断事件，打断当前程序或者任务执行，跳转到中断例程序流程如下： 执行完每一条指令后，都会确认在执行刚才指令的过程中中断控制器是否发送请求过来，有则会在相应的时钟脉冲到来的时候从总线读取请求对应的中断向量。 根据中断向量在IDT找到对应中断描述符，符号内有中断服务例程的段选择子。 根据段选择子在GDT里面找到对应段描述符，其中保存有段基址和属性信息，得到起始地址，跳转到该地址。 根据CPL和DPL看是否发生了特权级转换，如果转换则从任务描述符（TSS）中获得该程序的内核栈地址，包含内核态的ss和sp（ss：sp地址形式），将系统当前使用的栈换成内核栈，换掉ss，sp，将用户态ss，sp压入内核栈保存。 CPU保存寄存器值来保存现场。 将中断服务例程的段描述符的第一条指令加载到cs和eip寄存器，开始执行例程。 在中断服务例程处理完成后需要通过iret指令恢复被打断的程序的执行执行如下： 从内核栈弹出现场信息，即eflags，cs，eip等。 如果存在特权级转换，则弹出ss，sp，切换回用户态栈。 如果此次处理带错误码的异常，cpu恢复现场时候不会弹出错误码，需要软件编程弹出错误码。 中断处理的特权级转换通过门描述符来确定，产生中断后一定是向相等或更高特权级转换，结果的CPL必须等于目的代码段的DPL。如果中断由用户态指令触发，则目标DPL必须具有比CPL相同或者更低的特权，防止随意中断。 练习1：makefile编写 理解make执行文件过程 了解主引导扇区makefile基本原则 1234targets : prerequisites command#目标（可执行文件或object file）：依赖文件（一个或者多个）# 命令（编译命令） 示例如下 12test:test.c gcc -o test test.c 四种赋值： 12345678910111213x:=foo #简单赋值x=fooy=$(x)bx=new#递归赋值，会改变用到此值的所有值x?=a#条件赋值，未定义则赋值x+=b#追加赋值，会增加一个空格后加上去 一些基本函数 1234$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;,...)#将参数填入表达式$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)#条件语句 一些常见的自动变量 1234test:test.o test1.o test2.o gcc -o $@ $^# $@为目标文件名，这里为test# $^为依赖的文件，这里为两个o 实战分析 分析lab1中的makefile，可以分为一下几个部分： 1234$(UCOREIMG): $(kernel) $(bootblock) $(V)dd if=/dev/zero of=$@ count=10000 $(V)dd if=$(bootblock) of=$@ conv=notrunc $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc 上述为ucore.img部分，即依赖kernel和bootlock部分。命令中，dd用于读取，转换，输出文件，if和of即为输入文件和输出文件，count代表拷贝块大小，seek代表跳过blocks个块再开始复制，notrunc即不截断输出文件。该行目的为生成10000块的文件，每块默认512字节，用0填充，bootblock写入第一块，kernel写入第二块。 再来观察kernel： 123456789101112KOBJS = $(call read_packet,kernel libs)kernel = $(call totarget,kernel)$(kernel): tools/kernel.ld$(kernel): $(KOBJS) @echo + ld $@ $(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS) @$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel) @$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' &gt; $(call symfile,kernel)$(call create_target,kernel) kernel.ld不必多说，关注下面的KOBJS，即将obj文件都链接起来。obj文件来自于read_packet，而packet文件来自如下： 123$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS))add_files_cc = $(call add_files,$(1),$(CC),$(CFLAGS) $(3),$(2),$(4)) 这其中add_files_cc传入CC（编译器，clang还是gcc），CFLAGS编译参数。KCFLAGS即include的files，KSRCDIR即要编译的文件目录。实际执行命令如下： 12345gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 \\ -gstabs -nostdinc -fno-stack-protector \\ -Ilibs/ -Ikern/debug/ -Ikern/driver/ \\ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c \\ -o obj/kern/init/init.o 回到kernel，下面一行为ld，即链接器，链接所有obj文件。 之后反汇编到asm文件，再处理一下得到sym文件。 回到img，除了kernel，下一个为bootblock，如下所示： 12345678910111213bootfiles = $(call listf_cc,boot)$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))bootblock = $(call totarget,bootblock)$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign) @echo + ld $@ $(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock) @$(OBJDUMP) -S $(call objfile,bootblock) &gt; $(call asmfile,bootblock) @$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock) @$(call totarget,sign) $(call outfile,bootblock) $(bootblock)$(call create_target,bootblock) 简要分析，首先bootblock需要boot文件夹下的files编译成obj，然后ld链接，然后需要反汇编到asm文件便于查看，再objcopy去掉符号和重定位，生成到.out文件中，最后使用sign工具处理.out，得到bootblock。 简要来分析编译时候关键参数： 1234567-ggdb 生成调试信息-m32 生成32位环境代码-gstabs 生成stabs格式调试信息，从而可以显示出便于开发者阅读的函数调用-nostdinc 不使用标准库，因为是内核-fno-stack-protector 不生成检测缓冲区溢出的代码，内核用不到-Os 为减小代码大小而优化-I&lt;dir&gt; 添加搜索头文件路径 练习1.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么? 由文档我们可以知道，sign.c是用来生成一个符合规范的硬盘主引导扇区的。观察sign.c代码可以看出，它接收os参数，检测参数对应文件长度，读入512的缓冲区，并且将最后两个字节，即buf[510] = 0x55;以及buf[511] = 0xAA;，从而得到正确的硬盘主引导扇区。 2：使用qemu执行并调试lab1中的软件qemu基础 安装不必多言，可以直接sudo apt-get： 123sudo apt-get install qemu-system# 软链接一下，使用命令sudo ln –s /usr/local/bin/qemu-system-i386 /usr/local/bin/qemu 由于主要是i386平台，这里软链接一下方便使用。 qemu格式如下： 1qemu [options] [disk_image] 下面是一些常见参数： 123456789101112131415161718192021222324-hda xxfile -hdb xxfile -hdc xxfile# 使用file作为硬盘0,1,2,3镜像-boot [a|c|d]# 从软盘a，光盘c，硬盘d启动 默认硬盘启动-snapshot# 写入临时文件而不写回磁盘镜像-m xxx# 设置虚拟内存xxx M字节-s# 等待gdb连接到端口1234-p port# 改变连接端口到port-S# 启动时候不启动CPU，需要在monitor中输入c （continue）才能继续模拟工作-d# 输出日志到qemu.log文件# 可以重定向到dev设备，dev包括stdio，tty，file等-serial dev# 重定向虚拟串口到dev中-parallel dev# 重定向虚拟并口到主机设备dev中-monitor dev# 重定向monitor到dev中 在lab 1中，我们可以这样启动设备 1qemu -S -s -hda ucore.img -monitor stdio # 用于与gdb配合进行源码调试 完成后用gdb打开kernel文件，执行如下连接到端口1234： 1(gdb) target remote:1234 也有更简便的方法来，就是将它配置进文件，在makefile里面启动时候加载gdb配置文件，开启qemu进行debug。简单来说可以在tools/gdbinit修改，并且执行make debug进行调试。 1 从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。 更改gdbinit文件如下： 12set architecture i8086target remote :1234 构建运行系统并调试，进入gdb，执行以下指令： 10x0000fff0 in ?? () 需要注意的是，我们现在处于实模式，直接看pc是看不出指令的，下一条指令地址位于CS：ip算出来的。于是可以观察cs寄存器，ip寄存器，如下： 1234(gdb) x $cs0xf000: 0x00000000(gdb) x $eip0xfff0: 0x00000000 可以看到cs在0xf000，eip在0xfff0，通过计算16*cs+ip可以得到地址0xffff0，观察0xffff0，得到如下： 123(gdb) x /2i 0xffff0 0xffff0: ljmp $0x3630,$0xf000e05b 0xffff7: das 最开始的指令是一个长跳转ljmp，跳转到e05b。对于BIOS代码，qemu默认是以32位模式解释代码的，这导致地址不正确，反汇编也不正确。参考这个链接我们可以得到解决办法，在gdb配置中加入以下指令： 1set tdesc filename target.xml target.xmlet.xml可以在上面链接中获取到，根据此我们可以以16位方法正确反汇编代码。 **2 在初始化位置0x7c00设置实地址断点,测试断点正常 ** 直接在gdb中设置断点就行，格式如下，可以写进gdb配置也可以直接在命令行输入。 1b *0x7c00 **3 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较 ** 在makefile里面把debug命令改成如下： 1234debug: $(UCOREIMG) $(V)$(QEMU) -S -s -parallel stdio -hda $&lt; -serial null -d in_asm -D q.log&amp; $(V)sleep 2 $(V)$(TERMINAL) -e \"gdb -q -tui -x tools/gdbinit\" 其中in_asm代表以target asm形式表示。将执行了的汇编码保存到q.log里面，进行对比。 1234567891011IN: 0x00007c00: fa cli ----------------IN: 0x00007c00: fa cli 0x00007c01: fc cld 0x00007c02: 31 c0 xorw %ax, %ax0x00007c04: 8e d8 movw %ax, %ds0x00007c06: 8e c0 movw %ax, %es0x00007c08: 8e d0 movw %ax, %ss 与之前的asm文件一致。 4 自己找断点测试 方法同上，不过多赘述。 3：分析bootloader进入保护模式的过程阅读bootasm.S源码解决以下问题 为何开启A20，以及如何开启A20 如何初始化GDT表 如何使能和进入保护模式 观察源码，首先从第一个扇区读取内容到地址0x7c00处，此时$cs=0x0并且$ip=0x7c00，得到cs:ip。开始进入汇编，开始代码如下： 12345678910start:.code16 # Assemble for 16-bit mode cli # Disable interrupts cld # String operations increment # Set up the important data segment registers (DS, ES, SS). xorw %ax, %ax # Segment number zero movw %ax, %ds # -&gt; Data Segment movw %ax, %es # -&gt; Extra Segment movw %ax, %ss # -&gt; Stack Segment cli指令关闭中断，cld指令使得方向标志位复位，从而按递增方向增长。 xor操作用于清零，mov操作用于将数据段，代码段，栈段寄存器也清零。初始化完成之后，开始打开A20线。 123456789101112131415seta20.1: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.1 movb $0xd1, %al # 0xd1 -&gt; port 0x64 outb %al, $0x64 # 0xd1 means: write data to 8042's P2 portseta20.2: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.2 movb $0xdf, %al # 0xdf -&gt; port 0x60 outb %al, $0x60 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1 使用8042控制器来控制A20 gate。操作简单来说如下： 读0x60端口，为读output buffer 写0x60端口，为写input buffer 读0x64端口，为读status register 操作control register：先向0x64写一个命令，根据命令从60读control register命令或者写60一个control register命令。 实际操作起来流程为：读0x64观察8042是否忙，忙则继续读直到不忙，然后向0x64写入0xd1,代表即将写入8042的输出端口。然后再次等待，等待完成后向0x60写入0xdf，代表打开A20地址线。 对于全局描述符表GDT而言，下面使用lgdt指令直接加载即可： 1lgdt gdtdesc 然后将控制寄存器cr0的PE位置置为1,即可开启保护模式： 123movl %cr0, %eaxorl $CR0_PE_ON, %eaxmovl %eax, %cr0 然后跳转到32位代码区： 1ljmp $PROT_MODE_CSEG, $protcseg 设置寄存器，建立堆栈，进入boot主方法： 1234567891011movw $PROT_MODE_DSEG, %ax # Our data segment selectormovw %ax, %ds # -&gt; DS: Data Segmentmovw %ax, %es # -&gt; ES: Extra Segmentmovw %ax, %fs # -&gt; FSmovw %ax, %gs # -&gt; GSmovw %ax, %ss # -&gt; SS: Stack Segment#Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)movl $0x0, %ebpmovl $start, %espcall bootmain 4：分析bootloader加载ELF格式的OS的过程TODO 5：实现函数调用堆栈跟踪函数 （需要编程）TODO 6：完善中断初始化和处理 （需要编程）TODO document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/ucore-lab-1/"},{"title":"板子","text":"板子 MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); 目录 1. 数学 1.1. gcd 1.2. exgcd 1.3. 求解线性同余方程 1.4. 欧拉定理(扩展， 不适用于矩阵) 1.5. 矩阵 1.6. 广义斐波那契数列循环节 1.7. 整除分块 1.8. 莫比乌斯反演 1.9. Lucas 1.10. 逆元 1.11. BM算法 1.12. 二次剩余 1.13. k次幂和 1.14. 杜教筛 2. 数据结构 2.1. kd树 3. dp 3.1. 区间dp 3.2. 状压dp 3.3. 数位dp 4. 计算几何 4.1. 红书 4.2. 三维向量旋转 5. 博弈 6. 图论 7. 黑科技 7.1. 高精 8. tips 该板子补充红书上没有或者替换成自己熟悉的板子 1. 数学1.1. gcd $gcd(a, b) = gcd(b, a % b)$ 等式(1) 12345678910ll gcd(ll a,ll b){ return b?gcd(b,a%b):a;}或者inline ll gcd(ll a,ll b){ if(!b) return a; while(b^=a^=b^=a%=b);//先做一次取模，然后交换两个元素 return a;} 1.2. exgcd 求解 $ax + by = c$的x的最小正整数解 首先求解$ax + by = gcd(a, b)$(2) 由等式(1)可得 $bx1 + a % b * y1 = gcd(b, a % b) = ay1 + b * (-\\lfloor \\frac{a}{b} \\rfloor +x1) * y1$ (3) 联立等式(2), (3)得到 $x=y_1, y=-\\lfloor \\frac{a}{b} \\rfloor +x1$ 将所得式子不断递归至$b=0$, 返回最后结果 1234567891011ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y){ if(b == 0) { x = 1, y = 0; return a; } ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d;} 设$d=gcd(a, b)$, 等式两边则同时乘上$\\frac{c}{d}$则可以获得一组特解 $x1=x0 * \\frac{c}{d}，y1=y0 * \\frac{c}{d}$ 每次将x0减少x，y0则相应增加$\\frac{ax}{b}$, 若需要保证y依然为正整数，则 $\\frac{ax}{b}=\\frac{a}{d}, x=\\frac{b}{d}$ 保证$0 &lt; x1 &lt; x$时，即可得到答案。 若$x &lt; 0$，则将x取绝对值 若$x0 &lt; 0$，则将x0加上x即可。 123456789d = exgcd(a, b, x, y);if(c% d== 0){ x *= c / d; t = b / d; t = abs(t); x = (x % t + t) % t; printf(\"%d\\n\", x);} 1.3. 求解线性同余方程 给出n个同余方程$N \\equiv a_1\\mod p_1, N \\equiv a_n\\mod p_n$ 求x的最小正整数解, $p_i$不互质 显然可以化为 $k1 * p1+a1=k2 * p2+a2-&gt;k1 * p1+(-k2 * p2)=a2-a1$ 设$a=p1, b=p2, x=k1, y=(-k2), c=a2-a1$方程可写为$ax+by=c$ 则问题转变为上一个题目 那么将x化为原方程的最小正整数解，$x=(x * (\\frac{c}{d})%(\\frac{b}{d})+(\\frac{b}{d}))%(\\frac{b}{d})$ 所以$N=a * (x+z * (\\frac{b}{d}))+r1-&gt;N=(\\frac{ab}{d}) * z+(a * x+r1)$ 现在只有z是未知数，所以变成$N\\equiv (a * x+r1) mod (\\frac{ab}{d}))$的问题 继续合并同余方程即可 12345678910111213141516171819202122232425ll M[55], A[55];ll China(int r){ ll dm, i, a, b, x, y, d; ll c, c1, c2; a=M[0]; c1=A[0]; for(i = 1; i &lt; r; i++){ b = M[i]; c2 = A[i]; exgcd(a, b ,d, x, y); c = c2 - c1; if(c % d) return -1;//c一定是d的倍数，如果不是，则肯定无解 dm = b / d; x = ((x * (c / d)) % dm + dm) % dm;//保证x为最小正数//c/dm是余数，系数扩大 c1 = a * x + c1; a = a * dm; } if(c1 == 0){//余数为0，说明M[]是等比数列。且余数都为0 c1 = 1; for(i = 0; i &lt; r; i++) c1 = c1 * M[i] / gcd(c1, M[i]); } return c1;} 中国剩余定理 12345678910//n个方程：x=a[i](mod m[i]) (0&lt;=i&lt;n)LL china(int n, LL *a, LL *m){ LL M = 1, ret = 0; for(int i = 0; i &lt; n; i ++) M *= m[i]; for(int i = 0; i &lt; n; i ++){ LL w = M / m[i]; ret = (ret + w * inv(w, m[i]) * a[i]) % M; } return (ret + M) % M;} 进阶: 给出k个模方程组：x mod ai = ri。求x的最小正值。如果不存在这样的x，那么输出-1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;typedef pair&lt;LL, LL&gt; PLL;LL a[100000], b[100000], m[100000];LL gcd(LL a, LL b){ return b ? gcd(b, a%b) : a;}void ex_gcd(LL a, LL b, LL &amp;x, LL &amp;y, LL &amp;d){ if (!b) {d = a, x = 1, y = 0;} else{ ex_gcd(b, a % b, y, x, d); y -= x * (a / b); }}LL inv(LL t, LL p){//如果不存在，返回-1 LL d, x, y; ex_gcd(t, p, x, y, d); return d == 1 ? (x % p + p) % p : -1;}PLL linear(LL A[], LL B[], LL M[], int n) {//求解A[i]x = B[i] (mod M[i]),总共n个线性方程组 LL x = 0, m = 1; for(int i = 0; i &lt; n; i ++) { LL a = A[i] * m, b = B[i] - A[i]*x, d = gcd(M[i], a); if(b % d != 0) return PLL(0, -1);//答案，不存在，返回-1 LL t = b/d * inv(a/d, M[i]/d)%(M[i]/d); x = x + m*t; m *= M[i]/d; } x = (x % m + m ) % m; return PLL(x, m);//返回的x就是答案，m是最后的lcm值}int main(){ int n; while(scanf(\"%d\", &amp;n) != EOF){ for(int i = 0; i &lt; n; i ++){ a[i] = 1; scanf(\"%d%d\", &amp;m[i], &amp;b[i]); } PLL ans = linear(a, b, m, n); if(ans.second == -1) printf(\"-1\\n\"); else printf(\"%I64d\\n\", ans.first); }} 1.4. 欧拉定理(扩展， 不适用于矩阵) $a^{b} \\equiv a^{b \\mod \\varphi(p)} \\mod p$ (a与p互质) $a^{b} \\equiv a^{b \\mod \\varphi(p) + \\varphi(p)} \\mod p$ (a与p不互质) 1234567891011121314151617181920212223242526272829303132ll ph(ll x){ ll res = x, a = x; for(ll i = 2; i * i &lt;= x; i++){ if(a % i == 0){ res = res / i * (i - 1); while(a % i == 0) a /= i; } } if(a &gt; 1) res = res / a * (a - 1); return res;}ll quick_pow(ll a, ll b, ll mod){ ll ans = 1; while(b) { if(b &amp; 1) ans = (ans * a) % mod; a = (a * a) % mod; b &gt;&gt;= 1; } return ans;}ll ph_pow(ll a, ll b, ll mod){ if(gcd(b, mod) == 1){ return quick_pow(a, b % (mod - 1), mod); } else { ll phi = ph(mod); return quick_pow(a, b % (phi) + phi, mod); }} 1.5. 矩阵 斐波那契数列求解 $F[n] = F[n-1] + F[n-2]$ 则可以看作矩阵$$ \\left[\\begin{matrix}F[n] \\ F[n-1]\\end{matrix} \\right] = \\left[\\begin{matrix}1&amp;1 \\ 1&amp;0\\end{matrix} \\right] * \\left[\\begin{matrix}F[n-1] \\ F[n-2]\\end{matrix} \\right]$$ 设$$A = \\left[\\begin{matrix}1&amp;1 \\ 1&amp;0\\end{matrix} \\right] B = \\left[\\begin{matrix}1 \\ 1\\end{matrix} \\right]$$, 则计算F[n]就是计算$A^{n-1}*B$, 再取出矩阵第一项即可。 上述相对应的操作在矩阵上均可运用。 1234567891011121314151617181920212223242526272829303132333435363738394041struct Matrix{ int n, m; ll a[maxn][maxn]; void clear() { n = m = 0; memset(a, 0, sizeof(a)); } void init (int x) { n = m = maxn; memset(a, 0, sizeof(a)); if(x) for(int i = 0; i &lt; 3; i++) a[i][i] = 1; } Matrix operator *(const Matrix &amp;b) const { Matrix tmp; tmp.clear(); tmp.n = n; tmp.m = b.m; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; b.m; j++) for(int k = 0; k &lt; m; k++) (tmp.a[i][j] += a[i][k] * b.a[k][j] % mod) %= mod; return tmp; } Matrix qpow(ll b) { Matrix ans, p = *this; ans.n = p.n; ans.init(1); while (b){ if (b &amp; 1) ans = ans * p; p = p * p; b &gt;&gt;= 1; } return ans; }}; 1.6. 广义斐波那契数列循环节123456789101112131415161718192021222324252627282930313233typedef long long ll;typedef __int128 i16;const int N = 1e5 + 7;int pr[N], pn;bitset&lt;N&gt; np;void init() { for(int i = 2; i &lt; N; i++) { if(!np[i]) pr[pn++] = i; for(int j = 0; j &lt; pn &amp;&amp; i * pr[j] &lt; N; j++) { np[i * pr[j]] = 1; if(i % pr[j] == 0) break; } }}ll getpp(int p) { ll ret = 1; for(int i = 0; i &lt; pn &amp;&amp; pr[i] * pr[i] &lt;= p; i++) { if(p % pr[i] == 0) { ret *= (pr[i] - 1ll) * (pr[i] + 1); p /= pr[i]; while(p % pr[i] == 0) p /= pr[i], ret *= pr[i]; } } if(p != 1) ret *= (p - 1ll) * (p + 1); return ret;}//使用方式scanf(\"%s%d\", s, &amp;mod);int len = strlen(s);ll ord = getpp(mod), r = 0;//ord为循环节长度for(int i = 0; i &lt; len; i++) { r = ((i16)r * 10 + s[i] - '0') % ord;//简化r的大小} 1.7. 整除分块正常整除分块为 $ans = (ans + ((n / l) * (r – l + 1) mod m) mod m$ 求$\\sum_{i=1}^n \\lfloor n/i\\rfloor * i^2 mod 1e9+7$ 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;typedef long long LL;const LL mod = 1e9 + 7;const LL inv = 166666668;const LL inv2 = 500000004;LL f(LL x){ return ((((x * (x + 1)) % mod) * (2 * x + 1) % mod) % mod) * inv % mod;}LL call(LL n, LL m){ LL ans = 0, ans1 = 0, t1 = ((((n * n) % mod) * (n + 1)) % mod) * inv2 % mod, t2 = ((((m * m) % mod) * (m + 1)) % mod) * inv2 % mod; for(LL l = 1, r; l &lt;= n; l = r + 1){ r = n / (n / l); LL tmp = (f(r) - f(l - 1) + mod) % mod; ans = (ans + ((n / l) * tmp) % mod) % mod; } ans = (t1 + mod - ans) % mod; for(LL l = 1, r; l &lt;= m; l = r + 1){ r = m / (m / l); LL tmp = (f(r) - f(l - 1) + mod) % mod; ans1 = (ans1 + ((m / l) * tmp) % mod) % mod; } ans1 = (t2 + mod - ans1) % mod; return (ans * ans1) % mod;}int main(){ LL n, m; while(~scanf(\"%lld %lld\", &amp;n, &amp;m)){ printf(\"%lld\\n\", call(n, m)); } return 0;} 1.8. 莫比乌斯反演 这里的ans后面少了mu函数，代码是对的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const long long MAXN=1e6+5;//线性筛法求莫比乌斯函数bool check[MAXN+10];long long prime[MAXN+10];int mu[MAXN+10];void Moblus(){ memset(check,false,sizeof(check)); mu[1] = 1; long long tot = 0; for(long long i = 2; i &lt;= MAXN; i++) { if( !check[i] ){ prime[tot++] = i; mu[i] = -1; } for(long long j = 0; j &lt; tot; j++) { if(i * prime[j] &gt; MAXN) break; check[i * prime[j]] = true; if( i % prime[j] == 0){ mu[i * prime[j]] = 0; break; }else{ mu[i * prime[j]] = -mu[i]; } } }}int main(){ Moblus(); int t; scanf(\"%d\",&amp;t); while(t--) { long long n; scanf(\"%lld\",&amp;n); long long ans=3; for(long long i=1;i&lt;=n;i++) ans+=mu[i]*(n/i)*(n/i)*(n/i+3); printf(\"%lld\\n\",ans); }} 1.9. Lucas1234567891011121314151617181920212223242526272829303132333435363738//Lucas定理实现C(n,m)%p的代码：p为素数LL exp_mod(LL a, LL b, LL p){ //快速幂取模 LL res = 1; while(b != 0) { if(b&amp;1) res = (res * a) % p; a = (a*a) % p; b &gt;&gt;= 1; } return res;}LL Comb(LL a, LL b, LL p){ //求组合数C(a,b)%p if(a &lt; b) return 0; if(a == b) return 1; if(b &gt; a - b) b = a - b; LL ans = 1, ca = 1, cb = 1; for(LL i = 0; i &lt; b; ++i) { ca = (ca * (a - i))%p; cb = (cb * (b - i))%p; } ans = (ca*exp_mod(cb, p - 2, p)) % p; return ans;}LL Lucas(LL n,LL m,LL p){ //Lucas定理求C(n,m)%p LL ans = 1; while(n&amp;&amp;m&amp;&amp;ans) { ans = (ans*Comb(n%p, m%p, p)) % p; n /= p; m /= p; } return ans;} 组合数取模 123456789typedef long long LL;const LL maxn(1000005), mod(1e9 + 7);LL Jc[maxn];void calJc() //求maxn以内的数的阶乘{ Jc[0] = Jc[1] = 1; for(LL i = 2; i &lt; maxn; i++) Jc[i] = Jc[i - 1] * i % mod;} 1.10. 逆元 费马小定理求逆元 12345678910111213141516171819202122LL pow(LL a, LL n, LL p) //快速幂 a^n % p{ LL ans = 1; while(n) { if(n &amp; 1) ans = ans * a % p; a = a * a % p; n &gt;&gt;= 1; } return ans;}LL niYuan(LL a, LL b) //费马小定理求逆元{ return pow(a, b - 2, b);}LL C(LL a, LL b) //计算C(a, b){ return Jc[a] * niYuan(Jc[b], mod) % mod * niYuan(Jc[a - b], mod) % mod;} 拓展欧几里得算法求逆元 123456789101112131415void exgcd(LL a, LL b, LL &amp;x, LL &amp;y) //拓展欧几里得算法{ if(!b) x = 1, y = 0; else { exgcd(b, a % b, y, x); y -= x * (a / b); }}LL niYuan(LL a, LL b) //求a对b取模的逆元{ LL x, y; exgcd(a, b, x, y); return (x + b) % b;} 线性求逆元 1234567891011121314#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define maxn 3000006#define LL long longusing namespace std;int n,p,inv[maxn];int main(){ scanf(\"%d%d\",&amp;n,&amp;p); inv[1]=1; for(int i=2;i&lt;=n;i++)inv[i]=(p-(LL)p/i*inv[p%i]%p)%p; for(int i=1;i&lt;=n;i++)printf(\"%d\\n\",inv[i]); return 0;} 1.11. BM算法 给出前k项，即可求出第n项，只能用于符合递推方程形式的方程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cassert&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%mod;a=a*a%mod;}return res;}// headint _;ll n;namespace linear_seq { const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt; Md; void mul(ll *a,ll *b,int k) { rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; } int solve(ll n,VI a,VI b) { // a 系数 b 初值 b[n+1]=a[0]*b[n]+... // printf(\"%d\\n\",SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) { mul(res,res,k); if ((n&gt;&gt;p)&amp;1) { for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; } } rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; } VI BM(VI s) { VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) { ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) { VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; } else { ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; } } return C; } int gao(VI a,ll n) { VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); }};int main() { for (scanf(\"%d\",&amp;_);_;_--) { scanf(\"%lld\",&amp;n); vector&lt;int&gt;a; a.push_back(1); a.push_back(3); a.push_back(5); a.push_back(7); printf(\"%d\\n\",linear_seq::gao(a,n-1)); }} 1.12. 二次剩余123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define re register#define gc getchar#define pc putchar#define puts put_s#define cs constnamespace IO{ namespace READONLY{ cs int Rlen=1&lt;&lt;18|1; char buf[Rlen],*p1,*p2; char obuf[Rlen],*p3=obuf; char ch[23]; } inline char get_char(){ using namespace READONLY; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,Rlen,stdin),p1==p2)?EOF:*p1++; } inline void put_char(cs char &amp;c){ using namespace READONLY; *p3++=c; if(p3==obuf+Rlen)fwrite(obuf,1,Rlen,stdout),p3=obuf; } inline void put_s(cs char *s){ for(;*s;++s)pc(*s); pc('\\n'); } inline void FLUSH(){ using namespace READONLY; fwrite(obuf,1,p3-obuf,stdout); p3=obuf; } inline ll getint(){ re ll num; re char c; while(!isdigit(c=gc()));num=c^48; while(isdigit(c=gc()))num=(num+(num&lt;&lt;2)&lt;&lt;1)+(c^48); return num; } inline void outint(ll a){ using namespace READONLY; if(a==0)pc('0'); if(a&lt;0)pc('-'),a=-a; while(a)ch[++ch[0]]=a-a/10*10,a/=10; while(ch[0])pc(ch[ch[0]--]^48); }}using namespace IO;namespace Linear_sieves{ cs int P=300005; int prime[P],pcnt; bool mark[P]; inline void init(int len=P-5){ mark[1]=true; for(int re i=2;i&lt;=len;++i){ if(!mark[i])prime[++pcnt]=i; for(int re j=1;j&lt;=pcnt&amp;&amp;i*prime[j]&lt;=len;++j){ mark[i*prime[j]]=true; if(i%prime[j]==0)break; } } }}namespace Find_root{ #define complex COMPLEX using namespace Linear_sieves; inline ll mul(cs ll &amp;a,cs ll &amp;b,cs ll &amp;mod){ return (a*b-(ll)((long double)a/mod*b)*mod+mod)%mod; } inline ll quickpow(ll a,ll b,cs ll &amp;mod,ll res=1){ for(;b;b&gt;&gt;=1,a=mul(a,a,mod))if(b&amp;1)res=mul(res,a,mod); return res; } inline ll ex_gcd(cs ll &amp;a,cs ll &amp;b,ll &amp;x,ll &amp;y){ if(!b){ y=0; x=1; return a; } ll t=ex_gcd(b,a-a/b*b,y,x); y-=(a/b)*x; return t; } inline ll inv(cs ll a,cs ll mod){ ll x,y; ll t=ex_gcd(a,mod,x,y); return (x%mod+mod)%mod; } ll W,Mod; class complex{ public: ll x,y; complex(cs ll &amp;_x=0,cs ll &amp;_y=0):x(_x),y(_y){} inline friend complex operator*(cs complex &amp;a,cs complex &amp;b){ return complex( (mul(a.x,b.x,Mod)+mul(mul(a.y,b.y,Mod),W,Mod))%Mod, (mul(a.x,b.y,Mod)+mul(a.y,b.x,Mod))%Mod); } }; complex quickpow(complex a,ll b){ complex res(1,0); for(;b;b&gt;&gt;=1,a=a*a)if(b&amp;1)res=res*a; return res; } inline bool isprime(ll x){ if(x&lt;=P-5)return !mark[x]; if(x%2==0||x%3==0||x%5==0||x%7==0||x%31==0||x%24251==0)return false; re ll t=x-1,s; t&gt;&gt;=(s=__builtin_ctzll(t)); for(int re i=1;i&lt;=5;++i){ re ll p=prime[rand()%pcnt+1]; re ll num=quickpow(p,t,x),pre=num; for(int re j=0;j&lt;s;++j){ num=mul(num,num,x); if(num==1&amp;&amp;pre!=x-1&amp;&amp;pre!=1)return false; pre=num; if(num==1)break; } if(num^1)return false; } return true; } inline ll Pollard_rho(ll x){ if(x%2==0)return 2; if(x%3==0)return 3; if(x%5==0)return 5; if(x%7==0)return 7; if(x%31==0)return 31; if(x%24251==0)return 24251; re ll n=0,m=0,t=1,q=1,c=rand()%(x-2)+2; for(int re k=2;;k&lt;&lt;=1,m=n,q=1){ for(int re i=1;i&lt;=k;++i){ n=(mul(n,n,x)+c)%x; q=mul(q,abs(n-m),x); } if((t=__gcd(q,x))&gt;1)return t; } } ll fact[60],cntf; inline void sieves(ll x){ if(x==1)return ; if(isprime(x)){fact[++cntf]=x;return;} re ll p=x; while(p==x)p=Pollard_rho(p); sieves(p); while(x%p==0)x/=p; sieves(x); } inline ll solve_2k(ll a,ll k){ if(a%(1&lt;&lt;k)==0)return 0; a%=(1&lt;&lt;k); re ll t=0,res=1; a&gt;&gt;=(t=__builtin_ctzll(a)); if((a&amp;7)^1)return -1; if(t&amp;1)return -1; k-=t; for(int re i=4;i&lt;=k;++i){ res=(res+(a%(1&lt;&lt;i)-res*res)/2)%(1&lt;&lt;k); } res%=1&lt;&lt;k; if(res&lt;0)res+=1&lt;&lt;k; return res&lt;&lt;(t&gt;&gt;1); } inline ll solve_p(ll a,ll p){ a%=p; if(quickpow(a,(p-1)&gt;&gt;1,p)==p-1)return -1; re ll b; Mod=p; while(true){ b=rand()%p; W=(mul(b,b,p)-a+p)%p; if(quickpow(W,(p-1)&gt;&gt;1,p)==p-1)break; } re ll ans=quickpow(complex(b,1),(p+1)&gt;&gt;1).x; return min(ans,p-ans); } inline ll solve_pk(ll a,ll k,ll p,ll mod){ if(a%mod==0)return 0; re ll t=0,hmod=1; while(a%p==0)a/=p,++t,hmod*=(t&amp;1)?p:1; if(t&amp;1)return -1; k-=t; mod/=hmod*hmod; re ll res=solve_p(a,p); if(res==-1)return -1; complex tmp(res,1); W=a; Mod=mod; tmp=quickpow(tmp,k); res=mul(tmp.x,inv(tmp.y,Mod),Mod); return res*hmod; } ll remain[20],mod[20],p; inline ll CRT(){ re ll ans=0; for(int re i=1;i&lt;=cntf;++i){ ans=(ans+mul(mul(p/mod[i],inv(p/mod[i],mod[i]),p),remain[i],p))%p; } return ans; } inline ll solve(ll a,ll pmod){ a%=pmod; cntf=0; p=pmod; sieves(pmod); if(cntf&gt;1)sort(fact+1,fact+cntf+1); if(cntf&gt;1)cntf=unique(fact+1,fact+cntf+1)-fact-1; for(int re i=1;i&lt;=cntf;++i){ re ll now=0,rmod=1; while(pmod%fact[i]==0)pmod/=fact[i],++now,rmod*=fact[i]; mod[i]=rmod; if(fact[i]==2)remain[i]=solve_2k(a,now); else remain[i]=solve_pk(a,now,fact[i],rmod); if(remain[i]==-1)return -1; } return CRT(); } #undef complex}int T;signed main(){ srand(time(0)); Linear_sieves::init(); T=getint(); const ll p = 1e9+7; while(T--){ re ll b=getint(),c=getint(),ans; ans=Find_root::solve(b * b - 4 * c,4*p); if(ans == -1){ b += p; ans=Find_root::solve(b * b - 4 * c,4*p); if(ans == -1){ printf(\"-1 -1\\n\"); continue; } } ll x = ans + b; x &gt;&gt;= 1; x %= p; ll y = (b - x + p) % p; if(x &gt; y){ swap(x, y); } printf(\"%lld %lld\\n\", x, y); } FLUSH(); return 0;} 1.13. k次幂和12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int P=1000000009;const int INV2=500000005;const int SQRT5=383008016;const int INVSQRT5=276601605;const int A=691504013;const int B=308495997;const int N=100005;ll n,K;ll fac[N],inv[N];ll pa[N],pb[N];inline void Pre(int n){ fac[0]=1; for (int i=1;i&lt;=n;i++) fac[i]=fac[i-1]*i%P; inv[1]=1; for (int i=2;i&lt;=n;i++) inv[i]=(P-P/i)*inv[P%i]%P; inv[0]=1; for (int i=1;i&lt;=n;i++) inv[i]=inv[i]*inv[i-1]%P; pa[0]=1; for (int i=1;i&lt;=n;i++) pa[i]=pa[i-1]*A%P; pb[0]=1; for (int i=1;i&lt;=n;i++) pb[i]=pb[i-1]*B%P;}inline ll C(int n,int m){ return fac[n]*inv[m]%P*inv[n-m]%P;}inline ll Pow(ll a,ll b){ ll ret=1; for (;b;b&gt;&gt;=1,a=a*a%P) if (b&amp;1) ret=ret*a%P; return ret;}inline ll Inv(ll x){ return Pow(x,P-2);}inline void Solve(){ ll Ans=0; for (int j=0;j&lt;=K;j++){ ll t=pa[K-j]*pb[j]%P,tem; tem=t==1?n%P:t*(Pow(t,n)-1+P)%P*Inv(t-1)%P; if (~j&amp;1) Ans+=C(K,j)*tem%P,Ans%=P; else Ans+=P-C(K,j)*tem%P,Ans%=P; } Ans=Ans*Pow(INVSQRT5,K)%P; printf(\"%lld\\n\",Ans);}int main(){ int T; freopen(\"t.in\",\"r\",stdin); freopen(\"t.out\",\"w\",stdout); Pre(100000); scanf(\"%d\",&amp;T); while (T--){ scanf(\"%lld%lld\",&amp;n,&amp;K); Solve(); } return 0;} 1.14. 杜教筛 筛$\\mu$和$\\varphi$的板子,根据内存来限制先预处理多少 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define N 6000010using namespace std;template&lt;typename T&gt;inline void read(T &amp;x){ x=0; static int p;p=1; static char c;c=getchar(); while(!isdigit(c)){if(c=='-')p=-1;c=getchar();} while(isdigit(c)) {x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c-48);c=getchar();} x*=p;}bool vis[N];int mu[N],sum1[N],phi[N];long long sum2[N];int cnt,prim[N];tr1::unordered_map&lt;long long,long long&gt;w1;tr1::unordered_map&lt;int,int&gt;w;void get(int maxn){ phi[1]=mu[1]=1; for(int i=2;i&lt;=maxn;i++) { if(!vis[i]) { prim[++cnt]=i; mu[i]=-1;phi[i]=i-1; } for(int j=1;j&lt;=cnt&amp;&amp;prim[j]*i&lt;=maxn;j++) { vis[i*prim[j]]=1; if(i%prim[j]==0) { phi[i*prim[j]]=phi[i]*prim[j]; break; } else mu[i*prim[j]]=-mu[i],phi[i*prim[j]]=phi[i]*(prim[j]-1); } } for(int i=1;i&lt;=maxn;i++)sum1[i]=sum1[i-1]+mu[i],sum2[i]=sum2[i-1]+phi[i];}int djsmu(int x){ if(x&lt;=6000000)return sum1[x]; if(w[x])return w[x]; int ans=1; for(int l=2,r;l&gt;=0&amp;&amp;l&lt;=x;l=r+1) { r=x/(x/l); ans-=(r-l+1)*djsmu(x/l); } return w[x]=ans;}long long djsphi(long long x){ if(x&lt;=6000000)return sum2[x]; if(w1[x])return w1[x]; long long ans=x*(x+1)/2; for(long long l=2,r;l&lt;=x;l=r+1) { r=x/(x/l); ans-=(r-l+1)*djsphi(x/l); } return w1[x]=ans;}int main(){ int t,n; read(t); get(6000000); while(t--) { read(n); printf(\"%lld %d\\n\",djsphi(n),djsmu(n)); } return 0;} 2. 数据结构2.1. kd树 x维数为2的KDtree模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL INF = 0x3f3f3f3f3f3f3f3f;const int MAXN = 1e5 + 10;struct Node { int lson, rson; LL Min[2], Max[2], x[2]; int id;} kdt[MAXN &lt;&lt; 1], tmp;int root, cmp_x;LL ans, xx0, xx1;bool cmp (const Node &amp;a, const Node &amp;b) { return a.x[cmp_x] &lt; b.x[cmp_x] || (a.x[cmp_x] == b.x[cmp_x] &amp;&amp; a.x[cmp_x^1] &lt; b.x[cmp_x^1]);}// 更新每个结点的边界信息void pushUp(int u, int v) { for (int i = 0; i &lt; 2; i++) kdt[u].Min[i] = min(kdt[u].Min[i], kdt[v].Min[i]); for (int i = 0; i &lt; 2; i++) kdt[u].Max[i] = max(kdt[u].Max[i], kdt[v].Max[i]);}int kdtBuild(int l, int r, int X) { int mid = (l + r) &gt;&gt; 1; kdt[mid].lson = kdt[mid].rson = 0; cmp_x = X; nth_element(kdt + l + 1, kdt + mid + 1, kdt + r + 1, cmp); // 将编号为mid的元素放在中间，比它小的放在前面，比它大的放后面 kdt[mid].Min[0] = kdt[mid].Max[0] = kdt[mid].x[0]; kdt[mid].Min[1] = kdt[mid].Max[1] = kdt[mid].x[1]; if (l != mid) kdt[mid].lson = kdtBuild(l, mid - 1, X ^ 1); if (r != mid) kdt[mid].rson = kdtBuild(mid + 1, r, X ^ 1); if (kdt[mid].lson) pushUp(mid, kdt[mid].lson); if (kdt[mid].rson) pushUp(mid, kdt[mid].rson); return mid;}// 插入新的结点void kdtInsert(int now) { int X = 0, p = root; while (true) { pushUp(p, now); if (kdt[now].x[X] &lt; kdt[p].x[X]) { if (!kdt[p].lson) { kdt[p].lson = now; return; } else p = kdt[p].lson; } else { if (!kdt[p].rson) { kdt[p].rson = now; return; } else p = kdt[p].rson; } }}// 点(x,y)在结点id的边界范围内能得到的最大距离上界LL getMaxDis(int id, LL x0, LL x1) { LL res = 0; if (x0 &lt; kdt[id].Min[0]) res += (kdt[id].Min[0] - x0) * (kdt[id].Min[0] - x0); if (x0 &gt; kdt[id].Max[0]) res += (kdt[id].Max[0] - x0) * (kdt[id].Max[0] - x0); if (x1 &lt; kdt[id].Min[1]) res += (kdt[id].Min[1] - x1) * (kdt[id].Min[1] - x1); if (x1 &gt; kdt[id].Max[1]) res += (kdt[id].Max[1] - x1) * (kdt[id].Max[1] - x1); return res;}LL dist(int id, LL x0, LL x1) { return (kdt[id].x[0] - x0) * (kdt[id].x[0] - x0) + (kdt[id].x[1] - x1) * (kdt[id].x[1] - x1);}void kdtQuery(int p) { LL dl = INF, dr = INF, d; d = dist(p, xx0, xx1); if (kdt[p].x[0] == xx0 &amp;&amp; kdt[p].x[1] == xx1) d = INF; // 查询(x,y)时要将(x,y)到自己的距离设为INF ans = min(ans, d); if (kdt[p].lson) dl = getMaxDis(kdt[p].lson, xx0, xx1); if (kdt[p].rson) dr = getMaxDis(kdt[p].rson, xx0, xx1); if (dl &lt; dr) { if (dl &lt; ans) kdtQuery(kdt[p].lson); if (dr &lt; ans) kdtQuery(kdt[p].rson); } else { if (dr &lt; ans) kdtQuery(kdt[p].rson); if (dl &lt; ans) kdtQuery(kdt[p].lson); }}LL answer[MAXN];int main() { //freopen(\"in.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) { int n; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(\"%I64d%I64d\", &amp;kdt[i].x[0], &amp;kdt[i].x[1]); kdt[i].id = i; } root = kdtBuild(1, n, 0); for (int i = 1; i &lt;= n; i++) { ans = INF; xx0 = kdt[i].x[0]; xx1 = kdt[i].x[1]; kdtQuery(root); answer[kdt[i].id] = ans; // printf(\"---%d\\n\", ans); } for (int i = 1; i &lt;= n; i++) printf(\"%I64d\\n\", answer[i]); } return 0;} 3. dp3.1. 区间dp1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define mst(a,b) memset((a),(b),sizeof(a))#define rush() int T;scanf(\"%d\",&amp;T);while(T--)typedef long long ll;const int maxn = 205;const ll mod = 1e9+7;const ll INF = 1e18;const double eps = 1e-9;int n,x;int sum[maxn];int dp[maxn][maxn];int main(){ while(~scanf(\"%d\",&amp;n)) { sum[0]=0; mst(dp,0x3f); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;x); sum[i]=sum[i-1]+x; dp[i][i]=0; } for(int len=2;len&lt;=n;len++) for(int i=1;i&lt;=n;i++) { int j=i+len-1; if(j&gt;n) continue; for(int k=i;k&lt;j;k++) { dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]); } } printf(\"%d\\n\",dp[1][n]); } return 0;} 3.2. 状压dp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int RD(){ int out = 0,flag = 1;char c = getchar(); while(c &lt; '0' || c &gt;'9'){if(c == '-')flag = -1;c = getchar();} while(c &gt;= '0' &amp;&amp; c &lt;= '9'){out = out * 10 + c - '0';c = getchar();} return flag * out; }const int maxn = 2048;int num,m,numd;struct Node{ int dp,step; };int vis[maxn];int map[maxn][maxn];void BFS(int n){ queue&lt;Node&gt;Q; Node fir;fir.step = 0,fir.dp = n;//初始状态入队 Q.push(fir); while(!Q.empty()){//BFS Node u = Q.front(); Q.pop(); int pre = u.dp; for(int i = 1;i &lt;= m;i++){//枚举每个操作 int now = pre; for(int j = 1;j &lt;= num;j++){ if(map[i][j] == 1){ if( (1 &lt;&lt; (j - 1)) &amp; now){ now = now ^ (1 &lt;&lt; (j - 1));//对状态进行操作 } } else if(map[i][j] == -1){ now = ( (1 &lt;&lt; (j - 1) ) | now);//对状态进行操作 } } fir.dp = now,fir.step = u.step + 1;//记录步数 if(vis[now] == true){ continue; } if(fir.dp == 0){//达到目标状态 vis[0] = true;//相当于一个标记flag cout&lt;&lt;fir.step&lt;&lt;endl;//输出 return ;//退出函数 } Q.push(fir);//新状态入队 vis[now] = true;//表示这个状态操作过了（以后在有这个状态就不用试了） } } }int main(){ num = RD();m = RD(); int n = (1 &lt;&lt; (num)) - 1; for(int i = 1;i &lt;= m;i++){ for(int j = 1;j &lt;= num;j++){ map[i][j] = RD(); } } BFS(n); if(vis[0] == false) cout&lt;&lt;-1&lt;&lt;endl; return 0;} 3.3. 数位dp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849typedef long long ll; int a[20]; ll dp[20][state];//不同题目状态不同ll dfs(int pos,/*state变量*/,bool lead/*前导零*/,bool limit/*数位上界变量*/)//不是每个题都要判断前导零 { //递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了 if(pos==-1) return 1;/*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。不过具体题目不同或者写法不同的话不一定要返回1 */ //第二个就是记忆化(在此前可能不同题目还能有一些剪枝) if(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=-1) return dp[pos][state]; /*常规写法都是在没有限制的条件记忆化，这里与下面记录状态是对应，具体为什么是有条件的记忆化后面会讲*/ int up=limit?a[pos]:9;//根据limit判断枚举的上界up;这个的例子前面用213讲过了 ll ans=0; //开始计数 for(int i=0;i&lt;=up;i++)//枚举，然后把不同情况的个数加到ans就可以了 { if() ... else if()... ans+=dfs(pos-1,/*状态转移*/,lead &amp;&amp; i==0,limit &amp;&amp; i==a[pos]) //最后两个变量传参都是这样写的 /*这里还算比较灵活，不过做几个题就觉得这里也是套路了 大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论 去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目 要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类， 前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/ } //计算完，记录状态 if(!limit &amp;&amp; !lead) dp[pos][state]=ans; /*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/ return ans; } ll solve(ll x) { int pos=0; while(x)//把数位都分解出来 { a[pos++]=x%10;//个人老是喜欢编号为[0,pos),看不惯的就按自己习惯来，反正注意数位边界就行 x/=10; } return dfs(pos-1/*从最高位开始枚举*/,/*一系列状态 */,true,true);//刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛 } int main() { ll le,ri; while(~scanf(\"%lld%lld\",&amp;le,&amp;ri)) { //初始化dp数组为-1,这里还有更加优美的优化,后面讲 printf(\"%lld\\n\",solve(ri)-solve(le-1)); } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;typedef long long ll;int a[20];ll dp[20][2];ll dfs(int pos, int pre, int state, bool limit)//不是每个题都要判断前导零{ if(pos==-1) return 1; if(!limit &amp;&amp; dp[pos][state]!=-1) return dp[pos][state]; int up=limit?a[pos]:9; ll ans=0; for(int i=0;i&lt;=up;i++) { if(i == 4) continue; else if(pre == 6 &amp;&amp; i == 2) continue; ans+=dfs(pos-1, i, i == 6 ? 1 : 0, limit &amp;&amp; i==a[pos]); } if(!limit) dp[pos][state]=ans; return ans;}ll solve(ll x){ int pos=0; while(x) { a[pos++]=x%10; x/=10; } return dfs(pos - 1, 0, 0, true);}int main(){ ll le,ri; while(~scanf(\"%lld%lld\",&amp;le,&amp;ri) &amp;&amp; (le || ri)) { memset(dp, -1, sizeof(dp)); printf(\"%lld\\n\",solve(ri)-solve(le-1)); } return 0;} 4. 计算几何4.1. 红书4.2. 三维向量旋转1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;#define eps 1e-10#define pi acos(-1.0)using namespace std;int dcmp(double x){if (fabs(x)&lt;eps)return 0;else return x&lt;0?-1:1;}struct Point3{ double x,y,z; Point3(double x=0,double y=0,double z=0):x(x),y(y),z(z){};};typedef Point3 Vector3;Vector3 operator + (Vector3 a,Vector3 b){return Vector3(a.x+b.x,a.y+b.y,a.z+b.z);}Vector3 operator - (Vector3 a,Vector3 b){return Vector3(a.x-b.x,a.y-b.y,a.z-b.z);}Vector3 operator * (Vector3 a,double b){return Vector3(a.x*b,a.y*b,a.z*b);}Vector3 operator / (Vector3 a,double b){return Vector3(a.x/b,a.y/b,a.z/b);}bool operator == (Vector3 a,Vector3 b){return a.x==b.x &amp;&amp; a.y==b.y &amp;&amp; a.z==b.z;}double Dot3(Vector3 a,Vector3 b){return a.x*b.x+a.y*b.y+a.z*b.z;} //点积double Length3(Vector3 a){return sqrt(Dot3(a,a));}Vector3 Cross3(Vector3 a,Vector3 b) //叉积{return Vector3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);}double Angle3(Vector3 a,Vector3 b){return acos(Dot3(a,b)/Length3(a)/Length3(b));}// 范围[0,180]//点到线段的距离double DistanceToSeg3(Point3 p,Point3 a,Point3 b){ if(a==b) return Length3(p-a); Vector3 v1=b-a,v2=p-a,v3=p-b; if(dcmp(Dot3(v1,v2))&lt;0) return Length3(v2); else if(dcmp(Dot3(v1,v3))&gt;0) return Length3(v3); else return Length3(Cross3(v1,v2))/Length3(v1);}//点p绕向量ov旋转ang角度，旋转方向是向量ov叉乘向量opPoint3 rotate3(Point3 p,Vector3 v,double ang){ double ret[3][3],a[3]; v = v / Length3(v); ret[0][0] = (1.0 - cos(ang)) * v.x * v.x + cos(ang); ret[0][1] = (1.0 - cos(ang)) * v.x * v.y - sin(ang) * v.z; ret[0][2] = (1.0 - cos(ang)) * v.x * v.z + sin(ang) * v.y; ret[1][0] = (1.0 - cos(ang)) * v.y * v.x + sin(ang) * v.z; ret[1][1] = (1.0 - cos(ang)) * v.y * v.y + cos(ang); ret[1][2] = (1.0 - cos(ang)) * v.y * v.z - sin(ang) * v.x; ret[2][0] = (1.0 - cos(ang)) * v.z * v.x - sin(ang) * v.y; ret[2][1] = (1.0 - cos(ang)) * v.z * v.y + sin(ang) * v.x; ret[2][2] = (1.0 - cos(ang)) * v.z * v.z + cos(ang); for (int i=0;i&lt;3;i++) a[i]=ret[i][0]*p.x+ret[i][1]*p.y+ret[i][2]*p.z; return Point3(a[0],a[1],a[2]);}Point3 face,head,st,en,a,vx=Point3(1,0,0),vy=Point3(0,1,0),vz=Point3(0,0,1);int main(){ int T,n; scanf(\"%d\",&amp;T); while (T--) { double ans=1e8,ang,dx,dy,dz,d; char x[3]; face=Point3(1,0,0); head=Point3(0,0,1); scanf(\"%lf%lf%lf\",&amp;st.x,&amp;st.y,&amp;st.z); scanf(\"%lf%lf%lf\",&amp;en.x,&amp;en.y,&amp;en.z); scanf(\"%d\",&amp;n); while (n--) { scanf(\"%lf %s %lf\",&amp;d,x,&amp;ang); dx=d*cos(Angle3(vx,face)); dy=d*cos(Angle3(vy,face)); dz=d*cos(Angle3(vz,face)); a=st+Point3(dx,dy,dz); ans=min(ans,DistanceToSeg3(en,st,a)); st=a; if (x[0]=='U') { Vector3 v=Cross3(face,head); face=rotate3(face,v,ang); head=rotate3(head,v,ang); }else if (x[0]=='D') { Vector3 v=Cross3(head,face); face=rotate3(face,v,ang); head=rotate3(head,v,ang); }else if (x[0]=='L') { face=rotate3(face,head,ang); }else if (x[0]=='R') { Vector3 v=head*(-1); face=rotate3(face,v,ang); } } printf(\"%.2f\\n\",ans); } return 0;} 5. 博弈6. 图论7. 黑科技7.1. 高精123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145struct Wint:vector&lt;int&gt;{ Wint(int n=0) { push_back(n); check(); } Wint&amp; check() { while(!empty()&amp;&amp;!back())pop_back(); if(empty())return *this; for(int i=1; i&lt;size(); ++i) { (*this)[i]+=(*this)[i-1]/10; (*this)[i-1]%=10; } while(back()&gt;=10) { push_back(back()/10); (*this)[size()-2]%=10; } return *this; }};istream&amp; operator&gt;&gt;(istream &amp;is,Wint &amp;n){ string s; is&gt;&gt;s; n.clear(); for(int i=s.size()-1; i&gt;=0; --i)n.push_back(s[i]-'0'); return is;}ostream&amp; operator&lt;&lt;(ostream &amp;os,const Wint &amp;n){ if(n.empty())os&lt;&lt;0; for(int i=n.size()-1; i&gt;=0; --i)os&lt;&lt;n[i]; return os;}bool operator!=(const Wint &amp;a,const Wint &amp;b){ if(a.size()!=b.size())return 1; for(int i=a.size()-1; i&gt;=0; --i) if(a[i]!=b[i])return 1; return 0;}bool operator==(const Wint &amp;a,const Wint &amp;b){ return !(a!=b);}bool operator&lt;(const Wint &amp;a,const Wint &amp;b){ if(a.size()!=b.size())return a.size()&lt;b.size(); for(int i=a.size()-1; i&gt;=0; --i) if(a[i]!=b[i])return a[i]&lt;b[i]; return 0;}bool operator&gt;(const Wint &amp;a,const Wint &amp;b){ return b&lt;a;}bool operator&lt;=(const Wint &amp;a,const Wint &amp;b){ return !(a&gt;b);}bool operator&gt;=(const Wint &amp;a,const Wint &amp;b){ return !(a&lt;b);}Wint&amp; operator+=(Wint &amp;a,const Wint &amp;b){ if(a.size()&lt;b.size())a.resize(b.size()); for(int i=0; i!=b.size(); ++i)a[i]+=b[i]; return a.check();}Wint operator+(Wint a,const Wint &amp;b){ return a+=b;}Wint&amp; operator-=(Wint &amp;a,Wint b){ if(a&lt;b)swap(a,b); for(int i=0; i!=b.size(); a[i]-=b[i],++i) if(a[i]&lt;b[i]) { int j=i+1; while(!a[j])++j; while(j&gt;i) { --a[j]; a[--j]+=10; } } return a.check();}Wint operator-(Wint a,const Wint &amp;b){ return a-=b;}Wint operator*(const Wint &amp;a,const Wint &amp;b){ Wint n; n.assign(a.size()+b.size()-1,0); for(int i=0; i!=a.size(); ++i) for(int j=0; j!=b.size(); ++j) n[i+j]+=a[i]*b[j]; return n.check();}Wint&amp; operator*=(Wint &amp;a,const Wint &amp;b){ return a=a*b;}Wint divmod(Wint &amp;a,const Wint &amp;b){ Wint ans; for(int t=a.size()-b.size(); a&gt;=b; --t) { Wint d; d.assign(t+1,0); d.back()=1; Wint c=b*d; while(a&gt;=c) { a-=c; ans+=d; } } return ans;}Wint operator/(Wint a,const Wint &amp;b){ return divmod(a,b);}Wint&amp; operator/=(Wint &amp;a,const Wint &amp;b){ return a=a/b;}Wint&amp; operator%=(Wint &amp;a,const Wint &amp;b){ divmod(a,b); return a;}Wint operator%(Wint a,const Wint &amp;b){ return a%=b;} 8. tips 唯一分解定理：n的因子个数Num(n) = (1 + a1) * (1 + a2) * … * (1 + an)a &gt; b 且 gcd(a, b) == 1, 有$(gcd(a^n - b^n, a^m - b^m)) = a^{gcd(n, m)} - b^{gcd(n, m)}$$\\mu(n)$——莫比乌斯函数$\\varphi(n)$——欧拉函数。表示不大于n且与n互质的正整数个数，十分常见的数论函数。用数学式子表示即：$\\varphi(n)=\\sum_{i=1}^{n}[gcd(n,i) == 1]$$d(n)$——约数个数。表示n的约数的个数。用式子表示为:$d(n)=\\sum_{d|n}1$,也可以写作:$d(n)=\\sum_{d=1}^{n}[d|n]$$\\sigma(n)$——约数和函数。即n的各个约数之和。表示为$\\sigma(n)=\\sum_{d|n}d=\\sum_{d=1}^{n}[d|n] * d$ document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"基础","slug":"基础","link":"/tags/%E5%9F%BA%E7%A1%80/"},{"name":"诗句","slug":"诗句","link":"/tags/%E8%AF%97%E5%8F%A5/"},{"name":"Introduction","slug":"Introduction","link":"/tags/Introduction/"},{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"模板","slug":"模板","link":"/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"C++Primer","slug":"C-Primer","link":"/tags/C-Primer/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"面向面试编程","slug":"面向面试编程","link":"/tags/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E7%BC%96%E7%A8%8B/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"容器化","slug":"容器化","link":"/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"编译原理","slug":"编译原理","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"GO","slug":"GO","link":"/tags/GO/"},{"name":"分布式","slug":"分布式","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"做题家","slug":"做题家","link":"/tags/%E5%81%9A%E9%A2%98%E5%AE%B6/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Gaman","slug":"Gaman","link":"/tags/Gaman/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"汇编","slug":"汇编","link":"/tags/%E6%B1%87%E7%BC%96/"},{"name":"安全","slug":"安全","link":"/tags/%E5%AE%89%E5%85%A8/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"categories":[{"name":"Science","slug":"Science","link":"/categories/Science/"},{"name":"Romance","slug":"Romance","link":"/categories/Romance/"},{"name":"Ego","slug":"Ego","link":"/categories/Ego/"},{"name":"Gaman","slug":"Gaman","link":"/categories/Gaman/"}]}