{"pages":[{"title":"","text":"A simple, delicate, and modern theme for the static site generator Hexo. Preview | Documentation | Chat on Gitter 💿 Installation12$ npm install hexo-theme-icarus$ hexo config theme icarus Please refer to Getting Started with Icarus for more details. 🎁 FeaturesCyberpunk Theme VariantTap into the future cyber world with the newly added Cyberpunk theme variant. Inspired by Cyberpunk 2077. Extensive Plugin SupportIcarus includes plentiful search, comment, sharing and other plugins out of the box that makes your blog feature-rich and powerful. Comment Changyan · Disqus · DisqusJS · Facebook · Gitalk · Gitment · Isso · LiveRe · Utterance · Valine Donate Button Afdian.net · Alipay · Buy me a coffee · Patreon · Paypal · Wecat Search Algolia · Baidu · Google CSE · Insight Share AddThis · AddToAny · Baidu Share · Share.js · ShareThis Widgets Google Adsense · Archives · Categories · External Site Links · Recent Posts · Google Feedburner · Tags · Table of Contents Analytics Baidu Statistics · Bing Webmaster · BuSuanZi Web Counter · CNZZ Statistics · Google Analytics · Hotjar · StatCounter · Twitter Conversion Tracking Other Plugins Cookie Consent · LightGallery · Justified Gallery · KaTeX · MathJax · Oudated Browser · Page Loading Animations Colorful Code HighlightIcarus directly import stylesheets from the highlight.js package and makes more than 90 code highlight themes available to you. Atom One Light Monokai Kimbie Dark Flexible Theme ConfigurationIcarus allows you to configure your site on a per-page or per-layout basis. _config.icarus.yml12345widgets: - type: profile position: left - type: recent_posts position: right post.md12345widgets: - type: profile position: left - type: recent_posts position: left _config.page.yml1widgets: null Responsive LayoutGive your audiences best viewing experience with Icarus’s mobile-friendly responsive layout. 🔨 DevelopmentThis project is built with Hexo Inferno.js Stylus Bulma Please refer to the documentation and contributing guide for implementation details. 🎉 ContributeIf you feel like to help us build a better Icarus, you can ✒ Submit a tutorial | 🌏 Add a translation | 🚩 Report a bug | 🔌 Suggest a new feature 📝 LicenseThis project is licensed under the MIT License - see the LICENSE file for details. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"The Road Not Taken","text":"The Road Not Takenby Robert Frost Two roads diverged in a yellow wood,And sorry I could not travel bothAnd be one traveler, long I stoodAnd looked down one as far as I couldTo where it bent in the undergrowth Then took the other, as just as fair,And having perhaps the better claim,Because it was grassy and wanted wear;Tough as for that the passing thereHad worn them really about the same, And both that morning equally layIn leaves no step had trodden black.Oh,I kept the first for another day!Yet knowing how way leads on to way,I doubted if I should ever come back. I shall be telling this with a sighSomewhere ages and ages hence:Two roads diverged in a wood, and I–I took the one less traveled by,And that has made all the difference. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/the-road-not-taken/"},{"title":"hello world","text":"本文主要介绍各种语言中“hello world”程序的写法。 前置知识： 无 C语言：12345678910111213141516#include &lt;stdio.h&gt;int main(){ printf(\"hello world\\n\"); return 0;}``` ### C++```c++#include &lt;iostream&gt;using namespace std;int main(){ cout&lt;&lt;\"hello world\"&lt;&lt;endl; return 0;} Python 31print(\"hello world\") Pyhton 21print \"hello world\" PHP123&lt;?phpecho \"hello world\"?&gt; Java因为代码过长而懒得写。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/hello-world/"},{"title":"The first blog","text":"这里是我的第一篇博客。 由于贫穷的原因，懒得续费阿里云和域名，现将博客搭到Github上。将来也将陆续将各种文章写在这里。原来写过的文章也会补在这里。预计有时间去注册个免费域名。关于分区：科学/Science ：技术类文章。浪漫/Romance ：生活，人文类文章。克苏鲁/Cthulhu ：奇奇怪怪的文章。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Ego/the-first-blog/"},{"title":"When You Are Old","text":"When You Are Oldby William Butler Yeats When you are old and grey and full of sleep,And nodding by the fire, take down this book,And slowly read, and dream of the soft lookYour eyes hd once, and of their shadow deep; How many loved your moments of glad grace,And loved your beauty with love false or true,But one man loved the pilgrim soul in you,And loved the sorrows of your changing face; And bending down beside the glowing bars,Murmur, a little sadly, how Love fled.And paced upon the mountains overhead.And hid his face amid a crowd of stars. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/when-you-are-old/"},{"title":"Sonnet 18","text":"Sonnet 18by William Shakespeare Shall I compare thee to a summer’s day?Thou art more lovely and more temperate.Rough winds do shake the darling buds of May,And summer’s lease hath all too short a date. Sometime too hot the eye of heaven shines,And often is his gold complexion dimm’d;And every fair to fair sometime declines,By chance or nature’s changing course untrimmed. But thy eternal summer shall not fade,Nor lose possession of that fair thou ow’st;Nor shall Death brag thou wander’st in his shade,When in eternal lines to time thou grow’st. So long as men can breathe or eyes can see,So long lives this, and this gives life to thee. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/sonnet-18/"},{"title":"How Do I Love Thee","text":"How do Love Theeby Elizabeth Barrett Browning How do I love thee? Let me count the ways.I love thee to the depth and breadth and heightMy soul can reach, when feeling out of sightFor the ends of Being and ideal Grace.I love thee to the level of everyday’sMost quiet need, by sun and candlelight.I love thee freely, as men strive or Right;I love thee purely, as they turn for Praise.I love thee with the passion put to useIn my old griefs, and with my childhood’s faith.I love thee with a love I seemed to loseWith my lost saints. I love thee with the breath,Smiles, tears, of all my life; and if God choose,I shall but love thee better after death. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/how-do-i-love-thee/"},{"title":"She Walks in Beauty","text":"She Walks in Beautyby Lord Byron She walks in beauty, like the nightOf cloudless climes and starry skies;And all that’s best of dark and brightMeet in her aspect and her eyes;Thus mellowed to that tender lightWhich heaven to gaudy day denies? One shade the more, one ray the less,Had half impaired the nameless graceWhich waves in every raven tress,Or softly lightens o’er her face;Where thoughts serenely sweet express,How pure, how dear they’re dwelling-place. And on that cheek, and o’er that brow,So soft, so calm, yet eloquent,The smiles that win, the tints that glow,But tell of days in goodness spent,A mind at peace with all below,A heart whose love is innocent! document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/she-walks-in-beauty/"},{"title":"When We Two Parted","text":"When We Two Partedby Lord Byron When we two partedIn silence and tears,Half broken-hearted,To sever for years,Pale grew thy cheek and cold,Colder thy kiss;Truly that hour foretoldSorrow to this. The dew of the morningSank chill on my brow–It felt like the warningOf what I feel now.Thy vows are all broken,And light is thy fame:I hear thy name spoken,And share in its shame. They name thee before me,A knell to mine ear;A shudder comes o’er me–Why wert thou so dear?They know not I knew thee,Who knew thee too well–Long, long shall I rue thee.Too deeply to tell. In secret we met–In science we grieveThat thy heart could forget,Thy spirit deceive.If I should meet theeAfter long years,How should I greet thee?With silence and tears. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/when-we-two-parted/"},{"title":"To His Coy Mistress","text":"To His Coy Mistressby Andrew Marvel Had we but world enough, and time,This coyness, lady, were no crime.We would sit down, and think which wayTo walk, and pass our long love’s day.Thou by the Indian Ganges’ sideShouldst rubies find: I by the tideOf Humber would complain. I wouldLove you ten years before the Flood,And you should, if you please, refuseTill the conversion of Jews.My vegetable love should growVaster than empires, and more slow;An hundred years should go to praiseThine eyes and on thy forehead gaze;Two hundred to adore each breast;But thirty thousand to the rest;An age at least to every part,And the last age should show your heart;For, Lady, you deserve this state,Nor would I love at lower rate.But at my back I always hearTime’s wingèd chariot hurrying near;And yonder all before us lieDeserts of vast eternity.Thy beauty shall no more be found,Nor, in thy marble vault, shall soundMy echoing song: then worms shall tryThat long preserved virginity,And your quaint honour turn to dust,And into ashes all my lust:The grave’s a fine and private place,But none, I think, do there embrace.Now therefore, while the youthful hueSits on thy skin like morning dew,And while thy willing soul transpiresAt every pore with instant fires,Now let us sport us while we may,And now, like amorous birds of prey,Rather at once our time devourThan languish in his slow-chapt power.Let us roll all our strength and allOur sweetness up into one ball,And tear our pleasures with rough strifeThorough the iron gates of life:Thus, though we cannot make our sunStand still, yet we will make him run. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Romance/to-his-coy-mistress/"},{"title":"洛谷P2357守墓人题解","text":"题解 前置知识： C++ 数据结构 题目链接P2357 守墓人 解题思路线段树or树状数组裸题本题解用的可区间更新的树状数组数据范围会爆int,所以用long long 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long long sum[200010];long long lazytag[200010];int n;inline int lowbit(int x){ return x&amp;(-x);}long long suum(int i,long long k[]){ long long s=0; while(i&gt;0) { s+=k[i]; i-=lowbit(i); } return s;}void update(int x,long long a,long long k[]){ while(x&lt;=n) { k[x]+=a; x+=lowbit(x); }}void uprange(int x,int y,long long a){ update(x,-(x-1)*a,sum); update(x,a,lazytag); update(y+1,y*a,sum); update(y+1,-a,lazytag);}long long rangesum(int i,int j){ long long s=0; s+=suum(j,sum)+suum(j,lazytag)*j; s-=suum(i-1,sum)+suum(i-1,lazytag)*(i-1); return s;}int main(){ int f; scanf(\"%d%d\",&amp;n,&amp;f); long long i,j,x,y,su; int t; memset(sum,0,sizeof(sum)); memset(lazytag,0,sizeof(lazytag)); for(i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;t); update(i,t,sum); } for(i=0;i&lt;f;i++) { scanf(\"%lld\",&amp;t); if(t==1) { scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;su); uprange(x,y,su); } if(t==2) { scanf(\"%lld\",&amp;su); uprange(1,1,su); } if(t==3) { scanf(\"%d\",&amp;su); uprange(1,1,-su); } if(t==4) { scanf(\"%lld%lld\",&amp;x,&amp;y); printf(\"%lld\\n\",rangesum(x,y)); } if(t==5) { printf(\"%lld\\n\",rangesum(1,1)); } }} document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E6%B4%9B%E8%B0%B7p2357%E5%AE%88%E5%A2%93%E4%BA%BA%E9%A2%98%E8%A7%A3/"},{"title":"洛谷P4712题解","text":"题解 前置知识： C++ 题目链接P4712 「生物」能量流动 解题思路贪心的思想，要想要获得的能量最多，就要保证流失的能量最少。由题目可知，ri+1 &gt;=ri，后面的食量不小于前面的食量，后面的可以吃到后面的生物，前面的只能吃前面的生物，由此可以得到贪心策略：从前往后尽量满足食物。复杂度据说是O(nlogn),但我不会算……实测跑得很快。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;double a[100005];int main(){ int n,i,left=0,d,j,flag = 0; double x,tmp; scanf(\"%d%lf\",&amp;n,&amp;a[0]); for(i=1; i&lt;=n; i++) { scanf(\"%lf%d\",&amp;x,&amp;d); tmp = x; for(j=left; j&lt;=d; j++) { // printf(\"%f %f\\n\",x,a[j]); if(a[j]&lt;1e-9) left = j; if(x&lt;=a[j]/5.0+1e-10) { a[j]-=5*x; a[i]=tmp; x=0; break; } else { x=x-(a[j]/5.0); a[j]=0; left++; } } if(x&gt;1e-9) { printf(\"-1\\n\"); return 0; } } double sum=0; for(i=left;i&lt;=n;i++) { sum+=a[i]; } printf(\"%f\\n\",sum/5.0);} document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E6%B4%9B%E8%B0%B7p4712%E9%A2%98%E8%A7%A3/"},{"title":"AC自动机模板","text":"题解 前置知识： C++ 数据结构 题目链接P3808 【模板】AC自动机（简单版）P3808 【模板】AC自动机（加强版） 解题思路第一题：在文本串中，寻找有多少模式串出现过。第二题：在文本串中，找到出现次数最多的模式串，并且输出。如有多个结果则输出多个。两题的本质都是AC自动机。先构建Trie树，然后依据KMP的思想，构造fail树。然后进行查询。代码的主要区别在query和insert。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#define N 500010using namespace std;queue&lt;int&gt;q;struct AC{ int c[N][26],val[N],fail[N],cnt; void ins(char *s) //建立trie树 下标存储字母 内容存取跳转 { int len = strlen(s); int now =0; for(int i=0; i&lt;len; i++) { int v = s[i]-'a'; if(!c[now][v]) c[now][v]=++cnt; now = c[now][v]; } val[now]++; } void build()//构建fail树 { for(int i=0; i&lt;26; i++) //初始化 if(c[0][i]) fail[c[0][i]]=0,q.push(c[0][i]); while(!q.empty()) { int u=q.front(); q.pop(); for(int i=0; i&lt;26; i++) { if(c[u][i]) fail[c[u][i]]=c[fail[u]][i],q.push(c[u][i]);//跳转 else c[u][i]=c[fail[u]][i]; } } } int query(char *s) { int len = strlen(s); int now=0,ans=0; for(int i=0; i&lt;len; i++) { now = c[now][s[i]-'a']; for(int t=now; t&amp;&amp;~val[t]; t=fail[t]) ans+=val[t],val[t]=-1; } return ans; }} ac;int n;char p[1000005];char ch[155][75];int main(){ scanf(\"%d\",&amp;n); for(int i=1; i&lt;=n; i++) scanf(\"%s\",p),ac.ins(p); ac.build(); scanf(\"%s\",p); int ans = ac.query(p); printf(\"%d\\n\",ans); return 0;}``` ```c++#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#define N 1000005using namespace std;queue&lt;int&gt;q;int ans[155];struct AC{ int c[N][26],val[N],fail[N],cnt; //建立trie树 下标存储字母 内容存取跳转 v代表模式串的次序 void ins(char *s,int v) { int len = strlen(s); int now =0; for(int i=0; i&lt;len; i++) { int v = s[i]-'a'; if(!c[now][v]) c[now][v]=++cnt; now = c[now][v]; } val[now]=v; } void build()//构建fail树 { for(int i=0; i&lt;26; i++) //初始化 if(c[0][i]) fail[c[0][i]]=0,q.push(c[0][i]); while(!q.empty()) { int u=q.front(); q.pop(); for(int i=0; i&lt;26; i++) { if(c[u][i]) fail[c[u][i]]=c[fail[u]][i],q.push(c[u][i]); //跳转 else c[u][i]=c[fail[u]][i]; } } } void query(char *s) { int len = strlen(s); int now=0; memset(ans,0,sizeof(ans)); for(int i=0; i&lt;len; i++) { now = c[now][s[i]-'a']; for(int t=now; t; t=fail[t]) ans[val[t]]+=1; } }} ac;int n;char p[1000005];char ch[155][75];int main(){ while(~scanf(\"%d\",&amp;n)) { if(n==0) return 0; memset(ac.c,0,sizeof(ac.c)); memset(ac.val,0,sizeof(ac.val)); memset(ac.fail,0,sizeof(ac.fail)); ac.cnt=0; memset(p,0,sizeof(p)); memset(ch,0,sizeof(ch)); memset(ans,0,sizeof(ans)); q=queue&lt;int&gt;(); for(int i=1; i&lt;=n; i++) scanf(\"%s\",ch[i]),ac.ins(ch[i],i); ac.build(); scanf(\"%s\",p); ac.query(p); int tmp = 0; for(int i=1;i&lt;=n;i++) { if(tmp&lt;ans[i]) tmp = ans[i]; } cout&lt;&lt;tmp&lt;&lt;endl; for(int i=1;i&lt;=n;i++) { if(tmp==ans[i]) { printf(\"%s\\n\",ch[i]); } } } return 0;} document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/ac%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%A8%A1%E6%9D%BF/"},{"title":"LCA模板","text":"题解 前置知识： C++ 数据结构 题目链接P3379 【模板】最近公共祖先（LCA） LCALCA 即最近公共祖先前序遍历中 LCA(S) 出现在所有 S 元素之前 后序遍历在 S 之后两点的最近公共祖先必定处在树上两点间的最短路上两点距离 *d(u,v)=h(u)+h(v)-2h(lca(u,v))** 。 代码#include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int maxn = 500005; struct EDGE { int t, next; } e[2 * maxn]; //邻接表存边 //t表示指向的点 next表示下条边 //head[x]表示x的点存的首条边的号码 int dep[maxn], fa[maxn][22], lg[maxn], head[maxn]; int tot; void add(int x, int y) { e[++tot].t = y; e[tot].next = head[x]; head[x] = tot; } void dfs(int f, int fat)//f表示当前节点 fat表示父亲节点 { dep[f] = dep[fat] + 1;//深度+1 fa[f][0] = fat;//f的父亲是fat for (int i = 1; (1&lt;&lt; i) &lt;= dep[f]; i++) fa[f][i] = fa[fa[f][i - 1]][i - 1]; //f的2**i的祖先，是f 的2**(i-1)的祖先的2**(i-1)的祖先 //2**(i-1)+2**(i-1)==2**i for (int i = head[f]; i; i = e[i].next) if (e[i].t != fat) { dfs(e[i].t, f); } } int lca(int x, int y) { if (dep[x] &lt; dep[y]) { swap(x, y); } while (dep[x] &gt; dep[y]) { x = fa[x][lg[dep[x] - dep[y]] - 1]; //跳到同一深度 } if (x == y) return x;//如果一个是另一个祖先，直接返回 for (int k = lg[dep[x]]-1; k &gt;= 0; k--) if (fa[x][k] != fa[y][k]) x = fa[x][k], y = fa[y][k]; return fa[x][0]; } int n, m, s; int main() { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt;= n - 1; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); add(y, x); } dfs(s, 0); for (int i = 1; i &lt;= n; i++) { lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i); cout&lt;&lt;lg[i]&lt;&lt;\" i:\"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;endl; //预先算出log_2(i)+1的值，用的时候直接调用就可以了 } for (int i = 1; i &lt;= m; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", lca(x, y)); } return 0; } document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/lca%E6%A8%A1%E6%9D%BF/"},{"title":"C++Primer Learning #0","text":"写在前面：C++Primer Learning预计会成为我的博客的一个系列，其中主要针对的是我个人对于C++语言的所不熟悉，不了解的部分，主要是个人的学习，所以更新内容不确定，对于C++Primer的部分内容会有省略。 目录：待更新 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/c-primer-learning-0/"},{"title":"OAuth 2.0","text":"前置知识： 网络 OAuth 2.0令牌 有时间范围，过期失效 可以被所有者撤销，立刻失效 有权限范围令牌四种形式： 授权码： 先申请授权码，再用该码获取令牌 隐藏式： 直接发放令牌 密码式： 直接告诉密码 凭证式： 用于命令行，在命令行下请求令牌令牌使用： 请求头加上authorization字段更新令牌： 一次性发放两个令牌，一次用于更新，一个用 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/oauth-2-0/"},{"title":"RESTful api设计","text":"前置知识： 网络 RESTful api设计协议： https域名： 使用专有域名，如https://api.example.com 简单,无扩展的话可以 https://expamle.com/api/版本： 放入url或http头 https://api.example.com/v1/路径： 只能有名词，与数据库表格名相对应，用复数形式，如 https://api.example.com/v1/zoos/HTTP动词： GET (SELECT) 取出资源 POST （CREATE） 新建资源 PUT (UPDATE) 改变后的完整资源的更新 PATCH (UPDATE) 改变资源属性 DELETE (DELETE) 删除资源 HEAD 获取资源原数据 OPINION 知晓哪些属性可以改变参数过滤： ?limit=10 返回记录数量 ?offset=10 返回记录开始位置 ?page=1&amp;perpage=10 每页记录数 ?sotredby=name&amp;order=asc 排序 ?x_type_id=1 筛选条件Status Code： 200 OK 201 created 202 accepted 已经进入排队 异步任务 204 no content 删除成功 400 invalid request 发出请求有错误 401 unauthorized 无权限 403 forbidden 授权但禁止访问 404 not found 不存在 406 not acceptable 请求格式不可得(要xml得到json) 410 gone 永久删除 422 unprocessable entity 创建对象时候验证错误 500 internal server error 服务器发生错误 502 bad gateway 服务器在充当网关或代理时，从其试图完成请求时访问的上游服务器接收到无效响应。错误信息： 返回键值对： error : xxx返回结果： GET /collection: 返回资源对象的列表 /collection/resource: 返回单个 POST /collection: 新生成的对象 PUT /collection/resource: 完整资源对象 PATCH /collection/resource: 同上 DELETE /collection/resource: 返回空文档Hypermedia API： 在返回结果中提供连接连向其他api，便于连向下一步其他： 身份认证用OAuth 2.0框架 多用json document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/restful-api%E8%AE%BE%E8%AE%A1/"},{"title":"docker安装与搭建qqbot","text":"前置知识： 网络 python docker安装与搭建qqbotdocker是什么Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。 它是目前最流行的 Linux 容器解决方案。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 比起虚拟机，docker具有运行速度快，体积小，占用资源少等诸多优点，这让docker十分流行。 docker 安装docker存在社区版与付费的企业版，本次使用的是免费的社区版。 本次使用的是windows的docker，可以点进下载链接进行下载，具体安装流程可以参考官方文档。 值得注意的是，官网并没有提供windows家庭版的安装流程，笔者在这里给出家庭版的流程。 1.安装Hyper-V 将下列代码保存为.cmd文件并以管理员身份运行,执行完毕后重启电脑 123456789pushd \"%~dp0\"dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum &gt;hyper-v.txtfor /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:\"%SystemRoot%\\servicing\\Packages\\%%i\"del hyper-v.txtDism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 2.解决Containers Windows Feature is not available问题 虽然网上教程没有遇到这个问题，但笔者遇到了。解决方法为将下列代码保存为.bat文件，并且以管理员权限运行并重启电脑 123456pushd \"%~dp0\"dir /b %SystemRoot%\\servicing\\Packages\\*containers*.mum &gt;containers.txtfor /f %%i in ('findstr /i . containers.txt 2^&gt;nul') do dism /online /norestart /add-package:\"%SystemRoot%\\servicing\\Packages\\%%i\"del containers.txtDism /online /enable-feature /featurename:Containers -All /LimitAccess /ALLpause 3.修改注册表 在cmd执行以下命令 1REG ADD \"HKEY_LOCAL_MACHINE\\software\\Microsoft\\Windows NT\\CurrentVersion\" /v EditionId /T REG_EXPAND_SZ /d Professional /F 重启后注册表会还原，但不会影响linux容器正常使用。 4.安装installer 注意不要勾选windows容器的选项，一路next就行了。 docker运行docker容器运行的基本流程：下载或打包程序的image-&gt;将image run起来，形成容器。 1.注册账号 docker需要账号才能运行，在此不过多赘述 2.修改配置文件，添加镜像源 在windows界面可以通过gui,在setting-&gt;docker engine中修改，然后重启docker，可以改成如下： 1234\"registry-mirrors\": [ \"https://dockerhub.azk8s.cn\", \"https://hub-mirror.c.163.com\" ], 3.image文件 docker将应用程序和依赖全部打包在image文件中，并且通过该文件生成容器。image文件是通用的，可以将一台机器上的image文件上放入另一台的image进行使用。image文件也可以继承另一个image文件进行开发。 image文件可以上传到仓库进行共享，而docker hub作为官方的仓库，是最为重要的仓库。 下面通过运行实例hello-world进行说明。 首先，可以执行以下命令将官方的hello-world的image文件拉至本地。 1docker image pull hello-world 等待抓取成功后，可以通过以下命令查看image文件 1docker image ls 4.run 通过以下命令运行hello-world的image文件 1docker run hello world 你会看到docker官方给出的信息，并且该容器会在信息结束后自动终止。但并非所有容器都是如此。 至此，简单的docker操作就结束了，下面研究有关将项目搭进docker的应用问题。 项目简介这次搭建的是构建在flask上的基于coolq-http的qqbot项目。项目内使用了redis进行数据的存储。本次将redis和BotServer分别打包进入容器中，实现redis和BotServer两个容器之间的通信，实现BotServer与宿主机上5700端口上的coolq-http通信。 本次项目所有python代码都在BotServer.py文件中。 关于bot怎么写在此不过多赘述，可以详见coolq-http的文档。 下面将详细解释搭建过程。 整理项目依赖项目基于flask实现，并且使用了redis通信模块。我们需要将所有的依赖写进requirement.txt文件中，并放入和项目的BotServer.py文件所在的文件夹。对于python项目，可以使用pipreqs进行自动编写。使用也很简单，cmd进入项目所在文件夹，执行以下命令即可。 12pip install pipreqspipreqs ./ --encoding=utf8 –encoding为可选项，但在windows下不加上这个选项会报错。 编写dockerfiledocker image的创建是通过docker一步步执行dockerfile来实现的。所以在编写好requirement.txt后，我们需要编写dockerfile。 在BotServer.py和requirement.txt所在的目录下，新建一个名为Dockerfile的文件(注意，没有后缀名)，将以下内容写进去。 1234567891011FROM python:3.6-slim WORKDIR /appCOPY . /appRUN pip install -r ./requirements.txt EXPOSE 5701CMD [\"python\",\"BotSever.py\"] FROM语句，含义是继承了官方的3.6-slim版本的python镜像。冒号表示标签，这里标签便是3.6-slim。 WORKDIR语句，指明接下来的工作目录为/app COPY语句，将本目录的所有文件复制到/app目录下去 RUN语句，指在build过程中执行该指令。这里执行的指令指使用pip将requirements.txt里的头文件全部安装。 EXPOSE语句，将端口5701开放。 CMD语句，在run的时候执行，在这里是指用python运行BotServer.py文件。 改写代码在打包成image之前，我们需要改写代码中的ip以及端口，来实现容器和容器之间的通信以及容器和宿主机的通信。 在原来的代码中，我们连接redis的方法如下： 1self.redis_pool = redis.ConnectionPool(host='127.0.0.1', port=6379, password='', db=0) host指向了127.0.0.1,也就是本机ip,但这在容器中是行不通的。由于隔离，无法直接将本机ip和容器中的127.0.0.1连接起来，我们可以将这一行改写成如下形式： 12self.redis_pool = redis.ConnectionPool( host='redis', port=6379, password='', db=0) 使用了redis代指本机ip,在run的时候，可以通过–link选项，将redis所在的容器与该项目所在的容器连接起来。 同理，我们需要将flask监听的地址，从127.0.0.1，改为0.0.0.0，来接受任何连接。 1self.bot_server.run(host=\"0.0.0.0\", port=5701) 在发送信息时，我们需要想宿主机的coolq-http的端口发送信息，就需要将代码中本机的url改为宿主机的url。在windows中，我们可以将127.0.0.1改为host.docker.internal。例如： 12url = \"http://127.0.0.1:12345/send_group_msg\" # 原来的urlurl = \"http://host.docker.internal:12345/send_group_msg\" 这样我们就能实现容器和宿主机的连接。 打包image在改写完代码后，我们就可以打包image了。用cmd进入项目所在目录，执行以下命令： 1docker build -t qqbot . -t用来指定image的名字，**.** 点代表本文件夹。打包需要一些时间下载。在完成后，我们就可以进行下一步。 安装运行redisredis安装是较为简单的一步，与hello word类似，我们可以直接从官方镜像源下载并且安装redis,执行命令如下： 12docker pull redis:latestdocker run -itd --name redis-test -p 6379:6379 redis 其中-p是将宿主机的6379端口(前一个6379)映射到容器的6379端口，从而便于外部访问。-d命令为后台运行。 -i: 以交互模式运行容器，通常与 -t 同时使用， -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用。 运行qqbot我们搭建好了redis的镜像并成功运行了起来，搭建好了bot的镜像，现在所需要做的便是将bot的镜像运行起来。在run之前，我们先查看redis所在的容器。可以执行以下命令查看: 1docker ps -a 在本台电脑上，显示如下： 2c30a28c3979 redis “docker-entrypoint.s…” 24 hours ago Up 3 hours 0.0.0.0:6379-&gt;6379/tcp redis-test 将最前面的container id复制下来，将之前改写的redis和容器地址使用–link连接起来，执行以下命令，便可以将bot跑起来了： 1docker run --name bot -itd --link 2c30a28c3979:redis -p 5701:5701 qqbot 这样，我们就成功将qqbot搭建进docker之中。 后记本文主要是记录自己踩过的一些坑，将整个流程写了一遍，其中改写代码的环节虽然很短，但耗费了我一天半的时间。有些问题很玄学，比如安装installer时报错，重启电脑就解决了。有时候pip时间过长会报错，重启docker就解决了。 为什么不把coolq也放进docker里，主要是因为懒…… 本次没有将qqbot全部代码展现出来，主要是因为代码质量目前还欠佳。等我有时间（没时间）将代码优化后，再来详细讲解bot。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/docker%E5%AE%89%E8%A3%85%E4%B8%8E%E6%90%AD%E5%BB%BAqqbot/"},{"title":"面向面试编程-蓄水池算法","text":"前置知识： 数学 面向面试编程-蓄水池算法题目要求给定一个极其大的数据流，大到无法存入内存，要求在所有数据中随机选取k个元素。 解法：蓄水池算法假设读取第i个数据，从1开始计数。如果i小于等于k，则存入蓄水池。如果i大于k，则随机取从1到i之间的随机数m，如果m处于1到k中，那么将i元素替换蓄水池中m元素。证明对于蓄水池中的元素，被选中的概率是不被蓄水池外的元素替换掉的概率。即k×(k+1)×…×(N-1)/((k+1)×(k+2)×…×(N)) = k/N。对于蓄水池外的元素，假设位置i，那么概率为选中的概率乘以不被后面元素替代的概率。即(k/i)×(i/(i+1))×…×((N-1)/N) = k/N。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E7%BC%96%E7%A8%8B-%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/"},{"title":"git的使用","text":"前置知识： 无 git的使用前言我发现我这个废物到现在没有系统性学习git，于是写了本文。主要用于加强记忆，备忘。 介绍git，又叫分布式版本控制系统。版本管理系统，意味着对项目的版本进行管理，可以退回到历史版本，也可以在历史版本基础上开发新版本，可以将分支的版本合并到主要版本从而便于开发。分布式意味着每台电脑上都是完整的版本，而非版本的一部分。 基本概念git主要有三个主要的基本概念：工作区， 版本库，暂存区。工作区：即工作目录，主要进行开发的位置。版本库：一般在工作目录中的隐藏文件夹.git目录中，git用于管理的工作目录。暂存区：类似于存放项目内文件的各种类修改操作。存放于index文件中。具体实现可以参考原理，本文不过多概述。 git常用命令git init：初始化工作目录，创建.git文件夹从而便于开始管理。git add：接文件名，在工作目录中搜索对应文件名，并且将文件存入暂存区。git commit：提交所有或者部分暂存区文件到仓库。一般加-m参数来写提交注释。一定要写提交注释。git status：查看仓库当前状态。git diff：查看未提交记录与提交过的具体文件差别。git log：查看log。git reset：有三种模式。可以使用–hard来更新工作区，暂存区，仓库所有文件到目标commit记录（参数为commit 的sha1）或者回退到之前几个版本（参数为HEAD^。尖号数量代表往前几个版本），通常用于回滚版本。另外两种模式可参照对应文档。git reflog：查看命令的日志。git checkout –filename：将工作区的文件修改撤销掉，换成最新的暂存区内或者版本库内的文件。git reset HEAD file：撤销暂存区的文件修改。git rm：版本库中删除对应文件。如果确实删除后需要提交。git clone：从对应库中拷贝项目。git mv：移动或者重命名对应文件。git branch：创建分支。git checkout：移动到分支。git merge：合并分支。如果出现冲突则手动解决冲突后git add对应文件。git push：将文件推到远程库。git pull：将远程库拉到本地库并覆盖。git stash：将当前目录保存起来，之后可以切换分支改bug，改完后用git stash pop来恢复现场。git rebase：将多个commit记录合并并接到另一个分支之后。用于整合commit记录。 总结主要包含了git的常用命令以及基本概念，各种参数不全面，各种功能描述也可能不全面或者有误，但主要功能基本准确。现在虽然ide帮我们做了很多，但学习一些git的概念对开发还是有意义的。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/git%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"C++ 实现线程池","text":"前置知识： c++ 操作系统 C++实现线程池前言 本文使用C++基本库，实现了固定线程数量的线程池。 线程池基础 对于了解过线程的人而言，线程池的概念并不难理解。为了避免频繁地创建与销毁线程，节省开销，预先创建一定数量的线程作为“池子”，并使用池内的线程来进行使用，节省开销。 理论并不困难，但在实现上面，由于现代C++自身的晦涩难懂，标准库的难以使用，而且网络上的教程不说人话，使得使用C++开发线程池存在不少困难。本文便理清这些困难，帮助更好使用C++。 thread介绍 在C++11之后，标准库增加了thread库，使得c++有了原生的线程支持。这里简单介绍一下库的几个方法。 构造函数：thread只有默认构造函数和移动构造函数，没有拷贝构造。在默认构造中，声明如下： 12template&lt; class Function, class... Args &gt;explicit thread( Function&amp;&amp; f, Args&amp;&amp;... args ); 它接收函数与参数，并执行。在实际运用中，除了传递函数指针，也可以直接使用lambda表达式。 方法：thread有多种方法，具体如下： | Observers | | | ———————————————————— | ———————————————————— | | joinable | checks whether the thread is joinable, i.e. potentially running in parallel context (public member function) | | get_id | returns the id of the thread (public member function) | | native_handle | returns the underlying implementation-defined thread handle (public member function) | | hardware_concurrency[static] | returns the number of concurrent threads supported by the implementation (public static member function) | | Operations | | | join | waits for a thread to finish its execution (public member function) | | detach | permits the thread to execute independently from the thread handle (public member function) | | swap | swaps two thread objects (public member function) | 在本次中主要使用了detach，即，将线程放开，到后台运行。 实现思路 可以看到，c11的thread库在线程创建时候便需要与一个函数相关联，无法更改。这里采用的实现思路为：将需要执行的函数当作对象，存入池子中。每个线程先阻塞，在函数存入时便唤醒，获取函数，得到函数参数，并执行该函数，在完成后再次阻塞。 由此，我们可以得到每个thread的主体内容： - 一个指针，指向线程池主体，来获取锁与函数。 - 函数主体为死循环，在检测到池子内有任务后便获取函数并执行。在检测到函数主题关闭后退出循环。在其他时刻阻塞。 - thread理应detach，在后台运行。 根据此流程，我们也可以得到线程池主体控制程序的内容： - 锁，用于协调各个线程。 - 任务队列，用于存放函数。 - 条件变量，用于唤醒线程。 - 标识退出的变量。 基本思路理清，我们可以写出对应代码。 Controller类 Controller类对应的便是控制程序。如上所述，我们构建相应的成员。 1234567891011121314template &lt;class F, class Args, class Ret&gt;class Controller{public: std::mutex mu;//锁 std::queue&lt;std::tuple&lt;F, Args, Ret &amp;&gt;&gt; tasks;//任务队列。存放函数的地方。 std::condition_variable cond_v;//条件变量，用于阻塞和唤醒线程 bool closed = false;//标志是否结束 Controller() = default;//默认构造函数 Controller(const Controller &amp;ctrl)//拷贝构造函数。 { //由于条件变量无法拷贝构造，这里只是占位，并不会实际发生拷贝 }}; 模板的三个参数分别对应函数主体，函数参数，函数返回值。因此返回值在队列里存放的为左引用。 拷贝构造函数不实际执行拷贝，只是占位便于代码编写。 就像之前上一部分所述一样，我们实现了控制类的编写。 ThreadPool 类 代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970template &lt;class F, class Args, class Ret&gt;class ThreadPool{public: Controller&lt;F, Args, Ret&gt; controller;//控制类 std::shared_ptr&lt;Controller&lt;F, Args, Ret&gt;&gt; shr_ptr;//指向控制类的指针 被所有线程共享 //构造函数。构造出给定数量的线程并且放入后台执行。 ThreadPool(size_t size) : controller() { this-&gt;shr_ptr = std::make_shared&lt;Controller&lt;F, Args, Ret&gt;&gt;(this-&gt;controller); //循环构造给定数量thread 并进入让其执行死循环 for (size_t i = 0; i &lt; size; i++) { std::thread([ptr = shr_ptr] { std::unique_lock&lt;std::mutex&gt; mux(ptr-&gt;mu); for (;;) { if (!ptr-&gt;tasks.empty())//如果任务非空，则从队列里获取并执行任务 { auto current = std::move(ptr-&gt;tasks.front()); F fun = std::get&lt;0&gt;(current); Args arg = std::get&lt;1&gt;(current); Ret &amp;re = std::get&lt;2&gt;(current); ptr-&gt;tasks.pop(); mux.unlock(); re = fun(arg); mux.lock(); } else if (ptr-&gt;closed)//退出循环 { break; } else//进入阻塞 { ptr-&gt;cond_v.wait(mux); } } }).detach(); } } //析构函数 先上锁通知类已经关闭 再利用条件变量通知所有线程 ~ThreadPool() { if ((bool)shr_ptr) { { std::lock_guard&lt;std::mutex&gt; mu(shr_ptr-&gt;mu); shr_ptr-&gt;closed = true; } shr_ptr-&gt;cond_v.notify_all(); } } //执行函数 先上锁写入任务，再通知一个线程进行执行 void excute(F &amp;&amp;f, Args &amp;&amp;args, Ret &amp;ret) { { std::lock_guard&lt;std::mutex&gt; mu(shr_ptr-&gt;mu); //上锁 析构时候解锁 便于写入 shr_ptr-&gt;tasks.emplace(std::tuple&lt;F, Args, Ret &amp;&gt;(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args), ret)); } shr_ptr-&gt;cond_v.notify_one(); }}; 如注释所写一般，我们使用c++实现了线程池。 总结 本次花了一晚上时间，使用c++实现了一个线程池。虽然只是固定数量的线程池，但对于c++并发而言，算是一个很好的入门。就我个人而言，本次也复习了不少c++相关知识，更接触了不少现代c++特性。可以看出，本文在左值右值上并没有过多阐述，因为本人对完美转发掌握尚不熟练。本次部分代码也是依葫芦画瓢。之后的c++学习过程中还得强化概念与使用方法。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/c-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"title":"计算机网络复习","text":"前置知识： 网络 计算机网络复习主要考点选择题/填空题/简答题/综合计算 物理传输介质种类： 引导型传输媒体： 双绞线 同轴电缆 光缆 非导引型传输媒体： 地面微波 卫星通信 网络协议定义，三要素： 定义：为进行网络中数据交换而定义的规则或标准 三要素： 语法：数据与控制信息的结构或格式 语义：发出何种控制信息，完成何种动作，作出何种响应 同步：事件实现顺序的说明 CSMA/CD，CSMA/CA工作原理： CSMA/CD：载波监听多点介入/碰撞检测 多点接入：总线型网络 载波监听：检测传输过程中是否有其他计算机发送，就是不停检测信道 碰撞检测：边发送边监听。检测到电压变化幅度过大则停止检测 使用该协议，只能半双工通信 在检测到空闲后，推迟一个随机的时间，然后重传 CSMA/CA：载波监听多点介入/碰撞避免 碰撞避免：减少碰撞发生的概率 发送数据之前先检测信道，检测为空闲则等待一个帧调节时间后发送，目的接受后则在等待一个短帧间隔后发送ACK，然后开始通信。源站还需要将占用时间发送给其他站。然后在忙变空闲后，在等待一个帧调节时间后进入争用窗口期，所有发送的站都要执行退避算法，随机选择一个时间间隙开启计时器，遇到忙则冻结。 子网路由与主机路由区别： 路由到子网和路由到主机 数据链路层功能，透明传输实现： 链路是从一个节点到相邻结点的一段物理线路 数据链路则是在链路基础上增加必要的硬件软件 向该层用户提供透明可靠的基本服务 三个问题：封装成帧 透明传输 差错检测 封装成帧：规定数据最大传送单元MTU，添加首部SOH，尾部EOT 转义数据报 透明传输：转义数据报 添加ESC字符转义 差错检测：CRC 仅检测不纠错 MAC地址/IP地址： 硬件地址，又称为物理地址与MAC地址，就是适配器地址或者适配器标识符。单个站地址 多播地址 全球管理 本地管理 IP地址：网络层以及以上使用地址，逻辑地址，路由器只根据IP进行选择 链路层只能看见MAC帧，IP层屏蔽了许多细节 ARP：使用ARP高速缓存 建立ARP映射表 动态更新 ARP过程：广播ARP请求分组 得到ARP响应 写入映射表 TCP链接，三次握手四次挥手： 三次握手 客户打开链接 创建传输控制模块TCB 客户向服务器发送SYN=1以及自己的序号X 服务器返回SYN=1 ACK=1 自己的序号Y ack数字X+1 客户机返回ACK=1 序号x+1 ack=y+1 并可以传输数据 四次挥手： 客户主动关闭，向服务发送FIN与序号 服务器照旧发送ACK与seq ack 服务器向客户确认FIN 发送ACK seq ack与上次ack相同 客户照旧确认 客户等待2MSL后关闭 可靠传输实现： 滑动窗口：以字节为单位。通过窗口滑动和累计确认来实现。有缓存用于存储乱序到达或者接受但未被读取的数据 RTT计算：RTT_new = (1-a)RTT_old + a(RTT_sample) a=0.125 超时时间RTO计算：RTO = RTT + 4(RTTd) RTTd_init = 0.5(RTT) RTTd_new = (1-b)RTTd_old + b(abs(RTT_new-RTT_sample)) b=0.25 选择确认：头部加上确认边界，防止重传浪费 TCP拥塞控制算法，计算： 拥塞控制：防止过多的数据注入到网络中全局性的过程 流量控制是点到点通信量控制 开环控制：设计网络时候将拥塞因素考虑周到;闭环控制：检测网络系统拥塞状态，将信息传达到可采取行动的地方 调整网络解决问题 慢开始：幂函数开始 直至达到门限 拥塞避免：每过一个RTT则增加1 快重传：收到一个即使顺序不对也确认 快恢复：3ACK后减半开始拥塞避免 3ACK减半 超时则归为1 门限都减半 AMQ：主动队列管理 小于最小门限则保留 超过最大门限则丢弃 在中间则随机丢弃 IP子网相关计算，超网： IP可以分为网络号，子网号，主机号 IP可以划分为A，B，C类，对应255.0.0.0 255.255.0.0 255.255.255.0 子网掩码与地址取AND，得到网络号地址。子网号位数决定子网数量，通常去掉全0和全1。子网主机数同理。 每一个CIDR地址数都是2的整数幂次倍数，相当包含网络数为2的网络数位数减去CIDR位数幂次 CRC计算： 被除数左移除数位数-1位，处以被除数，得到余数并加上。 余数为0则没有差错 RIP路由计算： 基于距离向量的路由选择协议 距离为跳数 仅和相邻路由器交换信息，交换信息为自己的路由表，按照固定时间间隔交换 距离算法：将表距离加1,下一跳转为目标主机，更新 实现简单 开销较小 好消息传得快 坏消息传的慢 网络规模小，最多为15 收敛慢 网络拓补结构： 边缘部分，核心部分 边缘部分：用户直接使用的，处于互联网的所有主机，又叫端系统。通信方式可分为CS方式和P2P方式 客户-服务方式：服务请求方和服务提供方。客户想服务器请求，不需要特殊硬件和复杂操作系统。服务可同时接受多个请求，需要很强大性能与软件支持。 P2P：对等连接方法 核心部分：给端系统提供服务的。路由器，交换机等。 局域网可分为星形网 环状网 总线网 交换技术种类： 电路交换特点：端到端建立专用物理通路 建立链接 通话 释放链接 在通话全部时间里，两个用户始终占用端到端通信资源 分组交换特点：采用存储转发技术 整块发送报文 将报文加上必要头部发送 需要传输路径 电路交换时延：电路建立连接时间S+报文总量X/数据率B+链路个数K multiply 链路传播时延B 分组交换时延：发送完最后一个分组结束 即经过k-1次转发 时延=数据总长度x/数据率b+（k-1）分组长度p/数据率b+k(传播时延b) 编码技术种类： 不归零制：正电平为1 负电平为0 归零制：正脉冲为1 负脉冲为0 曼彻斯特编码：向下跳变为1 向上跳变为0 差分曼彻斯特：从边界开始跳变为0 边界不跳变为1 调幅：载波的振幅 01表示不同振幅 调频：载波的频率 01对应不同频率 调相：初始相位随基带变化而变化 一般采用混合调制 正交振幅调制 信道复用技术： 频分复用：占用不同的频道带宽 时分复用：在不同时间占用同样的频带宽度 切分时间为固定长度组 统计时分复用：先集中器，再分配时间 波分复用：光的频分复用 码分复用：用户之间正交 网络互连，互连的设备，层次： 计算机，集线器，路由器，交换机等，手机等智能机器 网络将许多计算机连接在一起 互连网将许多网络通过路由器连接在一起 多ISP结构互联网，有主干ISP 地区ISP 本地ISP 互联网交换就诶点IXP允许两个网络直接相连而不必经过最上层主干ISP OSI IEEE体系结构分层： OSI七层模型：应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 OSI缺点：缺少实际经验 商业驱动 实现复杂 效率地下 制定周期长 运作不合理 实际运用为TCP/IP标准 IEEE：802.11 数据链路层分为逻辑链路控制子层 介质访问控制子层 面向连接，无连接应用，区别： 通信前建立连接，完成后释放连接/尽最大努力 传输控制协议TCP：提供面向连接的，可靠的数据传输服务，传输单位为报文段 用户数据报协议UDP：无连接的，尽最大努力的数据传输服务，传输单位为用户数据报 网络定义，网络分类： 计算机网络主要是由一些通用的 可编程的硬件互联而成 这些硬件并非专门用来实现某一特定目的 可编程的硬件能用来传输不同类型数据 并且支持广泛和日益增长的应用 广域网WAN：几十到几千公里;城域网MAN：一个城市;局域网LAN：用于微型计算机或工作站相连;个人区域网PAN：个人使用的电子设备互联 公用网：电信公司建造大型网络;专用网：特殊业务服务，如军队网络。 DNS作用： DNS根服务器采用任播技术 即相同IP但物理位置不同 因而总能找到最近的服务器 递归查询 迭代查询 将域名解析为IP 动态网页实现技术： CGI通用网关接口：定义动态文档如何创建，输入数据如何提供给应用程序 输出结果如何使用 CGI程序又叫CGI脚本 服务器推送技术 TCP开销大 活动文档技术 把工作交给浏览器 HTML，XML区别： HTML：超文本标记语言 展示文档 XML：可扩展标记语言 用于数据存储，传输等。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"},{"title":"容器化技术","text":"容器化技术作为当今热门的技术，已经形成的成熟的应用以及活跃的生态。越来越多的程序采用容器技术来进行封装。容器技术极大地改善了程序，简化了程序部署。其轻量化的特性也被许多解决方案所青睐。 本文旨在从零开始，构建一个类docker的容器应用，并且实际运行，同时对其中的原理进行剖析。 容器化技术本机环境：Linux version: 4.19.0-10-amd64 (debian-kernel@lists.debian.org) (gcc version 8.3.0 (Debian 8.3.0-6)) #1 SMP Debian 4.19.132-1 (2020-07-24)GO version: go1.13.6 linux/amd64 参考书籍《自己动手写Docker》 陈显鹭 王炳燊 秦妤嘉著 目录 初探容器化：隔离，限制与docker run 容器镜像与持久化 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF/"},{"title":"简易正则转NFA实现","text":"本文将介绍简易正则转nfa的一个python实现。 前置知识 python 编译原理 简易正则转NFA实现简介 NFA，即非确定性有限状态自动机。他将文本匹配转化为状态的转移，给予初态与终态。当一串文本随着输入，能成功从初态转换到终止状态，即为匹配成功。并且由于其为非确定型，相同的文本匹配模式，可能存在的NFA形态会很多。 正则表达式，即一串用于描述文本匹配规则的文本。通过特殊字符组合成规则字符串，用于过滤文本。 本项目将实现使用python，将简易正则，即包含连接运算，克林星号运算，或操作运算的正则表达式，转换到等价NFA的过程。 NFA实现 状态机本身相当于图，包含边集与点集。由于我们不需要实际进行匹配，只需要转换，因此可以省略部分点，只保留起点与终点。但我们需要展示所有边，因而边不可以省略。 根据上述描述，我们来定义类： 123456class NFA: def __init__(self,ch): self.head = 1 self.tail = 2 self.lines = [[1,ch,2]] 初始化方法，起点与终点，初始化的边。我们便拥有了一个最简单的NFA。在此基础上，我们再来实现相应运算功能。 连接操作 连接操作最为简单。我们只需要将第二个NFA起点连接到第一个NFA终点即可。注意结点序号问题。我们需要标识每个结点，这时候只需要将接在后面的NFA的每个结点的序号增加前NFA节点个数-1的数量即可。 12345def and_NFA(self,NFA_b): NFA_b.add_num(len(self)-1) for line in NFA_b.lines: self.lines.append(line) self.tail = NFA_b.tail 或运算操作 或运算稍为复杂，但也不难。或运算相当于将两个NFA并联起来。我们只需要增加头节点，尾结点，再在中间并联两个NFA即可。同样，注意结点序号问题。 1234567891011def or_NFA(self,NFA_b): self.add_num(1) NFA_b.add_num(len(self)+1) for line in NFA_b.lines: self.lines.append(line) self.lines.append([1,'~',self.head]) self.lines.append([1,'~',NFA_b.head]) self.lines.append([self.tail,'~',NFA_b.tail+1]) self.lines.append([NFA_b.tail,'~',NFA_b.tail+1]) self.tail = NFA_b.tail+1 self.head = 1 克林星号运算 克林星号运算所表示的NFA并不复杂。它表示前面的字符可以匹配0次或者多次。这里我们需要有一个循环的思想。即起点可以直接跳到终点，终点也可以直接跳到起点。那么增加两条边即可。 123def kleen_NFA(self): self.lines.append([self.head,'~',self.tail]) self.lines.append([self.tail,'~',self.head]) 由于我们只实现简易正则，实现三个运算即可。在完成NFA方法构建后，我们来关注正则的解析问题。 正则表达式解析 正则的解析如同计算器一样，需要符号栈与文本栈，并且要处理优先级问题。但我们只实现了三种运算，优先级问题并不困难。 对于克林运算，我们可以直接对文本栈顶进行运算。它的优先级最高。 对于连接运算，我们需要放入符号栈，等待遇到或运算清理栈时候来处理。 对于或运算，当检测到或时候，我们可以将栈顶的连接运算全部清空，直到遇到或运算或者左括号为止。再放入符号栈。 对于括号运算，左括号直接进入符号栈，右括号则清理文本栈，直到遇到左括号为止。 当算法结束后，若文本栈未规约完成，则继续弹出两个文本与一个符号，进行运算，直至规约完成。 对于上述规则，我们可以得到代码.此处连接使用点来代替。calculate函数代表将符号作用于文本栈： 12345678910111213141516171819202122232425262728293031def parse(s): sign_stack = [] nfa_stack = [] for ch in s: if ch=='(': sign_stack.append(ch) elif ch == ')': while len(sign_stack) != 0 and sign_stack[-1] != '(': tmp = sign_stack[-1] sign_stack.pop() nfa_stack[-2] = calculate(tmp,nfa_stack[-2],nfa_stack[-1]) nfa_stack.pop() elif ch == '*': nfa_stack[-1] = calculate(ch,nfa_stack[-1],None) elif ch == '|': while len(sign_stack) != 0 and sign_stack[-1] == '.': sign_stack.pop() nfa_stack[-2] = calculate('.',nfa_stack[-2],nfa_stack[-1]) nfa_stack.pop() sign_stack.append(ch) elif ch == '.': sign_stack.append(ch) else : nfa_stack.append(NFA(ch)) while len(nfa_stack)&gt;1: ch = sign_stack[-1] sign_stack.pop() nfa_stack[-2] = calculate(ch,nfa_stack[-2],nfa_stack[-1]) nfa_stack.pop() return nfa_stack[0] One more thing 最后一个问题。在默认的正则表达式中没有连接运算符。我们可以硬编码一下增加连接运算符的规则，然后将原来的表达式转换为可以解析的表达式。 123456789101112131415161718192021222324def RegexToNFA(s): ret = s[0] for i in range(1,len(s)): pre = s[i-1] now = s[i] if isCharacter(pre) and isCharacter(now): ret +='.' ret += now elif isCharacter(pre) and now == '(': ret +='.' ret += now elif pre == ')' and isCharacter(now): ret +='.' ret += now elif pre == '*' and isCharacter(now): ret +='.' ret += now elif pre == '*' and now == '(': ret +='.' ret += now else : ret += now print(ret) return parse(ret) 规则阐述不必多说。上述可能有遗漏，欢迎指正。 总结 本文提供了一个简单正则转NFA的python实现。之所以使用python是因为写着简单，数据结构随意。在最开始我想拿scheme写，但api还是不熟悉。最后选用了python。 本文技术含量不高，纯粹为课堂记录。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E7%AE%80%E6%98%93%E6%AD%A3%E5%88%99%E8%BD%ACnfa%E5%AE%9E%E7%8E%B0/"},{"title":"容器镜像与持久化","text":"本文为容器化技术系列文章的第二篇。本文将把容器技术与文件系统，压缩文件相结合，并且实现commit命令，用于保存镜像文件。 前置知识 Linux Go 容器镜像与持久化容器镜像overlay文件系统 从本文开始，我们将把参考资料《自己动手写docker》的原版中实现的镜像构造进行改造，其中最根本原因是原书采用了AUFS，而在笔者的系统上，没有AUFS，因而采用了docker也在使用的overlayfs进行替代。 overlayfs与AUFS类似，在linux 3.18内核便被支持。overlay允许一个读写目录树覆盖到另一个只读目录树上，所有对文件的修改都在上层的可写层进行。它与其他的UFS不同，在打开文件后的所有操作都转换到底层或者上层的文件系统。这使得文件系统的实现得到简化。 overlay简单的用法如下所示。 1mount -t overlay overlay -o lowerdir=/lower,upperdir=/upper,workdir=/work /merged 从上述的指令可以看出，指令指定了底层文件只读层，可以有多层;上层文件可写层;工作文件是提供给文件系统便于生成。merged则是最后合并的挂载目录。注意底层，顶层与工作的目录的文件系统，overlay在这方面有很多限制。 在执行完成上述挂载指令后，我们可以在文件夹中进行读写文件的尝试。具体不在本文中呈现。下面我们将其挂入容器系统之中。 busybox基础镜像 这里我们采用busybox作为基础的镜像。busybox是一个精简的镜像，包含了很多UNIX环境的常用命令。busybox可以使用docker export得到tar，并且解压得到新的rootfs。 我们实现的基础思路是：使用pivot_root将整个root文件系统移动进busybox所提供的目录，使用overlay将其创建为只读层，然后创建只写层，提供给容器进行运行操作。在容器结束运行后，还原这一切。 首先，我们将busybox解压，得到其rootfs。 12345678910111213141516171819func CreateReadOnlyLayer(rootURL string) error { //注意文件位置 将tar放到指定位置 busyboxURL := rootURL + \"busybox/\" busyboxTarURL := rootURL + \"busybox.tar\" exist, err := PathExists(busyboxURL) if err != nil { return fmt.Errorf(\"path exist error:%v\", err) } if exist == false { if err := os.Mkdir(busyboxURL, 0777); err != nil { return fmt.Errorf(\"mkdir root error: %v\", err) } //解压文件到文件夹 if _, err := exec.Command(\"tar\", \"-vxf\", busyboxTarURL, \"-C\", busyboxURL).CombinedOutput(); err != nil { return fmt.Errorf(\"tar error: %v\", err) } } return nil} 然后，创建读写层与工作层，将其挂入目录。此处不必多说。 之后，在mount各种需要的东西之前，我们要使用pivot_root系统调用，将整个系统的根文件移动进入该文件夹。 123456789101112131415161718192021222324252627282930func pivotRoot(root string) error { fmt.Println(\"pivot rooting\") //重新挂在本目录 便于使得新老root不在同一文件系统下 if err := syscall.Mount(root, root, \"bind\", syscall.MS_BIND|syscall.MS_REC, \"\"); err != nil { return fmt.Errorf(\"mount bind error: %v\", err) } pivotDir := filepath.Join(root, \".pivot_root\") if err := os.Mkdir(pivotDir, 0777); err != nil { return fmt.Errorf(\"mkdir error: %v\", err) } if err := syscall.Mount(\"\", \"/\", \"\", syscall.MS_PRIVATE|syscall.MS_REC, \"\"); err != nil { fmt.Printf(\"mount / error: %v\\n\", err) return err } if err := syscall.PivotRoot(root, pivotDir); err != nil { return fmt.Errorf(\"pivotroot error: %v\", err) } if err := syscall.Chdir(\"/\"); err != nil { return fmt.Errorf(\"chdir error: %v\", err) } //卸载原rootfs 清除临时文件 pivotDir = filepath.Join(\"/\", \".pivot_root\") if err := syscall.Unmount(pivotDir, syscall.MNT_DETACH); err != nil { return fmt.Errorf(\"umount error: %v\", err) } return os.Remove(pivotDir)} 在上述函数中，我们首先为了使得老root和新root不再一个文件系统下，将root重新mount了一次，使得新老root不在同一个文件系统下。然后进行系统调用，更改当前目录，删除临时文件。 在此之后，就像之前的文件系统一样，我们挂载必要的，如proc等。我们得到了以根目录为虚拟环境的容器进程。 至于卸载方面，我们只需要umount我们所挂载的目录，并且删除文件夹，即可。在此也不过多阐述。 但我们需要的不仅是虚拟的环境，我们还有持久化的需求。这里我们引入数据卷的概念，来存放我们持久化的数据。 持久化mount –bind 就像标题所写，这里我们采用mount –bind的方法来进行持久化。mount –bind相当于将两个目录连接起来。我们可以在得到持久化的目录名后，使用bind将容器外的目录与容器内的目录连接起来。同时在最后退出的时候，先卸载对应目录，此时文件便留在了容器外的目录。我们便实现了持久化的目标。 同时我们要注意，我们需要增加新的command选项，解析字符串，在这里便不过多展示。 volume代码实现 这里展示的仅仅是开始mount和结束umount的过程，增加命令与解析由于篇幅暂不展示。原理如上述所说。由于go的异常处理，代码会显得颇为冗杂。但本意如上所示。 1234567891011121314151617181920212223242526272829303132333435func MountVolume(rootURL string, mntURL string, volumeURLs []string) error { //volumeURLs格式为 [容器外目录,容器内目录] parentURL := volumeURLs[0] if err := os.Mkdir(parentURL, 0777); err != nil { if exist, _ := PathExists(parentURL); exist == false { return fmt.Errorf(\"error in mkdir parentURL: %v\", err) } } containerURL := volumeURLs[1] containerVolumeURL := mntURL + containerURL fmt.Println(containerVolumeURL) if err := os.Mkdir(containerVolumeURL, 0777); err != nil { return fmt.Errorf(\"error in mkdir containerVolumeURL: %v\", err) } //挂载目录 cmd := exec.Command(\"mount\", \"--bind\", parentURL, containerVolumeURL)//绑定 cmd.Stderr = os.Stderr cmd.Stdout = os.Stdout if err := cmd.Run(); err != nil { return fmt.Errorf(\"Mount volume error :%v\", err) } return nil}func DeleteVolumeMountPoint(mntURL string, volumnURL string) error { //卸载 cmd := exec.Command(\"umount\", \"-v\", mntURL+volumnURL) cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr if err := cmd.Run(); err != nil { return fmt.Errorf(\"delete mount volume error : %v\", err) } return nil} 在完成这些工作后，我们可以尝试数据卷是否工作正常。下面是本机的一个运行实例。可以看见，在完成数据卷工作后，数据确实得到了持久化。 1234567891011121314151617181920212223242526root@wqy:/media/wqy/新加卷/projekts/Go/src/mydocker# sudo ./mydockerdev run -ti -v /volume:/containerVolume shstart runCommandNew parentmounting /home/wqy/mnt//containerVolume[/volume /containerVolume]your command is shstart initCommandreading user commandthe command is shmount start/home/wqy/mntpivot rootingthe current wd is // # lsbin etc root usrcontainerVolume home sys vardev proc tmp/ # cd containerVolume//containerVolume # lsa.txt/containerVolume # echo \"sfsfsf\" &gt;b.txt/containerVolume # exitwqy@wqy:/volume$ cat b.txtsfsfsf 镜像打包 镜像打包也是我们需要的一项功能。在这里我们提供一个简单的实现方法：在为退出前，将所有文件打包成tar保存到外面即可。 在具体实现上，我们还需要增加指令，解析参数。我们这里使用commit命令，在容器运行时候进行打包。 12345678910func commitContainer(imageName string) error { mntURL := \"/home/wqy/mnt/\" rootURL := \"/home/wqy/\" imageTar := rootURL + imageName + \".tar\" fmt.Println(imageTar) if _, err := exec.Command(\"tar\", \"-czf\", imageTar, \"-C\", mntURL, \".\").CombinedOutput(); err != nil { return fmt.Errorf(\"tar error: %v \", err) } return nil} 这里提供的简单的打包解决方案。同样，解析命令的操作便不在此展示。 至此，我们实现了一些与容器文件相关的简单操作。 下一步做什么 在下一步，我们将继续扩展容器的功能，实现一些常用的docker指令，使得我们的容器更加接近docker，可用性更强。在下一篇文章中，我们将探讨这些功能。 总结与后记 这属于容器化技术第二篇文章。本文只介绍了一些简单的文件功能以及实现。文章较上一篇篇幅明显减少，主要原因还是实现的功能不太复杂，原理也不需要过多介绍。完成时间也较于上一篇文章所预期的时间晚了整整一个星期。这期间也有参加比赛，拖了一下的缘故。 写完本文主要是对文件的知识有所回顾。在本文中，我尝试了第一次自己设计解决方案，如使用bind，这是在原本书上没有写的。书上的解决方案在本机上无法实现，便自己想了一个。后来才发现，docker也使用了这样的技术。 下一篇技术含量会比本篇要更高。但预计时间也更长，可能是一个月左右，敬请期待。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/"},{"title":"Go知识点","text":"一些GO的知识点。 Go的知识点编译相关Go可以生成汇编，采用下列指令进行查看： 1go build -gcflags -S main.go Go可以生成汇编优化过程。通过GOSSAFUNC，可以生成html文件来交互查看。 SSA：静态单赋值。即每个变量只会被赋值一次，便于优化。同一变量名字会生成不同后缀来区分。 GO可以生成各种机器码，包括wasm。 TODO：待到学完编译原理在看。 数据结构数组只有类型和大小完全相同，才能认为是同一数据类型，可以用==比较。 【…】T{1,2,3}与【3】T{1,2,3}使用上完全相同，只是语法糖。 当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上。 当元素数量大于 4 个时，会将数组中的元素放到静态存储区初始化然后拷贝到栈上。 简单的越界错误可以由编译器发现，复杂的则需要运行时。运行时发现越界时候会panicIndex和runtime.goPanicIndex。运行时会插入代码，检查边界，越界则panic，通过则Load或Store。 切片slice有data指针，len长度，cap容量。 切片初始化可以有make创建，字面量初始化，或者截取数组或者切片的一部分。 切片逃逸：1、如果函数外部没有引用，则优先放到栈中；2、如果函数外部存在引用，则必定放到堆中； 切片很小并且非发生逃逸，会在栈或静态存储区初始化。否则在堆区初始化。 cap足够时候append覆盖时候会优化情况。不够则会调用growslice扩容并且拷贝过去。扩容规则如下： 如果期望容量大于当前容量的两倍就会使用期望容量； 如果当前切片的长度小于 1024 就会将容量翻倍； 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量； 大致容量如此，接下来还需要进行对齐操作。 拷贝时候会memove，这比依次拷贝性能更好，耗费资源仍然较多。 哈希表开放地址法:填空。 拉链法：挂上链表。 map底层为hmap，由若干个bmap桶组成。每个桶通常可以存8个元素。 通过哈希值低8位找到桶，在通过高八位对比tophash数组来查找。 分配时候若桶满则可以放入溢出桶，用overflow指针指过去。元素少于25个则直接hash，多余25则创建两个数组存储键值，然后for哈希过去。 在make时候，则会检查内存是否足够，获取哈希种子，计算最少桶数量，创建保存桶数组。 仅获取value的访问采用mapaccess1，会计算哈希值，查找桶，查找tophash，并且访问。mapaccess2就多个返回值。 当装载因子超过6.5或使用太多溢出桶会触发扩容 。扩容将桶数量翻倍，通过growWork触发，访问时候访问旧桶，写入则分流过到新桶。 删除和赋值逻辑类似。 字符串只读字符串，由data指针和len组成。 如果要修改，则要转换成为【】byte来进行。开销并不小。 逃逸分析取地址或者逃出了函数，按照此原则分析变量分配方法 语言基础函数调用在c语言中，函数调用参数使用寄存器与栈实现。6个一下为寄存器。以上放入栈。 Go采用栈来入参和出参，简化了实现，不必考虑架构。 Go无论是基本类型，结构体，还是指针，都会传值拷贝。 接口接口引入中间层，实现上下游解耦。在GO中，实现接口所有方法就算实现了接口。 interface{}不是任意类型。当我们转换成interface时候，类型就是interface。 函数接收者不是指针的时候，能通过结构体和指针使用方法。是指针的时候，只能通过指针使用方法。不能同时存在同名方法定义两次。 nil在转换成interface类型时候会包含以前的类型信息，因此转换后不是nil。 对于空interface而言，结构体为eface，不含方法，之包含类型与数据指针。_type类型中有数据大小，哈希值来快速确定类型是否相当，equal判断多个对象是否相等。 非空interface包含itab指针与数据指针。itab中包含对上述_type的哈希，来确认目标类型与具体类型是否相等。有fun动态大小数组，当成虚函数表，存储函数指针。同时包含原类型type和接口类型interfacetype。 非指针变量转换为接口会拷贝到堆上。 断言switch a.(type)时候会检查哈希值。 反射TypeOf接受空接口参数，转换为emptyInterface类型，并且获取typ并返回。 ValueOf则是先将其逃逸到堆上，热爱华南虎使用unpackEface将传进来的转换为emptyInterface结构体，包装成Value结构体并且返回。 更新变量时候，会检查变量是否对外公开。然后调用assignTo返回新反射对象，并且覆盖原始反射变量。 eface用于运行时，emptyInterface用于反射。 for range在for _,v:=range arr时候，系统会创建一个变量v，将数组值在迭代中覆盖过去，这导致v的地址在循环中不变。 使用for循环清空数组，切片，哈希表时候，会编译成arrayClear，加速过程，开销并不大。 range循环不会永动机，因为最开始会调用len来获取终止条件。 哈希表遍历：随机选一个正常桶开始，遍历桶内，桶外溢出桶，再按顺序来。 selectselect与switch类似，但状态只能是chan收发状态。 多个条件都满足时候，switch会随机执行，避免饥饿状态。 select的case用结构体表示 select不存在case直接阻塞，只有一个case则变成单if，一个case一个default会改写成if,else，默认情况下会将case转换为结构体，调用selectgo函数获取一个可行的结构体，使用一连串if观察是哪个被选中了。 轮询会随机开始，加锁顺序则是按地址排序。 调用select先确认轮询顺序加锁顺序，之后如果能立即执行则立即执行并返回，不能则创建sudog结构体，加入相关的收发队列，挂起等唤醒，唤醒了则遍历去找。 deferdefer会在函数结束执行，而不是代码作用域结束。 defer参数的值是在调用时候计算的。 defer采用延迟链表，最早只有堆上分配，后期有栈上分配，开放编码优化。 根据defer数量和return数量判断是否开放编码优化。直接插入到函数返回前。 panic recoverpanic时候，会放到panic链表最前面，然后获取defer链表，执行，最后panic。 程序的恢复由gopanic执行。取出栈顶指针和pc，执行recovery函数，recovery则跳回去。 make newmake需要判断类型，new则只用初始化指针，申请空间。 context基本用法如下： 12345678910111213141516171819202122232425func main() { ctx, cancel := context.WithCancel(context.Background()) go watch(ctx, \"【监控1】\") go watch(ctx, \"【监控2】\") go watch(ctx, \"【监控3】\") time.Sleep(10 * time.Second) fmt.Println(\"可以了，通知监控停止\") cancel() //为了检测监控过是否停止，如果没有监控输出，就表示停止了 time.Sleep(5 * time.Second)}func watch(ctx context.Context, name string) { for { select { case &lt;-ctx.Done(): fmt.Println(name, \"监控退出，停止了...\") return default: fmt.Println(name, \"goroutine监控中...\") time.Sleep(2 * time.Second) } }} chanchan结构体内包含队列元素个数，循环队列长度，数据指针，发送waitq，接收waitq。waitq表示双向链表，包含向前的sudog和向后的sudog。 发送前会先上锁，再判断是否closed。直接发送：先拷贝到目标地址，再标记接收goroutine，放进处理器runnext等待执行。带缓冲区：计算下一个可以存储数据的地方，再将数据拷贝到缓冲区，增加索引与计时器。缓冲区为循环数组。阻塞式发送：则先获取发送数据的goroutine，再获取sudog设置阻塞发送相关信息，加入发送等待队列，沉睡并等待唤醒，唤醒后首尾。 接收：如果不在缓冲区且就绪，则直接拷贝。在缓冲区，则拷贝并且移动缓冲区指针。chan为空则挂起，关闭则检查缓冲区，无数据则返回。如果发送队列存在挂起的，则从缓冲区拷贝到接收，再将发送挂起的拷贝进缓冲区。缓冲区存在数据则直接读，否则挂起。 GMP模型G表示goroutine，M表示线程，P表示处理器。G类似线程，包含自己的内存，栈，寄存器状态，再调度器保存或者恢复上下文的时候用到。M操作系统线程，GOMAXPROCS控制活跃数量，默认为CPU核数，减少系统调度开销。P提供上下文环境，可以调度线程上等待队列。调度时间点：主动挂起，系统调用，协作式调度，系统监控。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/go%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"杂乱知识点","text":"一些杂乱的知识点 杂乱知识点 01目录TODO protobuf为啥快 数据压缩程度高 解析速度快 protobuf基本使用tag|value方法存储数据。tag中包含数据序号与数据类型。从而避免了json的字符串解析。tag生成办法： 123static int makeTag(final int fieldNumber, final int wireType) { return (fieldNumber &lt;&lt; 3) | wireType;} 在上述代码中，fieldNumber为序号，wireType为数据类型。有符号整型使用zigzag编码，减少了存储空间。非varint类型数字采用小端序列存储。字符串类型采用**tag|len|str|**方法存储。 有符号整型的压缩ZigZag主要是将无符号数字0,1,2,3转换为有符号数字0,-1,1,-2等。之后我们可以压缩数据。将32位数据每次取7位，如果非最低字节则补1,其余补0.然后将低字节与高字节反转。（小端） 断点调试原理断点调试，即在断点处插入int 3指令，OS向进程发送SIGTRAP信号，使得当前进程暂停，交给父进程去处理。 按下ctrl-c后会发生什么发送SIGINT信号给前台进程组所有进程，强行终止程序执行。 进程间通信IPC InterProcessCommunication 匿名管道PIPE 半双工，只能一个方向流动，固定读写端 只能有亲缘关系进程之间的通信 类似于文件，可以read write，但仅存于内存 命名管道FIFO 可以在无关进程之间交换数据 属于特殊的文件形式存在于文件系统中，有路径名 消息队列 包含消息类型，存在优先级，有特定格式 读取时候可以按类型读取 信号量 发送信号，主要用于同步进程 原子操作 可以计数 共享内存 最快，直接读内存，效率高 可以多进程同时操作，需要同步 通常和信号量同时使用 TOP-K问题 quick select：快排思想，省去一半 平均On 最坏On2 建堆 nlogk 建堆可以分布式 可以哈希去重 B树与B+树B树 多叉树 关键词集合分布在整个树中 性能优异，等价于二分查找 关键词只出现在一个结点中 自动层次控制 B+树 用于数据库，文件系统等 数据稳定有序，自底向上插入，性能稳定 结点关键词只用于索引，不存储 叶子结点存储数据，并且添加链表指针 HTTP状态码见restful api 布隆过滤器使用k个哈希函数，将key映射成k个整数，然后将对应二进制位置为1。有一定概率判断出错。无法删除。 红黑树红黑树，自平衡的类平衡树，非严谨平衡。有以下特点 结点或黑或红 根是黑的 红色无法相连，黑色可以 根到所有叶子结点经过的黑色结点个数相同 插入结点过程 新插入的结点为红色 如果为根结点，则标记成黑色 如果parent不是黑色且不是root uncle为红 将parent and uncle标记为黑 祖父标记为红 与祖父相同颜色 uncle为黑 触发旋转 新结点为左左，则提绳子 左右，则将亲子换位，然后左左 右右同理 右做，则换位后右右 统计性能比avl更好 进程与线程 进程 系统进行资源调度和分配的基本单位，实现操作系统的并发。 进程内的线程共享堆，全局变量，静态变量，文件等。 进程之间同步基于IPC。 不同进程之间挂掉不影响 线程 CPU调度和分配的基本单位，实现进程内部的并发。 有独立的寄存器组，指令计数器，自己的栈。 线程之间同步基于内存。 同一进程的线程会相互影响 虚拟地址操作系统采用虚拟地址的方法，给予程序虚拟地址，由mmu翻译成物理地址，使得每个程序都认为自己独占了内存。好处： 抽象化，便于管理，分配，调度，便于利用碎片 扩大地址空间 便于共享 可以保护内存空间，难以访问到其他进程的内存坏处： 增加了开销，如翻译地址，额外的数据结构，磁盘io 可能浪费内存 缺页中断在malloc和mmap调用时候，只构建了虚拟地址，没有分配物理内存，当访问到的时候引起缺页异常，保护现场，分析原因，调用对应的处理函数，恢复。 系统锁 mutex互斥锁 读写都锁，统一时刻只能有一个访问 rwlock读写锁 写锁，可以有很多读，但写的时候不能读 spin自旋锁 同一时刻只有一个访问，但不会睡眠，而是自旋，一直保持活跃 RCU锁 写时候拷贝，对副本进行修改，在没有操作临界区时候去回调。 可重入锁 同一线程可以再次锁，不会死锁 乐观锁 认为拿数据的时候别人不会修改，读取的时候不会上锁。 在提交更新的时候使用版本号或者CAS算法来确定 CAS：当期望与实际符合的时候，才会更新替换，否则不会 悲观锁 在每次读取或修改都会上锁 不正确的代码容易导致死锁 进程状态创建-就绪-执行-等待-终止 死锁 互斥：资源只能被一个进程使用 请求与保持：在请求资源时候，不会放开自己已经持有的资源 不剥夺：不能强行剥夺 循环等待：各个进程循环等待 银行家算法：三个矩阵claimd allocated need，只要剩余不为负数则贷款给过去 几种io缓存IO：先拷贝到page cache，再拷贝到目标空间 效率较慢select poll epoll本质都是同步io，用于io复用select调用后会阻塞，知道fd就绪或者超时，并且通过遍历fd数组找到目标fd。描述符数量一半为1024。poll使用pollfd指针来实现，返回后采用轮询来返回就绪的fdepoll存在LT模式和ET模式，LT：应用程序不立即处理，ET则是立即处理。 BIO 同步阻塞 读取写入必须阻塞再一个线程里面完成，过程阻塞 NIO 同步非阻塞 不阻塞，而是反复查询 AIO 异步io 读取写入异步，内核读取了则发送信号 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E6%9D%82%E4%B9%B1%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"Raft项目总结","text":"raft作为相当有效的分布式算法的一个实现，较paxos更容易理解，也更加简便。本文将阐述raft相关的知识点，从而对raft算法有更深刻的理解。 前置知识： go 选主策略raft与paxos算法类似，都需要通过选主来保证一致性。但较paxos选主而言很明显，raft简化了选主过程。 计时器与状态改变在raft中，每个节点都需要维护一个计时器。当计时器到时间后，便需要改变自身状态，开始一轮选举。状态有Follower，Candidate，Leader三种，所有节点最初默认为Follower。在计时结束后，进入选举，成为Candidate。若收到大多数票，选举成功，则成为Follower。若选举被中断，比如收到了任期更高的节点发来的信息，则转换为Follower。 对于计时器而言，每次重置都会增加一个随机延迟，这是为了减少选举中的冲突，如同一时期许多节点都开始选举。这样的办法提高了选举安全性的保证，即同一时间只会选出一个Leader。 投票投票是原论文中相当详细的一部分，论文中列出的表很好地诠释了投票的进行过程，并且详细介绍了参数，这里给出一个投票RPC结构体的实现。 123456789101112type RequestVoteArgs struct { Term int CandidateID int LastLogIndex int LastLogTerm int}type RequestVoteReply struct { Term int VoteGranted bool} 与论文中保持一致，在征求投票参数中，Term表示自己的任期，ID用于标识自己，LastLogIndex与LastLogTerm涉及到后续的日志复制，是用来在任期相同时候来标识哪个结点更新的，从而更好选出Leader。返回值中，Term用于Candidate更新自己任期，如遇到任期更高的可以直接变成Follower，VoteGranted则用于表示是否投票。 进入选举之后，首先增加自己的Term，然后进行征求投票，向其他节点发送RPC请求，得到响应并且处理。任期是得到投票的关键。只有在当前节点与节点网络中过半节点一样新，才会被选举为Leader。这为后续的日志一致性提供了保证。 获得半数以上票则当选，非常自然而然地保证了选举Leader的唯一性。当无法获得半数以上投票时候，要么在接受其他节点信息的时候转变身份，要么计时器到期，进入新的选举。 心跳机制心跳机制是用于维护Leader地位的机制。当一个节点转变为Leader之后，会定期向其他节点发送空请求，使得其他节点能及时重置自己的计时器，避免进入选举状态。心跳机制也可以用于恢复之前失去连接的节点。如果心跳能够接通，则可以将之前的节点转换状态为Follower。 对于选举，更多的细节可以参考原论文。此处只是给出基本原理。 日志复制作为分布式系统，日志的一致性是必须要保证的一点。Raft实现日志复制的方法也不难理解。 日志表示 下面是单个日志的具体项的Go实现。实际存储使用切片即可。 1234type Log struct { Command interface{} Term int} 可以看出，日志不光包含朴素的指令信息，还包含日期信息，这是raft系统最主要的辨别日志的方法。当一个日志的任期与日志所在的位置（即Index索引）完全相同时候，才能认为是相同的。这也是用于主从日志保证一致性的策略。 日志一致性上面描述的日志的表示，这里我们将描述如何应用日志特性。 首先，日志只能从Leader接收，并且只能由Leader发向Follower。我们将日志区分为两种状态：未提交的，与已经 提交的。我们要确认的一致性，便是每个节点的committed的日志的一致性。 首先要确认的是，一条日志，只有存在于节点网络的过半节点中才会被提交，这意味着由网络隔离所导致的孤立节点网络中的日志可能会被多个机存储，但只要机器数量少于一半，则绝不会被提交。其次，就像之前所说，当Candidate与过半节点一样新的时候才会保证被选为Leader，这意味着Leader总是拥有最新最全的日志。由于消息传递的单向性，只能由Leader向Follower，因此Follower所能提交的日志总是Leader日志的一部分，这也保证了一致性。 在Leader内部会维护一个matchIndex与nextIndex，前者表示节点已经与本机匹配了的日志，后者表示下一个将要传递给该机器的日志索引。在选出新Leader时候，前者会被初始化为0,后者被初始化为本机日志长度减1。在本地日志与Leader发过来的日志对不上时候（这里的对不上，就是任期号与位置对不上），Leader便会改变该机器的nextIndex值，使其减少，直至对的上为止。当日志对上之后，Leader可以采用批量传递的方法，一次传递多个log，来提高效率，并且覆盖该节点的日志。传递日志数量取决与nextIndex的维护方式。每当日志复制完成，都会更新两个列表的值。最后，根据matchIndex值，可以得到一个已经确认复制完成的的列表。就我个人而言，我选择了根据该列表中位数的方法来确认该提交的日志。 同样，本文只是粗略概括，详细的一致性证明可以参考原论文的描述。 日志压缩日志无法无限地增长，因而我们需要压缩技术。在raft中，我们使用快照的方法来进行压缩。 快照技术快照技术理解并不困难，本质上便是合并已经提交的日志，对状态机进行合并，仅仅保留日志内最后一个任期与最后一个索引。 在实现上来说，通常每个服务器都是独立地建立快照，而不是由Leader统一创建。后者的开销与io效率更为低下。Leader偶尔也需要向落后的Follower发送快照来保证一致性，虽然开销看似很大，但在实际使用过程中，Follower的正常工作保持更新，会很少需要这些开销，因此这种开销是可接受的。 总结raft作为面向理解的算法，解决了paxos晦涩难懂的缺点，理解上并不困难，在实际工程运用中也相当实用。我自己亲手实现了个raft，由于一些代码规范的原因没有过多展示，但确实感觉对于分布式的理解更为增进了一步。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/raft%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"title":"编译原理做题版","text":"本文主要为编译原理的题目做法解答，基于mooc题目。人人都是做题家！ 编译原理做题版第二章 文法与语言写出语言文法对应的所有句子的集合，也就是文法所能推导出来的所有句子的集合。写出即可。 构造语法树根为产生式左部，下面从左到右组合成为产生式右部，构建即可。 如何生成目标串产生式推导，使用=&gt;连接即可。 二义性对于同一句子，是否存在两棵不同的语法树，可判断二义性。 给出语言的上下文无关文法上下文无关文法： 左侧必须为非终结符 且满足1型文法|β|&gt;=|α|无特定技巧，注意递归思想，注意数据范围，使用独特方法规范数据范围即可。 给出语言的三型文法三型文法： 右侧为左线性或者右线性，即只能aA与a，或只能Aa与a。也无特定技巧，注意三型文法规范。 第三章 词法分析画DFADFA状态是确定的，每一个输入对应确定的下一个状态，没有ε边。注意该点。进行绘画即可。 构造DFA首先需要NFA，这时候需要观察题干，得到NFA的所有字母，所有状态，转换关系，开始状态，结束状态。 然后将转换关系，绘制成NFA表格。 得到NFA表格后，扩充状态，如x状态在输入1后能进入x或y状态，则将xy状态加入表格，继续执行该过程，直至结束。 得到该表格后，将终止结点与非终止结点分为两个集合，在根据输入的不同，继续划分集合，直到无法再分。得到最简DFA。 画出图，即可。 写正规式注意星号，或号用法。 第四章 自顶向下语法分析first集求法first集合含义便是该非终结符所能产生的第一个字符，按照此规则去找。A-&gt;a则只有a，A-&gt;Ba则观察B是否成产生ε，如果能则将First(B)与a加入集合，不能则只加入First(B)，没有a。多个非终结符推出ε则以此类推。注意，epsilon本身也可以进入first集合。 follow集求法follow集合意义是该非终结符后面所有能接的第一个字符。那么观察产生式右边。比如A，如果只有S-&gt;Aa则follow只有a，如果只有S-&gt;A并且最后到了结束则加入#，如果S-&gt;AB，则将first(B)放入follow(A)，如果B能推出ε或者A为右部，则将follow(S)放入follow(A)。 select集合构建select集合是针对产生式的，注意。S-&gt;AB如果产生式右部不是空串，则为first(S)，AB可以推出空串，则first(S)∪follow(S)-ε LL(1)文法判断对于相同左部的产生式而言，产生式的select集合不相交。 预测分析表纵轴为产生式左部，横轴为输入符号，中间为对应产生式。 消除左递归对于A-&gt;Aα|β而言，为直接左递归，可以改写为A-&gt;βA’ A’-&gt;αA’的等价形式。存在间接左递归，可以先带入化成直接左递归后处理。 提取左公因子对于A-&gt;aB1|aB2|……|aBn|y 可以提取左公因子后，得到A-&gt;aB|y B-&gt;B1|B2|……|Bn 注意，消除左递归并且提取左公因子后不一定为LL(1)文法。 第五章 自底向上语法分析firstvt求法注意区别于first集合，firstvt求法：T-&gt;a…则加入a，T-&gt;R…则加入firstvt(R),T-&gt;Ra…则加入firstvt(R)与a。如此递归。 lastvt求法与firstvt类似，T-&gt;…a则加入a，T-&gt;…R则加入lastvt(R)，T-&gt;…aR则加入a和lastvt(R)，如此递归。 算符优先级判断对于ab而言，a=b。对于aAb而言，a=b，a小于firstvt(A)，lastvt(A)大于b，如此扫描。对于画表而言，横纵都是终结符，大小比较注意横纵关系。没有冲突则为算符优先级文法。 短语，句柄，素短语，最左素短语短语：子树的叶子从左到右句柄：最左的只有两层的子树的叶子从左到右素短语：至少包含一个非终结符的，与其他素短语不相交的短语最左素短语：语法树内最左的一个。 分析过程画表，观察栈顶和输入字符，比较关系，当遇到大于号和小于号配对时候则规约，不然移进。 第六章 LR分析法FSM构建首先增加拓广文法：增加个开头。将点放在拓广文法右部开头，如果是非终结符，则在方框内增加该非终结符的产生式，并将点放在右部开头。将点后续相同符号的，引出一条线指向新方框，方框内移动点到该符号后面，并和上面处理点后非终结符一样。迭代此过程，直到所有状态结束。 分析表构建注意ACTION表和GOTO表，如果点后为终结符则action(k,a) = Sj，k为当前表的标号，a为该中介符号j为后续表的标号。如果点后为非终结符A，则goto(k,A) = j如果项目为规约项目，则对于任何终结符a,Action(k,a)=rj，rj为目标产生式。注意这个a是任意a。如果结束了，则放入acc其他为error 分析表使用如果右边为si，则单纯地改变状态。如果右边为ri，则先将栈内符号可规约的符号弹出，状态置为剩余的栈顶部符号所存在的状态，根据此状态和规约出来的非终结符进行跳转。如此循环，直到结束。 LR(0)判断点后为终结符，则为移进项目。点后为非终结符，则为待约项目。点后为结束，则为规约项目。移进，规约同时存在会冲突。规约，规约存在也会冲突。 SLR(1)判断对于移进项目的非终结符b，规约项目的不同产生式左部B，C，如果b和Follow(B) Follow(C) 互不相交，则为SLR(1)文法，判断时候根据输入字符在这三者哪个里面决定移进还是规约。 第七章 语法制导的翻译标出属性值根据语义，带入语法树即可。 翻译成三地址码TAC三地址码 OP A1 A2 A3 类似汇编 注意操作变量个数 第八章 代码优化分基本块程序的第一个语句；goto的目标语句；跟在条件转移语句后面的语句 按照此切分 流图有向边：能到达则画有向边 根据go 语句执行顺序来确定 找循环D(N) 必经结点集合，指从开始到这个点，绕不开的结点的集合 当存在a-&gt;b的边，而且a的必经结点有b，则为回边回边a-&gt;b 循环入口为a 出口为b 先放入入口 再放入出口，直到栈顶的前驱都是a为止，找到循环（类似BFS） DAG优化将所有右边的，意义相同的变量放在DAG一个结点中，以操作符的方法增加边或结点，构造DAG，然后根据图，重新命名变量，重新构造式子，最后根据需要引用什么来赋值 第九章 目标代码生成根据TAC序列生成目标代码先翻译代码，然后尽量使用寄存器。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%81%9A%E9%A2%98%E7%89%88/"},{"title":"JS学习笔记","text":"本文主要为JS的学习笔记，基于MDN的文档，尤其是A_re-introduction_to_JavaScript。 JS学习笔记基础类型JS包含以下类型： Number String Boolean Symbol（ES2015新增） Object Function Array Date RegExp null undefined 数字 在JavaScript中，除了BigInt，不存在整数类型，都是IEEE754的double类型，都是浮点数。 存在NaN Not a Number，也存在Infinity和-Infinity两个特殊值，可以用isFinite来判断。 字符串 都是UTF-16的编码单元的序列，每一个编码单元由16位二进制数来表示，由一个或两个编码单元来表示一个字符。 可以用.length属性（而不是方法）来获取长度。 其他类型 null表示空值，undefined表示未定义未从初始化的值，未初始化的变量就是undefined类型。 JS存在布尔类型，false 0 空字符串“” NaN null undefined都会被转换为false。可以用Boolean显示转换，或在if中隐式转换。 变量存在三种声明变量方法，let const var。 let 声明块级作用域的本地变量，可选地初始化值。 const 声明不可修改的常量，在定义域内可见。 var 使用var在声明的整个函数都是可见的，没有块作用域的限制。 运算符使用==运算符能够自动类型转换，如果不需要则使用===运算符。类似的还有!=和!==运算符。 控制结构if else，while do-while和c语言类似。 for循环可以和c语言类似，但也存在不同的两种循环：for-of和for-in循环。 1234for (let value of array){ //do sth with the value //用于数组值} 12345for (let property in object){ //do sth with the object property //用于遍历对象 //遍历数组会遍历数组所有可枚举属性，如method和name，不要遍历数组} switch可以基于数字或者字符串，记得break。 对象可以简单理解未“名称-值”对，类似字典。在js中，除了核心类型，core object，一切都是对象。名称部分是字符串，值可以是一切数据类型。 创建空对象方法，其中更推荐第二种，因为JSON格式： 12var obj = new Object();var obj = {}; 创建对象实例如下： 123456789var obj = { name: \"carrot\", _for: \"MAX\", details:{ color:\"orange\", size:12 } } 访问方法支持如下： 12obj.details.colorobj[\"details\"][\"size\"] 第二种方法有点在于可以被看做字符串，但可能无法在后期被编译器优化。 创建对象可以用函数，如下所示: 12345678910111213function Person(name,age){ this.name = name; this.age = age;}function makePerson(first, last) { return { first: first, last: last };}var you = new Person('you',25) 数组数组是特殊的对象，以数字为类型名，只能用[ ]访问，包含特殊的属性：length，他比最大索引值大1。 创建数组传统方法如下： 123456var a = new Array();a[0] = \"dog\";//或者var a = [\"dog\",\"cat\"];a[100] = \"fox\";a.length；//101 注意第二种，length的值，他比最大索引值大1。访问不存在的数组索引，会得到undefined。 除了传统for，for-of，还可以用forEach方法.如下所示： | 参数 | 描述 | | :———————————– | :———————————————————– | | function(currentValue, index, arr) | 必需。 数组中每个元素需要调用的函数。currentValue必需。当前元素index可选。当前元素的索引值。arr可选。当前元素所属的数组对象。 | | thisValue | 可选。传递给函数的值一般用 “this” 值。 如果这个参数为空， “undefined” 会传递给 “this” 值 | 调用如下： 12345678var arr = [1, 2, 3, 4, 5];arr.forEach(function (item) { if (item === 3) { return; } console.log(item);}); 增加元素用.push。还有些其他方法，查表就行。 函数没有返回值的函数会返回undefined，调用函数没有提供足够参数会被undefined替代，传入过多参数会被忽略。 函数访问了函数体内为arguments的内部对象，包含所有参数。如下实现avg的方法： 123456789function avg(){ var sum = 0; for (var i = 0, j = arguments.length;i&lt;j;i++){ sum+= arguments[i]; } return sum/ arguments.length;}console.log(avg(1,2,3,4,5,6));//3.5 可以使用剩余参数操作符，来实现上述功能： 123456789101112function avg(...args){ var sum = 0; for (var value of args){ sum += value; } return sum/ arguments.length;}console.log(avg(1,2,3,4,5,6));avg.apply(null, [2, 3, 4, 5]);//使用apply来将数组传为参数列表,第一个参数为被当作this看待的对象。numbers = [2,3,4,5]avg(...numbers)//展开语法 js也可以创建匿名函数。也可以给函数命名来递归调用。 注意this指针的问题，this的上下文可变， 如果在一个对象上使用点或者方括号来访问属性或方法，这个对象就成了 this 。 举例如下： 1234567891011121314151617function makePerson(first, last) { return { first: first, last: last, fullName: function() { return this.first + ' ' + this.last; }, fullNameReversed: function() { return this.last + ', ' + this.first; } }}s = makePerson(\"Simon\", \"Willison\");s.fullName(); // \"Simon Willison\"s.fullNameReversed(); // Willison, Simonvar fullName = s.fullName;fullName(); // undefined undefined .prototype是可以被所有实例共享的对象，当访问某个实例没有定义的属性时候，会检查.prototype里面是否存在。使用如下： 12345678910function Person(first, last) { this.first = first; this.last = last;}Person.prototype.fullName = function() { return this.first + ' ' + this.last;}Person.prototype.fullNameReversed = function() { return this.last + ', ' + this.first;} 对于new，可以有下面的类似实现，注意apply： 1234567function trivialNew(constructor, ...args) { var o = {}; // 创建一个对象 constructor.apply(o, args); return o;}var bill = trivialNew(Person, \"William\", \"Orange\");var bill = new Person(\"William\", \"Orange\"); call函数可以用来设置this，用例如下： 12345678function lastNameCaps() { return this.last.toUpperCase();}var s = new Person(\"Simon\", \"Willison\");lastNameCaps.call(s);// 和以下方式等价s.lastNameCaps = lastNameCaps;s.lastNameCaps(); 内部函数函数内部可以定义函数，，而且可以访问父作用域的变量。如下所示： 123456789function parentFunc() { var a = 1; function nestedFunc() { var b = 4; // parentFunc 无法访问 b return a + b; } return nestedFunc(); // 5} 这种方法可以减少全局变量，避免污染命名空间。 闭包闭包样例如下： 123456789function makeAdder(a) { return function(b) { return a + b; }}var add5 = makeAdder(5);var add20 = makeAdder(20);add5(6); // 5+6=11add20(7); // 20+7=27 当调用makeAdder时创建了作用域对象，带有属性a，然后makeAdder创建一个函数并返回。闭包就是函数与其被创建时候带有的作用域对象的组合。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"React学习笔记","text":"本文主要为react的学习笔记，基于react文档。 React学习笔记JSX简介基本用法：使用{}，在大括号中放入任何有效的JavaScript表达式。 12const name = 'a';const element = &lt;h1&gt;Hello {name}&lt;/h1&gt;; 或者诸如2+2，user.firstName，formatName(user)等表达方法。 JSX本身也是表达式，转为普通的JS函数调用，取值后得到JS对象。可以在if，for中使用JSX，当参数传入，以及返回JSX。 123456function getGreeting(user){ if(user){ return &lt;h1&gt;Hello,{formatName(user)}&lt;/h1&gt;; } return &lt;h1&gt;Hello Stranger&lt;/h1&gt;;} 和html类似，可以使用属性或者在属性值用大括号插入js表达式（注意，不要引号，引号和大括号只有一个）。 1const elem = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt; JSX可以防范XSS注入，会进行转义，所以不用担心。 12const title = response.potentiallyMaliciousInput;const elem = &lt;h1&gt;{title}&lt;/h1&gt;; 在使用中，Babel会将JSX转译为React.createElement()函数调用，转化为基本的React元素。 元素渲染元素是构成React应用的最小砖块，描述了屏幕上看到的内容。开销不大。 将React元素渲染倒根DOM节点，只需要一起传入ReactDOM.render()中： 12const elem = &lt;h1&gt;hello world&lt;/h1&gt;;ReactDOM.render(element,document.getElementById('root')); React元素为不可变对象，更新UI的唯一的方式是创建全新的元素，并且传入ReactDOM.render()： 12345678910function tick(){ const elem = ( &lt;div&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;h2&gt;It is {new Date().toLocaleTimeString()}&lt;/h2&gt; &lt;/div&gt; ); ReactDom.render(elem,document.getElemById('root'));}setInterval(tick, 1000); 但在实践中，只调用以此ReactDOM.render()，注意这点。 ReactDOM会将元素以及子元素与之前的状态进行比较，只进行最小的更新。 组件与Props可以用JS函数或者ES6的类来定义组件，接收props（属性），返回React元素。如下两种方法是等效的： 123456789function Welcome(props){ return &lt;h1&gt;hello {props.name}&lt;/h1&gt;;}class Welcome extends React.Compoent { render(){ return &lt;h1&gt;hello {this.props.name}&lt;/h1&gt;; }} 在使用中，组件可以是react元素： 1const elem = &lt;Welcome name='2'/&gt; 当React元素为用户子当以自建时候，JSX所接收的属性以及子组件会转化为单个对象props传递给组件。 组件名字必须大写字母开头，小写字母被认为是原生DOM标签。 props是只读的，这意味着不改变入参，有着纯函数性质。 State与生命周期state与props类似，但state是私有的，并且完全受控于当前组件。 class组件应当始终使用props参数调用父类的构造函数。在构造函数中，state被赋初值。，使用setState进行更改。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Clock extends React.Component{ //构造函数 初始化 constructor(props){ super(props); this.state = { date: new Date(), }; } //更新函数 tick(){ this.setState({date: new Date()}); } //生命周期方法，在渲染到DOM中后运行 componentDidMount(){ this.timerID = setInterval( ()=&gt;this.tick(),1000 ); } //清除计时器 componentWillUnmount(){ clearInterval(this.timerID); } render(){ return ( &lt;div&gt; &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt; &lt;/div&gt; ); }}function App() { return ( &lt;div&gt; &lt;Clock/&gt; &lt;Clock/&gt; &lt;Clock/&gt; &lt;/div&gt; );}ReactDOM.render( &lt;App /&gt;, document.getElementById('root')); 当&lt;Clock/&gt;被传给ReactDOM后，会调用构造函数，初始化state，之后调用render方法，渲染输出，然后调用ComponentDidMount()方法向浏览器请求设置计时器，每秒调用tick()方法，tick()使用setState()更新，React便会更新DOM。组件被移除后，调用componentWillUnmount()方法卸除计时器。 不要直接修改state，这样不会重新渲染组件。只能在构造函数赋值。 state和props可能异步更新，可以用在setState()中传函数解决，如下所示： 1234// Correctthis.setState((state, props) =&gt; ({ counter: state.counter + props.increment})); state的更新可能被合并。 state可以作为props向下传递。 事件处理事件采用小驼峰方法命名，使用JSX的时候传入函数。必须显式采用preventDefault来阻止默认行为。如下所示： 123456789101112function ActionLink() { function handleClick(e) { e.preventDefault(); console.log('The link was clicked.'); } return ( &lt;a href=\"#\" onClick={handleClick}&gt; Click me &lt;/a&gt; );} e是一个合成事件。 在初始化时候应当绑定this，作为js特性，避免锅。 条件渲染使用if-else或逻辑运算符来控制渲染。 12345678910111213141516render() { const isLoggedIn = this.state.isLoggedIn; let button; if (isLoggedIn) { button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;; } else { button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;; } return ( &lt;div&gt; &lt;Greeting isLoggedIn={isLoggedIn} /&gt; {button} &lt;/div&gt; ); } 如果不想渲染，可以直接返回null。 1234function WarningBanner(props) { if (!props.warn) { return null; } 注意，生命周期方法还是会调用。 列表和key使用map()方法将数组映射成&lt;li&gt;&lt;/li&gt;，记得在映射的时候指定key值，用于辨析元素是否改变，添加，删除。 123456const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li key={number.toString()}&gt; {number} &lt;/li&gt;); key应当独一无二，用于标识。不建议用索引来当key值，但这是默认做法。 key在兄弟结点中必须唯一，但全局不一定唯一。 表单可以用onChange传入函数来控制组件维护的state document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Bomb Lab解析","text":"前置知识： 汇编 GDB Bomb Lab解析前言 Bomb lab是《深入理解计算机系统》配套实验之一。可执行程序包含着“炸弹”，必须输入六个正确的字符串来进行拆弹。字符串必须通过对程序的汇编码进行分析来得到。本文通过分析拆弹流程，对反汇编技术技巧进行总结。 准备 进入CSAPP LAB 官网进行文件的下载。自学者点击self-study handout下载tar压缩包。解压后得到3个文件，Bomb可执行文件，Bomb.c主函数文件，与README。 安装gdb进行反汇编准备。 观察主函数文件，根据函数来打断点。例如在第一阶段主函数有： 1234input = read_line(); phase_1(input); /* Run the phase */phase_defused(); /* Drat! They figured it out! * Let me know how they did it. */ read_line()该行在文件第73行，就可以先命令行执行gdb bomb，再break 73来打断点，在执行run之后，就会在该地方停顿下来，便于调试。常用gdb指令：i r xxx 查看xxx寄存器存储的信息。x xxx查看xxx内存位置的值。该指令可以带参数来改变值的输出格式。disas xxx将xxx函数或者xxx内存位置的函数反汇编。可以查看对应函数的汇编码。 phase_1 第一阶段的炸弹，主函数代码如上所示。对phase_1函数进行反汇编，可以得到如下： 123456780x0000000000400ee0 &lt;+0&gt;: sub $0x8,%rsp0x0000000000400ee4 &lt;+4&gt;: mov $0x402400,%esi0x0000000000400ee9 &lt;+9&gt;: callq 0x401338 &lt;strings_not_equal&gt;0x0000000000400eee &lt;+14&gt;: test %eax,%eax0x0000000000400ef0 &lt;+16&gt;: je 0x400ef7 &lt;phase_1+23&gt;0x0000000000400ef2 &lt;+18&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000400ef7 &lt;+23&gt;: add $0x8,%rsp0x0000000000400efb &lt;+27&gt;: retq rsp为栈顶指针，第一行减去栈顶指针是为函数留出栈空间，可以忽略。 第二行mov了一行数据，并且后面调用了strings_not_equal函数。eax为函数返回值，test函数用于检测返回值是否为0。后面je指令为0则跳转到+23即add行，不为0则爆炸。 那么我们猜测0x402400位置存放了字符串。当输入字符串和该字符串相同则不爆炸。通过x指令可以看出该内存位置为： 12(gdb) x /s 0x4024000x402400: \"Border relations with Canada have never been better.\" 输入该字符串，即可拆弹成功。 phase_2 同上，对phase_2反汇编可以得到如下： 123456789101112131415161718192021222324252627Dump of assembler code for function phase_2: 0x0000000000400efc &lt;+0&gt;: push %rbp 0x0000000000400efd &lt;+1&gt;: push %rbx 0x0000000000400efe &lt;+2&gt;: sub $0x28,%rsp 0x0000000000400f02 &lt;+6&gt;: mov %rsp,%rsi 0x0000000000400f05 &lt;+9&gt;: callq 0x40145c &lt;read_six_numbers&gt; 0x0000000000400f0a &lt;+14&gt;: cmpl $0x1,(%rsp) 0x0000000000400f0e &lt;+18&gt;: je 0x400f30 &lt;phase_2+52&gt; 0x0000000000400f10 &lt;+20&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000400f15 &lt;+25&gt;: jmp 0x400f30 &lt;phase_2+52&gt; 0x0000000000400f17 &lt;+27&gt;: mov -0x4(%rbx),%eax 0x0000000000400f1a &lt;+30&gt;: add %eax,%eax 0x0000000000400f1c &lt;+32&gt;: cmp %eax,(%rbx) 0x0000000000400f1e &lt;+34&gt;: je 0x400f25 &lt;phase_2+41&gt; 0x0000000000400f20 &lt;+36&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000400f25 &lt;+41&gt;: add $0x4,%rbx 0x0000000000400f29 &lt;+45&gt;: cmp %rbp,%rbx 0x0000000000400f2c &lt;+48&gt;: jne 0x400f17 &lt;phase_2+27&gt; 0x0000000000400f2e &lt;+50&gt;: jmp 0x400f3c &lt;phase_2+64&gt; 0x0000000000400f30 &lt;+52&gt;: lea 0x4(%rsp),%rbx 0x0000000000400f35 &lt;+57&gt;: lea 0x18(%rsp),%rbp 0x0000000000400f3a &lt;+62&gt;: jmp 0x400f17 &lt;phase_2+27&gt; 0x0000000000400f3c &lt;+64&gt;: add $0x28,%rsp 0x0000000000400f40 &lt;+68&gt;: pop %rbx 0x0000000000400f41 &lt;+69&gt;: pop %rbp 0x0000000000400f42 &lt;+70&gt;: retq End of assembler dump. 汇编码较上个阶段明显变长，这里分段解析。 可以看到首先调用了read_six_numbers来进行数据的读取。可以猜测并证实该函数作用为读取6个数，并放入栈中。 第一个引爆出现在cmpl 0x1 (rsp)后。即将栈顶元素与1相比较，不相等则爆炸。那么可以得到，第一个数为1。 在jmp之后将0x4(%rsp)与0x18(%rsp)存放了起来。根据一个数占4个字节可以得出，前者为存放下一个数值到rbx，后者为六个数的边界。 再次jmp之后可以看出，eax存放了rbx的前一个数，并且乘以2了。cmp即将前一个数×2与本数字相比较，不相等则爆炸。那么可以得到后一个数是前一个数的2倍的规律。 后面的代码不言而喻，依次进行数的比较，最后边界检查，到达边界则退出。那么可以得到拆弹代码： 11 2 4 8 16 32 phase_3 首先看代码： 1234567891011121314151617181920212223242526272829303132333435360x0000000000400f43 &lt;+0&gt;: sub $0x18,%rsp0x0000000000400f47 &lt;+4&gt;: lea 0xc(%rsp),%rcx0x0000000000400f4c &lt;+9&gt;: lea 0x8(%rsp),%rdx0x0000000000400f51 &lt;+14&gt;: mov $0x4025cf,%esi0x0000000000400f56 &lt;+19&gt;: mov $0x0,%eax0x0000000000400f5b &lt;+24&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000400f60 &lt;+29&gt;: cmp $0x1,%eax0x0000000000400f63 &lt;+32&gt;: jg 0x400f6a &lt;phase_3+39&gt;0x0000000000400f65 &lt;+34&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000400f6a &lt;+39&gt;: cmpl $0x7,0x8(%rsp)0x0000000000400f6f &lt;+44&gt;: ja 0x400fad &lt;phase_3+106&gt;0x0000000000400f71 &lt;+46&gt;: mov 0x8(%rsp),%eax0x0000000000400f75 &lt;+50&gt;: jmpq *0x402470(,%rax,8)0x0000000000400f7c &lt;+57&gt;: mov $0xcf,%eax0x0000000000400f81 &lt;+62&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f83 &lt;+64&gt;: mov $0x2c3,%eax0x0000000000400f88 &lt;+69&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f8a &lt;+71&gt;: mov $0x100,%eax0x0000000000400f8f &lt;+76&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f91 &lt;+78&gt;: mov $0x185,%eax0x0000000000400f96 &lt;+83&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f98 &lt;+85&gt;: mov $0xce,%eax0x0000000000400f9d &lt;+90&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f9f &lt;+92&gt;: mov $0x2aa,%eax0x0000000000400fa4 &lt;+97&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400fa6 &lt;+99&gt;: mov $0x147,%eax0x0000000000400fab &lt;+104&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400fad &lt;+106&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000400fb2 &lt;+111&gt;: mov $0x0,%eax0x0000000000400fb7 &lt;+116&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400fb9 &lt;+118&gt;: mov $0x137,%eax0x0000000000400fbe &lt;+123&gt;: cmp 0xc(%rsp),%eax0x0000000000400fc2 &lt;+127&gt;: je 0x400fc9 &lt;phase_3+134&gt;0x0000000000400fc4 &lt;+129&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000400fc9 &lt;+134&gt;: add $0x18,%rsp0x0000000000400fcd &lt;+138&gt;: retq 代码依旧很长，分部分进行解析。 最开始调用了sscanf，sscanf的字符串可以通过前面的mov指令猜出，位于0x4025cf。查看可以得知，该字符串为：“%d %d” 读取了两个数，加上前面两个lea指令，可以猜出数存放在0x8(rsp)和0xc(rsp)。 第一个引爆在cmp 0x1 eax，可以得知这是根据sscanf返回值来爆炸。当sscanf匹配数字大于1则不爆炸。 跳转后进行了cmpl $0x7,0x8(%rsp)，即第一个值和7进行比较。大于则爆炸。即第一个输入值需要小于等于7。 下一个将第一个值存入eax，并使用jmp跳转。jmpq star0x402470(,%rax,8)。我们可以先看看0x402470存放的是什么： 12(gdb) print *(0x402470)$1 = 4198268 4798268 = 0x400f7c，即下一行。那么根据地址可以得到，该跳转是利用第一个输入的值作为索引进行跳转，跳到对应指令。 下面结构都是类似的，将一个常数放入eax，并且跳转到与0xc(rsp)进行比较。相等则不会爆炸。以f7c行举例，对应值为0xcf=207那么可以得到一个解为： 10 207 phase_4 同上，看代码： 123456789101112131415161718192021220x000000000040100c &lt;+0&gt;: sub $0x18,%rsp0x0000000000401010 &lt;+4&gt;: lea 0xc(%rsp),%rcx0x0000000000401015 &lt;+9&gt;: lea 0x8(%rsp),%rdx0x000000000040101a &lt;+14&gt;: mov $0x4025cf,%esi0x000000000040101f &lt;+19&gt;: mov $0x0,%eax0x0000000000401024 &lt;+24&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000401029 &lt;+29&gt;: cmp $0x2,%eax0x000000000040102c &lt;+32&gt;: jne 0x401035 &lt;phase_4+41&gt;0x000000000040102e &lt;+34&gt;: cmpl $0xe,0x8(%rsp)0x0000000000401033 &lt;+39&gt;: jbe 0x40103a &lt;phase_4+46&gt;0x0000000000401035 &lt;+41&gt;: callq 0x40143a &lt;explode_bomb&gt;0x000000000040103a &lt;+46&gt;: mov $0xe,%edx0x000000000040103f &lt;+51&gt;: mov $0x0,%esi0x0000000000401044 &lt;+56&gt;: mov 0x8(%rsp),%edi0x0000000000401048 &lt;+60&gt;: callq 0x400fce &lt;func4&gt;0x000000000040104d &lt;+65&gt;: test %eax,%eax0x000000000040104f &lt;+67&gt;: jne 0x401058 &lt;phase_4+76&gt;0x0000000000401051 &lt;+69&gt;: cmpl $0x0,0xc(%rsp)0x0000000000401056 &lt;+74&gt;: je 0x40105d &lt;phase_4+81&gt;0x0000000000401058 &lt;+76&gt;: callq 0x40143a &lt;explode_bomb&gt;0x000000000040105d &lt;+81&gt;: add $0x18,%rsp0x0000000000401061 &lt;+85&gt;: retq sscanf与上个阶段一样，比较返回值并且跳转。同时将第一个数与0xe进行比较，可以得到不大于0xe才能不爆炸。 然后将0xe，0x0和数组第一个值放入相应寄存器，调用func4，最后检查返回值是否为0。可以看出需要继续解析func4。func4代码如下： 123456789101112131415161718192021220x0000000000400fce &lt;+0&gt;: sub $0x8,%rsp0x0000000000400fd2 &lt;+4&gt;: mov %edx,%eax0x0000000000400fd4 &lt;+6&gt;: sub %esi,%eax0x0000000000400fd6 &lt;+8&gt;: mov %eax,%ecx0x0000000000400fd8 &lt;+10&gt;: shr $0x1f,%ecx0x0000000000400fdb &lt;+13&gt;: add %ecx,%eax0x0000000000400fdd &lt;+15&gt;: sar %eax0x0000000000400fdf &lt;+17&gt;: lea (%rax,%rsi,1),%ecx0x0000000000400fe2 &lt;+20&gt;: cmp %edi,%ecx0x0000000000400fe4 &lt;+22&gt;: jle 0x400ff2 &lt;func4+36&gt;0x0000000000400fe6 &lt;+24&gt;: lea -0x1(%rcx),%edx0x0000000000400fe9 &lt;+27&gt;: callq 0x400fce &lt;func4&gt;0x0000000000400fee &lt;+32&gt;: add %eax,%eax0x0000000000400ff0 &lt;+34&gt;: jmp 0x401007 &lt;func4+57&gt;0x0000000000400ff2 &lt;+36&gt;: mov $0x0,%eax0x0000000000400ff7 &lt;+41&gt;: cmp %edi,%ecx0x0000000000400ff9 &lt;+43&gt;: jge 0x401007 &lt;func4+57&gt;0x0000000000400ffb &lt;+45&gt;: lea 0x1(%rcx),%esi0x0000000000400ffe &lt;+48&gt;: callq 0x400fce &lt;func4&gt;0x0000000000401003 &lt;+53&gt;: lea 0x1(%rax,%rax,1),%eax0x0000000000401007 &lt;+57&gt;: add $0x8,%rsp0x000000000040100b &lt;+61&gt;: retq func4代码使用了递归，不是很容易理解，这里我对着每一行翻译了一下，写了个c语言程序，代码如下： 1234567891011121314151617181920212223242526int func4(int edx,int esi,int edi){ int eax = edx; eax-=esi; int ecx = eax; ecx=(unsigned int)ecx&gt;&gt;0x1f; eax+=ecx; eax&gt;&gt;=1; ecx = esi*1+eax; if(ecx&lt;=edi) { eax = 0; if(ecx&gt;=edi) { return eax; }else{ esi = ecx+1; eax = 2*func4(edx,esi,edi)+1; } } else{ edx = ecx-1; eax = 2* func4(edx,esi,edi); } return eax;} 由于是一行一行翻译的，理解不困难。第一个数必定小于等于11，那么可以直接带入值遍历进行计算，实践得出返回值为0的情况。当输入为0 1 3 7时候返回值为0。 接下来代码不需要过多解释，即验证第二个数是不是为0。那么可以得到一个解： 10 0 phase_5 代码如下： 12345678910111213141516171819202122232425262728293031323334353637380x0000000000401062 &lt;+0&gt;: push %rbx0x0000000000401063 &lt;+1&gt;: sub $0x20,%rsp0x0000000000401067 &lt;+5&gt;: mov %rdi,%rbx0x000000000040106a &lt;+8&gt;: mov %fs:0x28,%rax0x0000000000401073 &lt;+17&gt;: mov %rax,0x18(%rsp)0x0000000000401078 &lt;+22&gt;: xor %eax,%eax0x000000000040107a &lt;+24&gt;: callq 0x40131b &lt;string_length&gt;0x000000000040107f &lt;+29&gt;: cmp $0x6,%eax0x0000000000401082 &lt;+32&gt;: je 0x4010d2 &lt;phase_5+112&gt;0x0000000000401084 &lt;+34&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000401089 &lt;+39&gt;: jmp 0x4010d2 &lt;phase_5+112&gt;0x000000000040108b &lt;+41&gt;: movzbl (%rbx,%rax,1),%ecx0x000000000040108f &lt;+45&gt;: mov %cl,(%rsp)0x0000000000401092 &lt;+48&gt;: mov (%rsp),%rdx0x0000000000401096 &lt;+52&gt;: and $0xf,%edx0x0000000000401099 &lt;+55&gt;: movzbl 0x4024b0(%rdx),%edx0x00000000004010a0 &lt;+62&gt;: mov %dl,0x10(%rsp,%rax,1)0x00000000004010a4 &lt;+66&gt;: add $0x1,%rax0x00000000004010a8 &lt;+70&gt;: cmp $0x6,%rax0x00000000004010ac &lt;+74&gt;: jne 0x40108b &lt;phase_5+41&gt;0x00000000004010ae &lt;+76&gt;: movb $0x0,0x16(%rsp)0x00000000004010b3 &lt;+81&gt;: mov $0x40245e,%esi0x00000000004010b8 &lt;+86&gt;: lea 0x10(%rsp),%rdi0x00000000004010bd &lt;+91&gt;: callq 0x401338 &lt;strings_not_equal&gt;0x00000000004010c2 &lt;+96&gt;: test %eax,%eax0x00000000004010c4 &lt;+98&gt;: je 0x4010d9 &lt;phase_5+119&gt;0x00000000004010c6 &lt;+100&gt;: callq 0x40143a &lt;explode_bomb&gt;0x00000000004010cb &lt;+105&gt;: nopl 0x0(%rax,%rax,1)0x00000000004010d0 &lt;+110&gt;: jmp 0x4010d9 &lt;phase_5+119&gt;0x00000000004010d2 &lt;+112&gt;: mov $0x0,%eax0x00000000004010d7 &lt;+117&gt;: jmp 0x40108b &lt;phase_5+41&gt;0x00000000004010d9 &lt;+119&gt;: mov 0x18(%rsp),%rax0x00000000004010de &lt;+124&gt;: xor %fs:0x28,%rax0x00000000004010e7 &lt;+133&gt;: je 0x4010ee &lt;phase_5+140&gt;0x00000000004010e9 &lt;+135&gt;: callq 0x400b30 &lt;__stack_chk_fail@plt&gt;0x00000000004010ee &lt;+140&gt;: add $0x20,%rsp0x00000000004010f2 &lt;+144&gt;: pop %rbx0x00000000004010f3 &lt;+145&gt;: retq 分步骤来进行解析。首先可以看到调用了string_length，后面检测了输入长度是否为6。即输入长度为6的字符串。 经过一番跳转，到达了movzbl (%rbx,%rax,1),%ecx。经过查看可以得知rbx存放的是输入的字符串，rax为索引，最开始为0，然后经过传输后，到达了and 0xf edx。即将该字符ascii码与0xf取与，即取后四位。 然后movzbl 0x4024b0(%rdx),%edx，即以and后的值索引并覆盖该寄存器，在该内存位置可以看到字符串为： 12(gdb) print (char*) 0x4024b0$2 = 0x4024b0 &lt;array&gt; \"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\" 覆盖寄存器后另一个mov，即将该字符放入栈。在之后指进行六次循环，得到新的六个字符。 在得到新字符串后又调用了string_not_equal，而目标字符串则在0x40245e，查看可以得知： 12(gdb) print (char*) 0x40245e$3 = 0x40245e \"flyers\" 那么该输入的字符串，后四位所形成的索引需要构成flyers新字符串。以0开始计数，flyer分别在原字符串的位置是9 15 14 5 6 7 。 经过查表可以得知，要使ascii后四位等于上述数列，一个可行的答案为： 1)/.%&amp;' phase_6 最长以及六个炸弹中最难的一个。我写了一套完整的注释来方便理解。如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091100x00000000004010f4 &lt;+0&gt;: push %r140x00000000004010f6 &lt;+2&gt;: push %r130x00000000004010f8 &lt;+4&gt;: push %r120x00000000004010fa &lt;+6&gt;: push %rbp0x00000000004010fb &lt;+7&gt;: push %rbx0x00000000004010fc &lt;+8&gt;: sub $0x50,%rsp0x0000000000401100 &lt;+12&gt;: mov %rsp,%r130x0000000000401103 &lt;+15&gt;: mov %rsp,%rsi0x0000000000401106 &lt;+18&gt;: callq 0x40145c &lt;read_six_numbers&gt;0x000000000040110b &lt;+23&gt;: mov %rsp,%r14 栈顶放到r140x000000000040110e &lt;+26&gt;: mov $0x0,%r12d 0放到r120x0000000000401114 &lt;+32&gt;: mov %r13,%rbp r13放到rbp0x0000000000401117 &lt;+35&gt;: mov 0x0(%r13),%eax *r13放到eax0x000000000040111b &lt;+39&gt;: sub $0x1,%eax eax减10x000000000040111e &lt;+42&gt;: cmp $0x5,%eax eax和5比大小0x0000000000401121 &lt;+45&gt;: jbe 0x401128 &lt;phase_6+52&gt; eax小于等于5则不炸。0x0000000000401123 &lt;+47&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000401128 &lt;+52&gt;: add $0x1,%r12d r12加一0x000000000040112c &lt;+56&gt;: cmp $0x6,%r12d 0x0000000000401130 &lt;+60&gt;: je 0x401153 &lt;phase_6+95&gt; r12等于6则跳到95 边界检查0x0000000000401132 &lt;+62&gt;: mov %r12d,%ebx r12放进ebx0x0000000000401135 &lt;+65&gt;: movslq %ebx,%rax ebx放进rax0x0000000000401138 &lt;+68&gt;: mov (%rsp,%rax,4),%eax *（4乘rax+rsp）放进eax/第ebx个数放进eax0x000000000040113b &lt;+71&gt;: cmp %eax,0x0(%rbp) 边界检查0x000000000040113e &lt;+74&gt;: jne 0x401145 &lt;phase_6+81&gt; 第ebx个数与第r13存放的数不相等则跳过0x0000000000401140 &lt;+76&gt;: callq 0x40143a &lt;explode_bomb&gt;0x0000000000401145 &lt;+81&gt;: add $0x1,%ebx ebx加一0x0000000000401148 &lt;+84&gt;: cmp $0x5,%ebx 比较ebx和50x000000000040114b &lt;+87&gt;: jle 0x401135 &lt;phase_6+65&gt; 小于等于则跳到650x000000000040114d &lt;+89&gt;: add $0x4,%r13 r13加40x0000000000401151 &lt;+93&gt;: jmp 0x401114 &lt;phase_6+32&gt; 跳到32ebx为内层循环变量j。r12为外层循环变量i。for(i=0;i&lt;=5;i++){ if((*r13)-1&lt;=5) not explode; for(j=i+1;j&lt;=5;j++) { if((*r13)!=(*(rsp+j))) not explode; } r13++;}0x0000000000401153 &lt;+95&gt;: lea 0x18(%rsp),%rsi 数组的末尾放进rsp放进rsi0x0000000000401158 &lt;+100&gt;: mov %r14,%rax r14放进rax 数组开头放入rax0x000000000040115b &lt;+103&gt;: mov $0x7,%ecx 0x7放进ecx0x0000000000401160 &lt;+108&gt;: mov %ecx,%edx ecx放进edx0x0000000000401162 &lt;+110&gt;: sub (%rax),%edx edx减去rax值0x0000000000401164 &lt;+112&gt;: mov %edx,(%rax) edx值存入rax值0x0000000000401166 &lt;+114&gt;: add $0x4,%rax rax地址加40x000000000040116a &lt;+118&gt;: cmp %rsi,%rax 比较rax和rsi0x000000000040116d &lt;+121&gt;: jne 0x401160 &lt;phase_6+108&gt; 不等于则跳回108a[i] = 7-a[i]0x000000000040116f &lt;+123&gt;: mov $0x0,%esi esi归零0x0000000000401174 &lt;+128&gt;: jmp 0x401197 &lt;phase_6+163&gt; 跳到1630x0000000000401176 &lt;+130&gt;: mov 0x8(%rdx),%rdx edx+8的值放进edx0x000000000040117a &lt;+134&gt;: add $0x1,%eax eax+10x000000000040117d &lt;+137&gt;: cmp %ecx,%eax 比较ecx和eax0x000000000040117f &lt;+139&gt;: jne 0x401176 &lt;phase_6+130&gt; 不等于则跳回1300x0000000000401181 &lt;+141&gt;: jmp 0x401188 &lt;phase_6+148&gt; 跳到1480x0000000000401183 &lt;+143&gt;: mov $0x6032d0,%edx 0x6032d0放到edx 0x0000000000401188 &lt;+148&gt;: mov %rdx,0x20(%rsp,%rsi,2) edx放进*(rsp+2*rsi)+0x200x000000000040118d &lt;+153&gt;: add $0x4,%rsi rsi+40x0000000000401191 &lt;+157&gt;: cmp $0x18,%rsi 边界检查0x0000000000401195 &lt;+161&gt;: je 0x4011ab &lt;phase_6+183&gt; 跳到1830x0000000000401197 &lt;+163&gt;: mov (%rsp,%rsi,1),%ecx 把rsp+rsi放进ecx rsi为0 4 8 16 32 640x000000000040119a &lt;+166&gt;: cmp $0x1,%ecx 比较ecx和1 比较数组值0x000000000040119d &lt;+169&gt;: jle 0x401183 &lt;phase_6+143&gt; 数组值小于等于1则跳回1430x000000000040119f &lt;+171&gt;: mov $0x1,%eax eax放成10x00000000004011a4 &lt;+176&gt;: mov $0x6032d0,%edx 0x6032d0放进edx0x00000000004011a9 &lt;+181&gt;: jmp 0x401176 &lt;phase_6+130&gt; 跳到130130-139 循环使得edx = 0x6032d0+8*a[i]然后放入*(rsp+2*rsi+0x20) rsi为数组的索引 0x00000000004011ab &lt;+183&gt;: mov 0x20(%rsp),%rbx rsp+20放进rbx0x00000000004011b0 &lt;+188&gt;: lea 0x28(%rsp),%rax rsp+28放进rax0x00000000004011b5 &lt;+193&gt;: lea 0x50(%rsp),%rsi rsp+50放进rsi0x00000000004011ba &lt;+198&gt;: mov %rbx,%rcx rbx放进rcx0x00000000004011bd &lt;+201&gt;: mov (%rax),%rdx rax值放入rdx0x00000000004011c0 &lt;+204&gt;: mov %rdx,0x8(%rcx) rdx放入rcx值+80x00000000004011c4 &lt;+208&gt;: add $0x8,%rax rax+80x00000000004011c8 &lt;+212&gt;: cmp %rsi,%rax 比较rsi和rax 边界检查0x00000000004011cb &lt;+215&gt;: je 0x4011d2 &lt;phase_6+222&gt; 相等则跳入2220x00000000004011cd &lt;+217&gt;: mov %rdx,%rcx rdx放进rcx0x00000000004011d0 &lt;+220&gt;: jmp 0x4011bd &lt;phase_6+201&gt; 跳回2010x00000000004011d2 &lt;+222&gt;: movq $0x0,0x8(%rdx) rdx+8置零类似于链表操作。rdx = *rax *(rcx+8) = *rax rax+=8 rcx = rdx 按照数组的顺序重新连接链表。0x00000000004011da &lt;+230&gt;: mov $0x5,%ebp ebp放50x00000000004011df &lt;+235&gt;: mov 0x8(%rbx),%rax rbx+8值放进rax0x00000000004011e3 &lt;+239&gt;: mov (%rax),%eax rax值放进eax0x00000000004011e5 &lt;+241&gt;: cmp %eax,(%rbx) 比较eax和rbx值0x00000000004011e7 &lt;+243&gt;: jge 0x4011ee &lt;phase_6+250&gt; rbx值大于等于eax则跳到2500x00000000004011e9 &lt;+245&gt;: callq 0x40143a &lt;explode_bomb&gt;0x00000000004011ee &lt;+250&gt;: mov 0x8(%rbx),%rbx rbx+8值放入rbx0x00000000004011f2 &lt;+254&gt;: sub $0x1,%ebp ebp减去10x00000000004011f5 &lt;+257&gt;: jne 0x4011df &lt;phase_6+235&gt; 如果不为0则跳回235 遍历链表，保证链表的遍历顺序为数组的降序。0x00000000004011f7 &lt;+259&gt;: add $0x50,%rsp0x00000000004011fb &lt;+263&gt;: pop %rbx0x00000000004011fc &lt;+264&gt;: pop %rbp0x00000000004011fd &lt;+265&gt;: pop %r120x00000000004011ff &lt;+267&gt;: pop %r130x0000000000401201 &lt;+269&gt;: pop %r140x0000000000401203 &lt;+271&gt;: retq 具体注释如上，该阶段使用了类似于链表的操作。通过输入六个数字，然后使用7减去每个数字，再将数字的索引顺序匹配为链表的连接顺序，再观察链表里的值实现降序排列。 再本次中，链表的值如下所示： 12345678(gdb) x /12xg 0x6032d00x6032d0 &lt;node1&gt;: 0x000000010000014c 0x00000000006032e00x6032e0 &lt;node2&gt;: 0x00000002000000a8 0x00000000006032f00x6032f0 &lt;node3&gt;: 0x000000030000039c 0x00000000006033000x603300 &lt;node4&gt;: 0x00000004000002b3 0x00000000006033100x603310 &lt;node5&gt;: 0x00000005000001dd 0x00000000006033200x603320 &lt;node6&gt;: 0x00000006000001bb 0x0000000000000000 由于使用32位寄存器，只用看后八位进行排序。39c&gt;2b3&gt;1dd&gt;1bb&gt;14c&gt;0a8 即为3 4 5 6 1 2 。在进行7-之后可以得到答案： 14 3 2 1 6 5 隐藏关卡 实在写不动了，据说是个二叉树。我放弃了。 总结与心得 本次实验主要是熟悉了汇编语言以及反汇编流程，熟悉了gdb的使用。最开始做lab的时候，我对汇编完全没有任何了解，从最开始的每一行都需要百度，到最后理解了每一行的含义，我确实了解了很多计算机相关知识。总而言之我自己认为这次收获还是很大的。有人说汇编是最后的底线，我之前一直觉得汇编对于我这种写高级语言的没什么关系，毕竟编译器优化后的汇编本来就很难读得懂，但现在觉得只要默认不优化的情况下，多了一种找bug的方法。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/bomb-lab%E8%A7%A3%E6%9E%90/"},{"title":"2020 6.824 lab1解析","text":"前置知识： go linux 2020 6.824 lab1解析前言 本系列主要是对mit课程6.824的lab进行解析，包括部分原理的讲解以及代码的实现。主要使用go来进行编写。本文讲解的是lab1，根据给定的代码框架来实现MapReduce结构。 介绍 6.824是mit的分布式系统课程，而该课程的实验也就是lab目的为通过给定的代码框架来实现通用的分布式系统。该课程lab在2020年进行了部分更新，例如本次的lab1就进行了大改，与前几年几乎完全不同，因此以往网络上的各路教程也就过时了。详细课程资源可以到6.824官方网站进行查看。 本文的lab1实现的是MapReduce架构，作为谷歌在2003年发表的论文，为现在的分布式计算思想提供了很明确的方向。它继承于函数式编程的思想，并且在谷歌内部真正进行了实现与运用。本文便根据给定的代码框架以及论文思想，来实现这么一个模型。 原理简介 MapReduce如上文所说，源于函数式编程思想，简单来说Map对应“映射”，Reduce对应“归约”，前者将数据切分从而映射到键值对（key-value对）组，后者将键值对组进行整理归纳，并整合到输出文件。该算法的优势在于优秀的并行化，可以使用多台计算机来应对计算规模的增加，从而节省时间。 但在具体原理上，我们还需要阅读谷歌发表的那篇论文从而了解更多细节。该论文写的很好，在实现细节不理解的情况下建议多读几遍。但在这里还是简述一下论文的观点。 论文中提供了编程模型的实现：通过master机器来统筹工作，通过worker机器来进行具体的map或者reduce工作。master给worker分配map或者reduce工作，worker接收到map工作时便读取对应数据，执行map工作，将map完成后的键值对组存于磁盘，并且通知master完成工作。当master了解到所有map工作完成后，便通知worker进行reduce工作。worker接收到指令后便读取磁盘上的对应键值对。然后通常先对键值对组进行排序，然后进行reduce工作，并存于输出文件中。同样，在master了解到所有文件已经reduce完成后便可以进行退出。 下面本文的实验也将基于上述模型来实现。 准备工作 进入lab1官网，官网的准备工作说的相当清楚。要准备linux环境，go环境，然后下载实验文件。这里需要一些基本的linux知识，不过官网已经将步骤给的相当清楚了。再次不过多赘述。 实验目标与流程 从官网可以看到，lab1的实验目标是完成mr文件夹中的master.go rpc.go worker.go三个文件，并且在main文件夹中通过mrmaster.go来创建一个master，通过执行多次mrworker.go来创建多个worker来运行。同时实验也给定了一个串行的结果正确的文件mrsequential.go，可以来参考以及改bug。在实验最后，我们需要对写好的文件进行测试。文件给了我们一个shell脚本test-mr.sh，该脚本会执行真正的应用程序以及给定各种实验场景，我们的目标是通过该测试。 在mr文件夹中，rpc.go负责master与worker之间的通信。这里可能需要rpc的一些知识来理解，但在本次实验中可以简单理解为worker以rpc.go内的结构体为参数，调用master.go文件中的函数来与master进行通讯。在master和worker的文件内也给定了样例，并且在worker内部还封装好了call函数，即使不理解rpc也可以学样例编写程序。 在worker文件中，可以看到Worker的参数为两个func，即map和reduce两个函数，这是在创建worker时候就给定的，那么我们可以想到在worker函数内部，我们需要主动找master要工作。同时在完成工作后，我们也需要找master汇报工作，同时接受下一份工作，直到master让你休假（但休假完还是要上班）或者master卷款跑路。（太资本主义了） 在master文件中，可以看到初始化master时候给定了文件名序列以及reduce后文件的数量。毫无疑问，我们先要把这些存起来。然后根据上述worker的工作流程，master的工作也可以确认：接受worker的工作请求，查看手里有啥空闲的工作，有map就给map，map活都接完但是没干完的就让员工先休假，等到map活干完再来分配reduce工作。reduce工作都干完了就可以卷款跑路（调用Done函数return true）了。（太资本主义了） 工作流程基本如上，虽然很形象，但接下来，我们需要具体用代码去实现它。 RPC.go master与worker要通过rpc进行通讯，那么我们先来规范好通讯协议，知道员工该告诉老板啥，老板该告诉员工啥，才能更好地展开工作。在这里，我们将worker发给master的数据称为请求，反过来称为相应。 首先，无论是map工作还是reduce工作，无论是分配工作还是汇报工作，都要通过文件来进行。master需要告诉worker去读取哪个文件，worker需要告诉master哪个文件已经完成了。因此在请求和相应二者中，可以确定的一项是filename。数据类型这里选用的是string。 其次，除了工作地点也就是文件名之外，还要汇报工作类型，是map还是reduce。所以无论是请求还是相应，都需要有表示工作类型的数据。这里我在请求中使用Status进行表示，同时也可以表示worker自己完成了工作还是在休假；响应中使用JobName进行表示。数据类型均为string。或许有些英语不准确但问题不大。 我们可以得到以下代码： 1234567891011type RPCArgs struct { Status string Filename string}type RPCReplys struct { JobName string Filename string NReduce int NMap int} 这里args为请求，replys为响应。在响应中多了两项，是为了worker更好地工作而传送的，在介绍worker时候会进行介绍。 master 明确沟通协议后，master的工作就很明确了：存储各种工作状态，分配工作，接受汇报工作并且改变工作的状态，并在所有工作结束自己退出。我们先根据上述描述了解master需要存什么。 首先，MakeMaster参数中的filenames和nReduce肯定是要存的，毫无疑问。 其次，需要存储各个工作的状态。在这里可以使用数组来表示，0表示未分配，1表示工作中，2表示已完成。这样做的另一个好处是在工作时间过长的时候可以重新把该工作设置为未分配，从而达到容错的效果。这里需要两个数组，mapTasks []int 和 reduceTasks []int。 第三，标志工作完成的标识符。这里用的mapDone和reduceDone两个int来标识。这也是确认工作完成来切换到reduce工作的标志。于是我们可以得到以下声明： 12345678910type Master struct { // Your definitions here. filenames []string mapTasks []int32 reduceTasks []int32 nReduce int nMap int mapDone int reduceDone int} 可以看到多了个nMap，也是为了worker便于工作而存放的。 MakeMaster函数便不用多说，进行初始化即可。 确定完协议后，就需要真正的函数来进行通信处理。这里使用的函数我命名为GetJob，接受参数如下： 1func (m *Master) GetJob(args *RPCArgs, reply *RPCReplys) error 确定协议后就需要做事了。首先我们来接受worker的汇报工作，如果他完成的工作叫map，则找到他完成的工作，划掉工作。具体代码如下： 12345678if args.Status == \"map\" { for index, value := range m.filenames { if args.Filename == value &amp;&amp; atomic.LoadInt32(&amp;m.mapTasks[index]) == 1 { atomic.StoreInt32(&amp;m.mapTasks[index], 2) break } }} 横向有点长，主要是因为会有多个线程同时访问数组，要保证数组操作的原子性，从而调用函数。reduce代码基本一样，不过多赘述。 接收汇报后便要先检测工作干完没有，干完了就可以直接结束。没干完就继续发配。这里检测是否完成与终止master进程的函数一样，调用了Done函数。 Done函数遍历工作池，如果所有工作都做完了，则删掉MapReduce的中间产生的键值对组，返回true值。否则返回 false。这里写的麻烦了点，而且删掉中间产物也不应该由master来做，在shell测试脚本中由shell来清空了中间产物。但最终可以过测试就行。 12345678910111213141516171819202122232425262728293031func (m *Master) Done() bool { ret := false m.mapDone = 1 m.reduceDone = 1 for _, value := range m.mapTasks { if value != 2 { m.mapDone = 0 break } } for _, value := range m.reduceTasks { if value != 2 { m.reduceDone = 0 break } } if m.mapDone == 1 &amp;&amp; m.reduceDone == 1 { ret = true fmt.Println(\"Done jobs\") for i := 0; i &lt; m.nReduce; i++ { for j := 0; j &lt; m.nMap; j++ { f, err := os.OpenFile(\"mr-\"+strconv.Itoa(i)+\"-\"+strconv.Itoa(j), os.O_RDWR|os.O_TRUNC, 0666) if err != nil { fmt.Println(err) } f.Close() } }//删掉中间产物 } return ret} 在结束条件确认之后，身为master便可以尽情发配工作了。发配工作流程是，检测第一个未分配工作，如果有则分配下去并且开始计时，计时结束如果未完成说明遭受了意外完成不了，重新变为未分配。如果完成了则一切安好。如果所有工作都分配了但有的未完成，便可以先叫员工休假。代码如下： 1234567891011121314151617181920if m.mapDone == 0 { index := m.getMapIndex()//手动封装的函数，找到第一个为0的数组索引，否则返回-1 if index != -1 { reply.JobName = \"map\" reply.Filename = m.filenames[index] reply.NMap = index//在map时候传送index数，在reduce时候传输nmap总数，便于中间文件的命名 atomic.StoreInt32(&amp;m.mapTasks[index], 1) go func() { time.Sleep(time.Duration(10) * time.Second) if atomic.LoadInt32(&amp;m.mapTasks[index]) != 2 { atomic.StoreInt32(&amp;m.mapTasks[index], 0) } }()//计时器，完成了则安好，未完成则改成未分配 } else { reply.JobName = \"free\"//休假 reply.Filename = \"\" } } reduce同理，不过多赘述。至此，我们完成了master与worker所需要通信的所有东西……除了函数返回值。我们需要返回一个error类型。我选择的是干脆返回一个nil。 不要忘了nMap和nReduce两个通信参数，在接下来的部分会用到。 至此，master部分结束了，接下来讲解worker部分。 worker worker部分我们需要完成的也就是主要的Worker函数，也就是那个接收两个函数为参数的函数。我们需要完成的也很简单：循环调用GetJob来联系Master，接收到map活则干map，接收到reduce活则干reduce，接收到暂停任务则sleep一下，如果联系不到则说明Master工作已经完成，干脆自己也退出就行。 worker主要部分也就确定了。一个大循环体，最开头是联系Master获得任务，代码如下： 123if call(\"Master.GetJob\", &amp;args, &amp;reply) == false { return } 注意，go是没有while的，你需要使用for循环。 接收到map工作后，先打开老板给的文件名，读取文件，将文件调用map函数，得到一个键值对组，存入中间文件中。中间文件的命名便有讲究：采用将key哈希成数字，然后对nReduce进行取余计算，这样可以保证相同的key计算值是一样的，同时也保证了分布式计算的正确性。将此数字作为中间文件名的一部分，同时另一部分采用map的号码，也就是传输过来的NMap号，来构成二元组。这样即保证了每个map任务的结果互不干扰，在一个map任务挂掉后重新执行该map，能够直接清空文件并再次编写。当进行reduce任务的时候，由于map数字是固定的，便于索引。 由于在mrsequential.go中实现了串行的MapReduce，因此可以复制粘贴一部分代码到里面。具体代码如下： 123456789101112131415161718192021222324252627282930313233else if reply.JobName == \"map\" { filename := reply.Filename file, err := os.Open(filename) if err != nil { log.Fatalf(\"cannot open %v\", filename) } content, err := ioutil.ReadAll(file) if err != nil { log.Fatalf(\"cannot read %v\", filename) } file.Close() kva := mapf(filename, string(content))//读取文件，调用map var files []*os.File for i := 0; i &lt; reply.NReduce; i++ { f, err := ioutil.TempFile(\"./\", \"tmp-map*\")//建立临时文件，可以保证程序意外退出后能够直接清空 if err != nil { fmt.Println(err) } files = append(files, f) } for _, kv := range kva { name := ihash(kv.Key) % reply.NReduce//哈希操作 f := files[name] fmt.Fprintf(f, \"%v %v\\n\", kv.Key, kv.Value)//将key相同的放进一个文件 } for index, value := range files { value.Close()//保存临时文件，同时改名为正式的中间文件的名字。也就是NMAP的作用 os.Rename(value.Name(), \"mr-\"+strconv.Itoa(index)+\"-\"+strconv.Itoa(reply.NMap)) } args.Status = \"map\" args.Filename = filename reply = RPCReplys{} } 代码不短，但有注释，很容易理解。 到reduce部分，reduce部分干的活便是打开reduce号对应的所有中间文件，读取他们，并对他们进行排序。然后，同样是为了容错，根据reduce号建立输出文件的临时文件。然后，遍历排序过的键值对组，将key值相同的文件，调用reduce函数归纳整理，将结果输出到临时文件中。最后，重命名临时文件到正式文件。 与map相同，由于在mrsequential.go中有对排序的实现以及文件名字命名的规范，文件内容的规范，我们也可以复制粘贴过来。具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051else if reply.JobName == \"reduce\" { var kvs []KeyValue var kv KeyValue filecode := reply.Filename for i := 0; i &lt; reply.NMap; i++ { filename := \"mr-\" + filecode + \"-\" + strconv.Itoa(i) ifile, err := os.OpenFile(filename, os.O_RDONLY, 0666)//根据reduce号计算中间文件名字，读取所有中间文件 if err != nil { log.Fatalf(\"cannot read %v\", filename) } for { _, err := fmt.Fscanf(ifile, \"%v %v\", &amp;kv.Key, &amp;kv.Value) if err != nil { fmt.Println(err) break } kvs = append(kvs, kv) } ifile.Close() } fmt.Println(\"len =\", len(kvs)) sort.Sort(ByKey(kvs))//对键值对组排序，ByKey可以参考mrsequential.go oname := \"mr-out-\" + reply.Filename ofile, err := ioutil.TempFile(\"./\", \"out-tmp*\")//临时文件，便于出错时直接丢弃 if err != nil { fmt.Println(\"output error\") } else { i := 0 for i &lt; len(kvs) { j := i + 1 for j &lt; len(kvs) &amp;&amp; kvs[j].Key == kvs[i].Key { j++ } values := []string{} for k := i; k &lt; j; k++ { values = append(values, kvs[k].Value) } output := reducef(kvs[i].Key, values) fmt.Fprintf(ofile, \"%v %v\\n\", kvs[i].Key, output) i = j } } ofile.Close()//这一部分参考mrsequential.go os.Rename(ofile.Name(), oname)//重命名 args.Status = \"reduce\" args.Filename = reply.Filename reply = RPCReplys{}} 至此，worker基本完成了。还有个休假部分，简单的sleep就行，不过多赘述。 整个MapReduce实验便完整地完成了。 测试 代码写完当然要测试。在lab1的官网上，给了我们一个很好的各种测试办法。具体可以参考官网。这里说说最终测试。 最后我们要执行的，是test-mr.sh的shell脚本。测试总共五项：测试word count程序，测试indexer程序，map并行化测试,reduce并行化测试以及容错测试。前两个是应用测试。中间两个我也不知道怎么测的，我也没看Shell源码，反正直接过了。最后一个容错测试值得多说几句。在现实生活中会遇到各种各样的错误，在上面实现的容错，也就是通过master在分配工作后检测给定时间内是否完成，未完成则重新分配，只能解决worker挂掉的问题。本次测试的也是如此。但现实生活中，可能master也会挂掉。这些问题在论文中提供了解决的思路。同时在论文中也有着多种优化的技巧与思路，所以论文值得多读几遍。 在执行完test-mr.sh最后，会有如下输出。如果你的结果和以下一样，恭喜你，你完成了本次实验。 12--- crash test: PASS*** PASSED ALL TESTS 总结 现在是凌晨2.15，写本博客比预先构想所花的时间要更长。写6.824的计划其实半年前学完go就想写了，但由于各种原因拖到最近才写完，从下载6.824到写完lab1过掉所有test只花了两天时间，和预想差不多。写本文花了两个半多小时。半年前最开始动手的时候感觉相当的迷茫，不知道从何下手，先是对go不熟悉，怕各种错误糊一脸，然后是对项目文件的不熟悉。这个过程中，仔细看官网，读论文，搜资料着实起到了很大的帮助。也幸亏MapReduce论文看了好几遍，让我交上了信息检索课的作业。 总之，正确早日写完6.824，不要留坑。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/2020-6-824-lab1%E8%A7%A3%E6%9E%90/"},{"title":"初探容器化：隔离，限制与docker run","text":"本文为容器化技术系列文章的第一篇。本文将介绍容器化中的隔离，限制的原理，并且实际编写一个类docker应用，并且实际执行docker run命令。 前置知识 Linux Go 初探容器化：隔离，限制与docker run目录 前言 隔离 Namepspaces 系统 Go的系统调用 限制 Cgroups技术 Cgroups实战 docker run 基本结构 实战docker_run 下一步做什么 总结与后记 隔离Namepspaces 系统： Namespaces 系统是linux对于系统资源的一种抽象，它使得进程认为在同一namespaces系统下的进程之间能够互相感知，而对namespace外一无所知，从而实现隔离的效果。 linux最新版本中，根据不同的功能，实现了7个namespace系统，如下所示： | Namespace | Constant | Isolates | | —- | —- | —-| | Cgroup | CLONE_NEWCGROUP | Cgroup root directory | | IPC | CLONE_NEWIPC | System V IPC, POSIX message queues | | Network | CLONE_NEWNET | Network devices, stacks, ports, etc. | | Mount | CLONE_NEWNS | Mount points| | PID | CLONE_NEWPID |Process IDs| | User | CLONE_NEWUSER |User and group IDs| | UTS | CLONE_NEWUTS |Hostname and NIS domain name| 详情可见man namespaces。具体命名空间数量由linux版本决定，在这里，由于只实现简易版本，我们只使用到IPC Network Mount PID User UTS这几个namespace。在内核版本3.8之后，这几个namespace都可用。 在man文档中，给了我们几种系统调用的方法，分别是： clone：创建新进程，根据flag数，为每一个flag创建一个namespace，将进程封入进去。 setns：将调用的进程封装进已经存在的namespace里面。 unshare：将正在调用的进程封装进由flags确立的新的namespaces里面。 ioctl:查看namespaces的信息。 文档中给出了这些信息，但我们不一定需要使用裸露的api，go为我们封装了它。 Go的系统调用： 在go的syscall库中，为我们封装了系统调用。我们可以通过设置SysProcAttr结构体，来进行系统调用。该结构体定义如下： 12345678910111213141516171819type SysProcAttr struct { Chroot string // Chroot. Credential *Credential // Credential. Ptrace bool // Enable tracing. Setsid bool // Create session. Setpgid bool // Set process group ID to Pgid, or, if Pgid == 0, to new pid. Setctty bool // Set controlling terminal to fd Ctty (only meaningful if Setsid is set) Noctty bool // Detach fd 0 from controlling terminal Ctty int // Controlling TTY fd Foreground bool // Place child's process group in foreground. (Implies Setpgid. Uses Ctty as fd of controlling TTY) Pgid int // Child's process group ID if Setpgid. Pdeathsig Signal // Signal that the process will get when its parent dies (Linux only) Cloneflags uintptr // Flags for clone calls (Linux only) Unshareflags uintptr // Flags for unshare calls (Linux only) UidMappings []SysProcIDMap // User ID mappings for user namespaces. GidMappings []SysProcIDMap // Group ID mappings for user namespaces. // GidMappingsEnableSetgroups enabling setgroups syscall. // If false, then setgroups syscall will be disabled for the child process. // This parameter is no-op if GidMappings == nil. Otherwise for unprivileged // users this should be set to false for mappings work. GidMappingsEnableSetgroups bool AmbientCaps []uintptr // Ambient capabilities (Linux only) } 在结构体中，我们着重关注Cloneflags,Unshareflags,UidMappings,GidMappings,这些在namespaces系统中，可能会用得到。 下面是一个小demo，用于展示如何使用SysProcAttr去创建进程并且封入新的namespace里面。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"syscall\" \"os/exec\" \"os\" \"fmt\")func main(){ cmd:=exec.Command(\"sh\") fmt.Println(\"start namespace demo\") cmd.SysProcAttr = &amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS|syscall.CLONE_NEWIPC|syscall.CLONE_NEWPID|syscall.CLONE_NEWNS|syscall.CLONE_NEWUSER, UidMappings: []syscall.SysProcIDMap{ { ContainerID: syscall.Getuid(), HostID: syscall.Getuid(), Size: 1, }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: syscall.Getgid(), HostID: syscall.Getgid(), Size: 1, }, } } cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr if err:=cmd.Run();err!=nil { log.Fatal(err) } fmt.Println(\"end namespace demo\")} 在demo，创建了子进程，启动了一个sh，并且封入了各个namespace中。在这个demo中，可以尝试各种指令来尝试隔离性，如ps -ef。 限制Cgroups技术 Namespace技术保证了各个进程的隔离。而若要添加诸如内存大小的限制，我们需要学习cgroups技术。 Control cgroups，通常称为cgroups，是linux内核提供的特性，它能使进程被组织进hierarchical groups，可以用来限制和监视各种资源的使用。内核的cgroup接口通过伪文件系统cgroupfs来调用。分组操作在cgroup内核中实现，而资源跟踪和限制则是通过资源类型子系统来实现。 cgroup 是绑定到通过 cgroup 文件系统定义的一组限制或参数的进程的集合。 subsystems 是修改cgroup进程的行为的内核组建。各式各样的子系统能够用来执行一些操作，诸如限制cpu时间或者内存。subsytems也被成为资源控制器。 控制器的cgroup按层次结构排列。 通过在cgroup文件系统中创建，删除和重命名子目录来定义此层次结构。 在层次结构的每个级别，都可以定义属性（例如，限制）。 cgroup提供的限制，控制和计费通常在定义属性的cgroup之下的整个子层次结构中都有效，例如，后代不能超过在层次结构中较高级别上放置在cgroup上的限制cgroups。 Cgroups实战 环境需要 stress程序 用于模拟系统负载较高场景 首先我们创建文件夹，并且把cgroup挂载进去。执行一下命令： 12345root@wqy:/home/wqy# mkdir cgroup-testroot@wqy:/home/wqy# sudo mount -t cgroup -o none,name=cgroup-test cgroup-test ./cgroup-testroot@wqy:/home/wqy# ls ./cgroup-test/cgroup.clone_children cgroup.sane_behavior release_agentcgroup.procs notify_on_release tasks 可以看到，在我们挂在完成后，文件内创建了一些默认的文件。其中cgroup.clone_childred代表子cgroup是否继承父cgroup的cpuset cgroup.procs代表树中当前节点所有进程组id notify_on_release代表最后一个进程退出后是否执行release_agent release_agent是个路径 用于退出后自动清理 tasks表示cgroup下的进程id。 我们可以在此文件夹中增加新的cgroup来进行测试。执行以下指令： 12345678910111213141516171819202122root@wqy:/home/wqy/cgroup-test# sudo mkdir cgroup-1root@wqy:/home/wqy/cgroup-test# sudo mkdir cgroup-2root@wqy:/home/wqy/cgroup-test# tree.├── cgroup-1│&nbsp;&nbsp; ├── cgroup.clone_children│&nbsp;&nbsp; ├── cgroup.procs│&nbsp;&nbsp; ├── notify_on_release│&nbsp;&nbsp; └── tasks├── cgroup-2│&nbsp;&nbsp; ├── cgroup.clone_children│&nbsp;&nbsp; ├── cgroup.procs│&nbsp;&nbsp; ├── notify_on_release│&nbsp;&nbsp; └── tasks├── cgroup.clone_children├── cgroup.procs├── cgroup.sane_behavior├── notify_on_release├── release_agent└── tasks2 directories, 14 files 可以看到，在添加子cgroup后，子cgroup继承了属性。 接下来，我们为进程加入限制。我们将创建一个stress程序，占用200m内存，观察限制前与限制后是否有区别。 1stress --vm-bytes 200m --vm-keep -m 1 执行以上指令，在本机的top中可以看到，%MEM项目为2.6,即200M。接下来，加上限制。 12345678root@wqy:/home/wqy/cgroup-test# mount |grep memorycgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)root@wqy:/home/wqy/cgroup-test# cd /sys/fs/cgroup/memory root@wqy:/sys/fs/cgroup/memory# sudo mkdir test-limit-memoryroot@wqy:/sys/fs/cgroup/memory# cd test-limit-memory/root@wqy:/sys/fs/cgroup/memory/test-limit-memory# sudo sh -c \"echo \"100m\" &gt;memory.limit_in_bytes\" root@wqy:/sys/fs/cgroup/memory/test-limit-memory# sudo sh -c \"echo $$ &gt; tasks\"root@wqy:/sys/fs/cgroup/memory# stress --vm-bytes 200m --vm-keep -m 1 在上述命令中，我们通过mount和grep找到了memory所在的挂载点，在挂载点创建了子cgroup：test-limit-memory，将内存限制写入了限制文件，将本进程写入了task，最后执行了指令。通过top命令可以看到 %MEM项目为1.3,即100M。我们成功实现了限制内存使用。 在完成了namespace隔离demo和cgroup限制demo后，我们即将用go语言，将这些整合在一起，实现简单的隔离限制程序。 docker_run 该部分代码仓库：github:mydockerpractice 具体为main.go subsystem cgroupmanager container四个部分。 基本结构 在实现简易的docker run之前，我们需要理清思路：我们即将要编写的文件，how it works。 功能 实现命令行解析参数 包括命令种类如run 资源限制如-m 在指定run命令后 使用namespace创建子进程 并且执行命令行给予的程序 在指定限制之后 能使用cgroup加入限制 解析文件可以由第三方库来实现，这里使用的是github.com/urfave/cli，在上述vendor文件夹中可以找到。 实战docker_run 首先，我们来确认主函数功能：启动cli，绑定各种参数，进行解析。剩下事务交给其他模块来做。我们可以得到以下主函数： 1234567891011121314151617181920212223242526272829package mainimport ( \"github.com/urfave/cli\" \"fmt\" \"os\" \"strings\" \"io/ioutil\" _ \"github.com/Sirupsen/logrus\" container \"mydocker/container\" subsystem \"mydocker/subsystem\" cgroupmanager \"mydocker/cgroupmanager\")const usage = `mydocker is a simple container.`func main(){ app := cli.NewApp() app.Name = \"mydocker\" app.Usage = usage app.Commands = []cli.Command{ initCommand, runCommand, } if err:= app.Run(os.Args); err!=nil { fmt.Println(err) } } 可以看到，我们定义了两个启动命令init和run，分别是初始化容器和启动程序。我们将在下面介绍两个指令的功能。 runCommand以及Run函数：runCommand解析参数并且传递给Run函数。Run函数使用NewParentProcess创建了带namespace的进程，创建了cgroup管理程序，配置了限制，应用到进程上，并且将程序指令写入pipe，便于namespace的进程调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var runCommand = cli.Command{ Name : \"run\", Usage : \"Create a container\", Flags : []cli.Flag{ cli.BoolFlag{ Name : \"ti\", Usage: \"enable tty\", }, cli.StringFlag{ Name : \"m\", Usage : \"limit the memory\", }, }, Action: func(context *cli.Context) error { fmt.Println(\"start runCommand\") if len(context.Args()) &lt; 1 { return fmt.Errorf(\"Missing container command\") } var cmdArray []string for _, arg := range context.Args() { cmdArray = append(cmdArray, arg) } tty := context.Bool(\"ti\") resConf := &amp;subsystem.ResourceConfig{ MemoryLimit: context.String(\"m\"), } Run(tty, cmdArray, resConf) return nil },}/*Run command start a parentprocess with namespacestart a CgroupManagerset the configstore the command*/func Run(tty bool, commandArray []string, resConf *subsystem.ResourceConfig){ parent, writePipe := container.NewParentProcess(tty) if err:= parent.Start(); err!=nil { fmt.Println(err) return } cgroupManager := cgroupmanager.NewCgroupManager(\"mydocker-cgroup\") defer cgroupManager.Destroy() cgroupManager.Set(resConf) cgroupManager.Apply(parent.Process.Pid) sendInitCommand(commandArray, writePipe) parent.Wait()} 注意上述NewParentProcess，这是完成程序隔离的重要函数。在下面我们会讲解它。 12345678910111213141516171819202122232425262728293031323334353637383940/*NewParentProcess function:creates a child precess with namespaces, run itself in the process, create a pipe and file for the Run fucntion to write*/func NewParentProcess(tty bool) (*exec.Cmd, *os.File){ fmt.Println(\"New parent\") readPipe, writePipe, err := NewPipe() if err!=nil { fmt.Printf(\"pipe error %v\\n\",err) return nil,nil } cmd := exec.Command(\"/proc/self/exe\",\"init\") cmd.SysProcAttr = &amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWNET |syscall.CLONE_NEWUSER, UidMappings: []syscall.SysProcIDMap{ { ContainerID: syscall.Getuid(), HostID: syscall.Getuid(), Size: 1, }, }, GidMappings: []syscall.SysProcIDMap{ { ContainerID: syscall.Getgid(), HostID: syscall.Getgid(), Size: 1, }, }, } if tty { cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr } cmd.ExtraFiles = []*os.File{readPipe} return cmd, writePipe} 这便是NewParentProcess的全貌。它启动了一个子cmd，套上了namespace隔离，并且最终要的一点，它使用了以init参数exec /proc/self/exe 这相当与它在子进程中以init参数调用它自己，重新启动。这会覆盖掉当前的数据，堆栈，PID等，从而实现了使用指定的run进程覆盖掉init进程的办法。就这样，我们便得到了一个守护进程以及一个被隔离的容器进程。 该函数返回了writePipe，便是方便将指令传达给子进程。它使用了ExtraFiles属性，意味着在创建子进程时候会额外携带该句柄。在操作系统中，几乎总是分配最小的可用句柄。由于0 1 2为标准输入输出错误句柄，这样在子进程中，就可以直接打开3号句柄获取指令。（虽然硬编码非常不优雅） 在隔离之后，我们还要为其加上限制。这一部分功能是由CgroupManager来完成。这里只实现了内存的限制，我们来从内存，观察CgroupManager是如何工作的。 1234567891011121314151617181920212223242526272829303132type CgroupManager struct { Path string Resource *subsystem.ResourceConfig}func NewCgroupManager(path string) *CgroupManager{ return &amp;CgroupManager{ Path: path, }}func (c *CgroupManager) Apply(pid int) error { for _, subSysIns := range(subsystem.SubsystemIns) { subSysIns.Apply(c.Path, pid) } return nil}func (c *CgroupManager) Set(res *subsystem.ResourceConfig) error { for _, subSysIns := range(subsystem.SubsystemIns) { subSysIns.Set(c.Path, res) } return nil}func (c *CgroupManager) Destroy() error{ for _, subSysIns := range(subsystem.SubsystemIns) { if err:= subSysIns.Remove(c.Path); err!= nil { fmt.Printf(\"error in remove cgroup %v\\n\",err) } } return nil} 可以看到，CgroupManager包含了路径以及资源限制的配置ResouceConfig。而在Run函数中可以看到，CgroupManager实现了Apply,Set,Destroy等方法，这些方法本质上是将ResouceConfig传递给subsystem文件中的SubsystemIns，使用SubsystemIns的多态方法进行调用。 接下来我们来观察subsystem文件声明，来观察它是如何限制资源的。 12345678910111213141516171819202122package subsystemtype ResourceConfig struct { MemoryLimit string CPUShare string CPUSet string}type Subsystem interface { Name() string Set(path string, res *ResourceConfig) error Apply(path string, pid int) error Remove(path string) error}var ( SubsystemIns = []Subsystem{ //&amp;CPUSetSubSystem{}, &amp;MemorySubSystem{}, //&amp;CPUSubSystem{}, }) 在这里可以看出，SubsystemIns是一个Subsystem数组，其中包括MemorySubSystem。Subsystem接口规定了实现的方法，Name,Set,Apply,Remove。 接下来让我们以MemorySubSystem为例子，观察具体的限制是如何实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*Set functionwrite the memory limit into the cgroup path*/func (s *MemorySubSystem) Set(cgroupPath string, res *ResourceConfig) error { if subsysCgroupPath, err := GetCgroupPath(s.Name(),cgroupPath,true); err == nil{ if res.MemoryLimit != \"\" { if err := ioutil.WriteFile(path.Join(subsysCgroupPath, \"memory.limit_in_bytes\"), []byte(res.MemoryLimit),0644); err != nil { return fmt.Errorf(\"set cgroup memory failed %v\",err) } } return nil } else { return err }}/*Apply functionJoin a process into a cgroup*/func (s *MemorySubSystem) Apply(cgroupPath string, pid int) error { if subsysCgroupPath, err := GetCgroupPath(s.Name(),cgroupPath,false); err == nil { if err := ioutil.WriteFile(path.Join(subsysCgroupPath, \"tasks\"),[]byte(strconv.Itoa(pid)),0644); err!=nil { return fmt.Errorf(\"set cgroup proc fail %v\",err) } return nil } else { return fmt.Errorf(\"get cgroup %s error: %v\",cgroupPath,err) }}/*Remove functionremove the cgroup path*/func (s *MemorySubSystem) Remove(cgroupPath string) error { if subsysCgroupPath, err := GetCgroupPath(s.Name(),cgroupPath,false); err == nil { return os.Remove(subsysCgroupPath) } else { return err }}/*Name functionget its name*/func (s *MemorySubSystem) Name() string{ return \"memory\"} 此处代码有注释，不过多赘述。本质上和之前的demo一样，写入限制文件，将进程放进去，和移除该进程限制所在的文件夹。在这里GetCgroupPath作用是根据mountinfo找到cgroup限制的文件夹，并创建子目录。具体代码可以在仓库内查看。 就此，限制系统demo便完成了。接下来我们来观察init指令执行后，该进程会如何运行。 1234567891011var initCommand = cli.Command { Name : \"init\", Usage : \"Init the process\", Action: func(context *cli.Context) error { fmt.Println(\"start initCommand\") cmd := readUserCommand() err := container.RunContainerInitProcess(cmd[0],cmd[1:]) return err },} 回到主进程。在创建子进程并且以init为参数执行了/proc/self/exe后，相对应接收的便是init指令。上面可以看到，init指令读取了之前的参数，并且初始化了容器进程。读取指令就像之前所说一样，可以采用fd=3的硬编码打开读取。 接下来我们来看看RunContainerInitProcess该如何运行。 123456789101112131415161718192021222324252627282930313233/*RunContainerInitProcess function:mounts the essential environment, read the command stored by the NewParentProcess,run the commands*/func RunContainerInitProcess(command string, args []string) error{ fmt.Printf(\"the command is %s\\n\",command) fmt.Println(\"mount start\") err :=syscall.Mount(\"\",\"/\",\"\",syscall.MS_PRIVATE|syscall.MS_REC,\"\") if err!=nil { fmt.Println(err) return err } defaultMountFlags := syscall.MS_NOEXEC | syscall.MS_NOSUID | syscall.MS_NODEV err = syscall.Mount(\"proc\", \"/proc\",\"proc\", uintptr(defaultMountFlags),\"\") if err!=nil { fmt.Println(err) return err } command,err = exec.LookPath(command) if(err!=nil){ fmt.Printf(\"error in finding %s \\n\",command) fmt.Println(err) return err } argv := append([]string{command},args...) if err := syscall.Exec(command, argv, os.Environ()) ; err!=nil { fmt.Printf(\"exec error is %v\\n\",err) return err } return nil} 可以看到，该函数接收两个参数，command和args，首先实现了chroot防止proc不释放，然后将proc挂载了进来，便于在容器内实现各种操作。之后，使用LookPath解析了指令，并且exec了程序。至此，我们实现了资源的限制，资源的隔离，并且在完成这些配置后运行了程序。一个简单的docker run项目便如此完成了。 下一步做什么 在docker中，除去隔离与限制，最显著的特点便是它的image镜像功能。这能大大减少部署环境的难度。在下一篇文章中，我们将探讨如何实现这一功能。 总结与后记 本篇文章讲解了如何实现一个隔离并且进行限制的小docker程序。在这其中主要熟悉了各种系统调用的作用与使用方法，以及如何进行实现。由于篇幅问题，本文省略了一部分工具代码，具体代码还需要参考仓库内。在仓库中有各种demo的实现。 本文对系统调用的知识主要来自对man文档的翻译，可能存在欠缺。因此有不足的地方欢迎指正。 本篇文章起于11.12，完成于11.16，由于各种原因存在一些拖延，但整体完成时间较长。本文主要也是我自己对于代码的一个复习于归纳。 下一篇文章不存在意外的话预计不会耗费多余一周的时间。敬请期待。 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E5%88%9D%E6%8E%A2%E5%AE%B9%E5%99%A8%E5%8C%96%EF%BC%9A%E9%9A%94%E7%A6%BB%EF%BC%8C%E9%99%90%E5%88%B6%E4%B8%8Edocker-run/"},{"title":"白帽子谈web安全读书笔记","text":"本文主要为白帽子谈web安全的读书笔记，用于记录。 白帽子谈web安全第一章 概述安全三要素： 机密性：数据加密，不被泄露。 完整性：数据完整，不被篡改。 可用性：保护资源随需求而得。 安全评估流程：资产阶级划分-&gt;威胁分析-&gt;风险分析-&gt;确认解决方案 威胁分析：伪装 篡改 抵赖 信息泄露 拒绝服务 提升权限 第二章 浏览器安全同源： 浏览器js使用同源策略来防护。不能跨域访问资源。 “同源”依据包括：域名或ip地址，子域名，端口，协议。 DOM cookie XMLHttpRequest以及一些插件如flash都会有着同源策略。 沙箱： 沙箱泛指资源隔离模块谷歌浏览器采用沙箱机制，多进程来限制代码执行。但一些第三方插件如flash，java等不受sandbox管辖，成为浏览器攻击热点。 恶意网站拦截： 基于页面特征识别，在服务端进行模型建立处理，使用黑名单，与安全厂商合作，推送黑名单。 EV证书：数字证书颁发机构与浏览器厂商一起打造的，增强对安全网站的识别。 第三章 XSS跨站脚本攻击：使用html注入篡改网页，插入恶意脚本 反射型XSS：将用户输入的数据反射给浏览器，需要诱使用户点击恶意链接才能攻击成功。非持久性XSS。 存储型XSS：写下包含恶意js的博客，发表后所有访问博客的都会执行代码。又叫持久型XSS。 DOM Based XSS：修改页面DOM节点来实现 cookie劫持 先xss访问远程脚本并且加载，再利用image的src，利用url参数中加入cookie来访问目标域名。只需要访问留下日志，即可窃取。 构造get post请求 get与上述类似，用过img的src来构造get请求。 post则使用js，构造表单（用js或者直接写html），或者用XMLHttpRequest来构造。 除了一般cookie以外，还可以通过观察network，构造sid之类的，进行模拟访问来获取消息。 xss钓鱼 xss将验证码url发到远程服务器，等待接收并且返回给xss来绕开验证码。 使用xss用js在界面画出伪造的登录框，发送密码到服务器。 浏览器以及用户软件识别 观察UA或者使用版本判断代码来识别浏览器版本。 通过新建控件来判断用户是否安装软件，如新建ActiveX空间XunLeiBHO.ThunderIEHelper来判断是否安装了迅雷软件。 还可以通过第三方软件来观察，如Flash的system.capabilities来找到硬件信息。 firefox的插件可以通过查询DOM来找到。 chrome插件可以通过访问chrome://flashgot/skin/icon32.png来查询。 通过CSS观察链接颜色来看是否访问过网站。 通过XSS调用Java Applet接口获取本地真实ip地址，本地网络信息。 攻击平台 Attack API：总结了许多XSS Payload归纳成api BeEF：有控制后台，攻击者可以在后台控制前端，展示完整XSS攻击过程。 XSS Proxy：嵌套ifrane实时远程控制背XSS攻击的浏览器。 调试JS Firebug Fiddler HttpWatch 浏览器Debugger XSS构造与攻击 使用字符编码，如GBK下两个字符在Unicode下被认为为一个字符，绕开系统安全检查。 绕开长度限制，如使用event或者将payload写在别出，再获取payload。 local.hash不会在http包发送，可以藏代码。 可以用注释将html代码注释掉，如第二个文本框允许写入更多细节，那么可以通过注释打通两个文本框。 通过base标签表示链接的base地址，使用这个标签来访问外部js。 window.name没有特殊字符限制，可以实现数据的跨域传输。也可以缩短payload长度。 通过flash构造http请求来威胁服务器。 使用存储型XSS嵌入反射型XSS进行攻击 Flash可以嵌入ActionScript脚本来攻击。 XSS防御 HttpOnly 可以防止js读取到cookie 输入检查，使用白名单或黑名单检查格式，而且必须在服务端检查，而非客户端。 可以使用输出检查，编码或者转义来实现，比如使用编码函数，在多个地方用多种编码 富文本中event应当被禁止，用白名单，使用开源项目来帮助检查。 第四章 跨站点请求伪造CSRF跨站点伪造请求，称为CSRF。 cookie策略 session cookie：临时cookie 在浏览器关闭后cookie就失效了 保存在浏览器进程的内存空间 third-party cookie：在服务器expire时间之后cookie才会失效 保存在本地 如果从一个域的页面加载另一个域的资源，IE safari会阻止third-party cookie发送 firefox chrome不会 P3P头不会拦截第三方cookie发送，用于广告等跨域访问 ，可以加以利用。 跨站点post 可以构造好一个form表单，用js自动提交，甚至隐藏在不可见的iframe的窗口中。 FLASH CSRF Flash也能有多种方法发送网络请求。 CSRF防御 验证码：强制用户进行交互，完成最终请求。但不能给所有操作都加上验证码。 referer check：检查referer来源，但由于不能什么时候都获取到referer。 Token：业界最主要做法。在链接中加入Token=randomblablabla值 token值不可预测，从而实现鉴别。可以放在cookie和session中，检查是否一致。token在一个用户的有效生命周期，在成功提交过后，应当消耗掉。 第五章 点击劫持使用一个透明的iframe覆盖，欺骗进行点击。使用CSS控制alpha通道进行实现。 flash也可以点击劫持，通过flash游戏诱导点击按钮变化，最后一步步操作打开了用户摄像头。 图片也可以劫持，通过调整图片css到任意位置，点击就会到钓鱼网站。 拖拽劫持：拖拽处隐藏iframe，拖拽完成后同时完成数据传输。 触屏劫持：触屏，离开屏幕，滑动都是事件，可以利用，比如造一个假地址栏。 防御 frame busting 禁止iframe嵌套 但由于是用js写的，因而可以绕过它 还可以用sandbox限制js脚本执行。 用x-frame-options的http头，拒绝加载任何frame页面 第六章 HTML5安全新标签，新安全 通过新标签，如video audio来远程加载音频，绕过filter。 使用sandbox以及属性来控制同源访问，运行脚本等。 使用noreferer来不再发送referer。 使用canvas能够进行破解验证码。 w3c有跨域请求标准，需要带origin header来防止csrf。 postMessage允许没以恶个窗口对象往其他窗口发送文本消息，实现跨窗口消息传递。不受同源策略限制。但也可以用xss payload来实现iframe，用PostMessage给父窗口发送消息。 web stroage分为session storage和local storage，前者关闭则会失效，后者一直存在。使用kv对来进行操作。也受同源策略约束。 第七章 注入攻击用户能够控制输入，而且程序需要执行的代码拼接了用户输入的数据。 SQL注入 盲注：在没有错误回显的情况下完成攻击，虽然缺少调试信息，但可以构造简单语句观察页面是否变化。 Timing Attack：根据benchmark函数，观察时间长短来观察是否注入成功。可以利用各种数据库函数来获取有用信息。如果有写权限，甚至可以写入磁盘。 攻击技巧 用substring可以找对应版本。 可以用union select来确定表是否存在，列是否存在。 确定列存在后，可以用字符范围来读取表内信息。 可以用自动化工具sqlmap。 可以用load_file读取文件，用into_dumpfile写入文件，然后创建表导入数据来查看数据。 可以用用户自定义函数来获取系统权限，可以通过lib_mysqludf_sys提供的几个函数执行系统命令，如sys_eval和sys_exec，这些被集成到sqlmap中。 ms sql server可以用xp_cmdshell来执行系统命令，oracle可以用java。 存储过程本身可能存在注入漏洞，注意文本处理。 注意字符集的统一，避免各个字符集差异导致转义问题。 sql不开严格模式，遇到超长输入可能会截断，那么插入与admin同名数据后，根据逻辑可能就可以越权访问。 防御 有些escape只能转义部分字符，黑名单形式不太行。 预编译语句是防范注入的最好方法。 使用安全的存储过程也能抵抗sql注入。 检查数据类型可以防范注入。 使用安全函数可以对抗sql注入，比如编码函数。 最好方法是限制权限，如自定义函数，操作本地文件。 其他注入 XML注入，可以构造恶意数据来插入。 代码注入，主要发生在eval等不安全的函数上。jsp的include也能导致注入，多见于脚本语言。 CRLF注入，这俩是不同语义的分隔符，可以注入来改变语义，修改日志。 最后 数据与代码分离，在拼凑的地方进行安全检查即可。 第八章 文件上传漏洞上传了可执行脚本，通过脚本文件获取到了执行服务端命令的能力。 安全问题： 上传web脚本语言，服务器的web容器解释了脚本 上传了flash的策略文件crossdomain.xml，黑客用来控制flash在该域下的行为 上传了病毒木马文件，诱骗下载 上传钓鱼图片或者包含了脚本的图片，被当成脚本执行 上传文件作为入口，溢出后台处理程序 上传的文件能被Web容器解释执行，所在目录是web容器所覆盖的目录，用户能够通过web访问，而且没有被安全检查，格式化，图片压缩等。 绕开上传检查 在文件名后面添加一个%00的字符，在c php被认为是终止符，那么可以构造文件名绕开文件名后缀类型检查。 判断前十个字节通常能判断文件的真实类型，因此可以伪造文件头前256个字节，判断文件类型。 功能or漏洞 在apache曾经的文件解析中，会从后往前解析，直到遇到认识的文件名为止。 在IIS文件解析中，截断字符为分号；因此可以造脚本名。文件夹扩展名也存在问题，/.asp/文件夹下的文件都被解释为asp文件。 针对IIS，可以用PUT方法和MOVE方法，将文本文件改写为脚本文件。首先用OPTIONS来查看支持的方法，然后用PUT上传文本文件，然后使用MOVE改名。 php cgi路径解析存在问题，当访问xxx.com/a.jpg/x.php时候会把a.jpg当php解析。原因是解析地址名时候会向上递归。 302能跳转到钓鱼网站，而利用文件上传功能，通过传播这个文件的url进行钓鱼，在老版本的IE中会将图片当HTML执行。 设计文件上传 文件上传目录没有exec权限，作为静态文件处理。 判断文件类型，使用MIME Type 后缀名等用白名单方法，对于图片可以用压缩函数或者resize函数来破坏代码。 用随机数改写文件名，文件路径。 单独设置文件服务器的域名。 第九章 认证和会话管理认证用于辨认用户是谁，授权用于决定用户能做什么。 密码必须用不可逆的加密算法，单向散列函数加密存储在数据库中。 破解MD5后的方法：彩虹表，收集大量明文和MD5，来进行查找。可以通过加盐处理。 sessionID通常加密后保存在Cookie中，但也可能被窃取。 如果登录前后sessionID没有发生变化，则会发生session fixation问题，用户X可以诱导用户Y改变session状态来实现攻击。比如诱导点击URL。所以在登陆完成后需要重写sessionID。 session存在保持攻击，只要不停发起请求，就可以一直活下去。 有些时候session不会在服务端维护，用客户端的cookie的expire时间，但由于在客户端，因此很容易被攻击。 可以强制销毁session，或者当ip ua变化时候强制销毁重新登录。不允许多个session生效。 单点登录SSO：登录以此可以访问所有系统。这样可以集中风险，在重点使用多种方法，甚至委托给第三方。既是优点也是缺点。可以用OpenID框架来认证。 第十章 访问控制访问控制是某个主题对某个客体实施某种操作的限制。可以通过ACL访问控制列表来决定。 基于URL的访问控制，通过权限认证是否能访问url来实现。可以通过字典找到url来访问。 spring security支持基于url method 表达式的访问控制，配置文件复杂，学习维护成本较高。 用户-角色-权限 称之为垂直权限管理。 需要检查资源是否属于对应用户，虽然角色共享，但存在私有数据。因此也存在水平权限管理问题。 OAuth是不提供用户名和密码情况下，授权第三方应用访问Web资源的安全协议.用request token换access token，然后用access token访问资源。 可以使用外部OAuth库来进行使用。 第十一章 加密算法和随机数常见有分组加密和流密码加密。 流密码：基于异或操作，常见错误是对同一个密钥多次加解密，由于异或运算的特性决定。同样利用原理，可以构造和管理员一样的密文来越权，这个可以用消息验证码MAC验证是否被篡改。有时候存在弱随机问题，可以暴力破解。 WEP密码就是采用流密码的RC4，可以用暴力和等待初始化向量重复来执行。 ECB电码本模式，每个分组之间相对独立，可以观察出来。改变密文顺序也可以改变明文顺序，有其统计特征。 CBC链式加密模式，前后会互相关联。先将初始化向量和第一个分组异或完成并且DES完成，然后将结果与第二个分组异或。最后填充不正确则会抛出异常。 如果最后一个分组消息长度没有达到，则会填充，比如剩下5个字节则每个字节填充个5之类的。如果正好为8则加一个全为8的分组。 CBC模式破解：先根据密文长度，检查是8字节还是16字节。然后构造初始化向量，直到padding正确，这时候就能确定中间值的最后一位。同理，可以确定中间值的所有位，从此可以获得明文。 密钥管理 不要把密钥硬编码到代码里面。当代码广泛传播，或者逆向后会被泄露，能够访问到代码的人员也会泄露。正确做法是放在配置文件或者数据库中。并且减少访问权限。在生产环境中需要重新生产密钥，定期更换密钥，可以将所有密钥放在一个服务器中，通过服务来获取密钥，不屑道本地文件中，只加载到内存里。 伪随机数 openssl曾经只能以pid为seed，导致只有32768个种子，很快可以遍历key。 许多地方都用伪随机数。系统时间替代伪随机数容易生成问题，因为这适合时间顺序增长的。不要把时间函数当随机数用。 伪随机数存在种子，rand的范围非常小，只有32767。伪随机数种子确定后求的值是固定的。由于种子数量可能固定，因而可以遍历。当已知第一个值之后，可以猜测种子进行遍历。可以发送keep alive头，强制所有服务端使用同一php进程响应。 这些可以使用足够安全的随机数算法解决。 总结 不要用ECB 不要流密码 用HMAC-SHA1替代MD5 不要用相同key做不同事情 salt和初始向量要随机 用别人实现的加密算法 不要依赖系统的保密性 用CBC的AES256加密 用HMAC-SHA512检查 用带salt的SHA256进行Hash 第十二章 WEB框架安全在正确的地方做正确的事，Model层要解决的问题不要丢给view层。 在不同的场景需要不同的编码函数，比如存在一些场景，自动转码不够用，有些场景需要加入sql转码，xml转码，js转码等。 读写操作需要区分，在存在写操作需要注意CSRF。 在web框架中防csrf： session中绑定token 或者代为保存到cookie中 form中自动填入token字段 ajax自动添加token post时候验证token参数 控制HTTP头，管理好跳转函数，控制Location字段，使用封装好的cookie函数。 使用ORM应对SQL注入，预编译，找到动态变量来实现。 文件上传也用别人写好的。 spring security为Spring mvc提供许多安全功能，但缺乏XSS CSRF等。 Web框架自身也可能存在安全问题。 第十三章 应用层拒绝服务攻击DDOS：分布式拒绝服务，有SYN泛洪，UDP泛洪，ICMP泛洪。 应用层DDOS区别于网络层，TCP已经建立连接。比如在大流量网站siteA上插入iframe代码。 应对DDOS可以采用限制请求频率，但IP可以发生变化，或者大量僵尸机器。因此要做好性能优化，负载均衡，CDN，限制请求频率。 验证码可能存在遍历图片的破解方法，有时候根据sessionID生成的验证码未失效。但现在也存在机器识别。 防御DDOS可以让客户端解析一段js，并且给出正确的运行结果。还可以设置参数缓解DDOS。可以根据频率进行拦截。 并发连接数量存在上线，如果所有连接都被占用，就会拒绝服务。因而可以消耗资源。 HTTP POST用很慢的速度发包，连接不断开，可能导致资源耗尽。 使用XSS，写入一个超长cookie导致无法访问，也会导致拒绝服务。 正则写的不好也可能导致资源大量消耗，可能导致正则计算复杂度过高，从而攻击。 第十四章 PHP安全文件包含漏洞 PHP：include include_once require require_once fopen readfile JSP :java.io.File java.io.FileReader ASP：include file include virtual 当使用include，会被作为php代码执行，不会在意包含文件类型。当include通过动态变量包含文件，而且用户可以控制该变量，则可以利用。 php内核使用c语言，因此可以利用0字符截断。此外还可以利用最大字符长度，用./来构造目录。构造目录方法可以用编码来利用。 fopen fclose同样危险，因为可以读取敏感文件。 可以利用字符来遍历目录漏洞。可以用Open_basedir来限制。 PHP还能加载远程文件，构造URL来执行。 包含本地文件需要知道具体位置，可以包含session文件，他在/tmp目录下。也可以用包含日志文件，可以在凌晨去攻击日志。 位置可以用默认安装，自定义安装的各种目录来猜测。可以用自动化脚本来打。 目录位置完全猜不到，可以尝试错误回显，或者利用/proc/self/environ，看环境变量来完成攻击。 临时文件可以暴力猜文件名，可以利用这一点。 变量覆盖漏洞 变量未初始化而且能被控制，则很不安全。可以在url里面覆盖全局变量。 extract可以将变量从数组导入符号表，可以overwrite。 防御：先保证register_globals = OFF 防止各种可能造成变量覆盖的函数，记得初始化变量。 代码执行漏洞 小心危险函数，比如popen system passthru exec eval等。 第十五章 WebServer配置安全Apache httpd 检查Module安装情况，注意最小权限，减少不必要Module，注意Module的安全漏洞。 不要以高权限身份运行Apache，入侵后会获得高权限shell，apache本身会做危险操作。 Nginx Nginx要注意自身软件版本，合理配置文件，处理UA之类的来管控服务。 jBoss 管理后台功能强大，默认没有认证，有多种远程执行命令的方法。 Tomcat Tomcat后台也默认跑在8080，部署war包需要manager权限，可以脚本自动打。 读后感在第15章之后，都是一些更高层面的安全问题，我自己觉得这些层面的问题虽然也很重要，但缺乏细节，有些事情也不是开发岗能解决的事。我自己本人是后端开发岗，有些更高层次的问题不是属于我能解决的问题，所以没有阐述。 就我个人而言，我认为这本书还是相当有价值的，尽管我本人不写PHP，而且这本书也有些年头了，一些东西也过时了，但对于我这个完全没有什么安全经验的人，能够读懂，了解一些安全的内容，还是很有意思。 这本书介绍的一些例子很好地展示了一些攻击的手段，“黑客”自我从小以来一直是个很炫酷的称号，在阅读了这些手段之后我也觉得，一些手段着实是利用了人性，充满智慧，相当巧妙。能够想到这些手段的人或许是灵光一现，但也经历过相当的积累，我对此无比感慨。这些奇怪的手段，让这本书作为假期的消遣娱乐也算很有意思。 当然，对手段的了解也意味着对手段的防范，在书中其实提到不少，用第三方写好，经历过检验的安全库，用设计良好的框架来保护，这也是开发的一个技巧。在安全方面，如果自己水平不够，这也是一个很好的解决方法。 文章格式有些混乱，这也是我自己的笔记习惯，阅读不便请见谅。 2021年1月15日 document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%B0%88web%E5%AE%89%E5%85%A8%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"板子","text":"板子 MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); 目录 1. 数学 1.1. gcd 1.2. exgcd 1.3. 求解线性同余方程 1.4. 欧拉定理(扩展， 不适用于矩阵) 1.5. 矩阵 1.6. 广义斐波那契数列循环节 1.7. 整除分块 1.8. 莫比乌斯反演 1.9. Lucas 1.10. 逆元 1.11. BM算法 1.12. 二次剩余 1.13. k次幂和 1.14. 杜教筛 2. 数据结构 2.1. kd树 3. dp 3.1. 区间dp 3.2. 状压dp 3.3. 数位dp 4. 计算几何 4.1. 红书 4.2. 三维向量旋转 5. 博弈 6. 图论 7. 黑科技 7.1. 高精 8. tips 该板子补充红书上没有或者替换成自己熟悉的板子 1. 数学1.1. gcd $gcd(a, b) = gcd(b, a % b)$ 等式(1) 12345678910ll gcd(ll a,ll b){ return b?gcd(b,a%b):a;}或者inline ll gcd(ll a,ll b){ if(!b) return a; while(b^=a^=b^=a%=b);//先做一次取模，然后交换两个元素 return a;} 1.2. exgcd 求解 $ax + by = c$的x的最小正整数解 首先求解$ax + by = gcd(a, b)$(2) 由等式(1)可得 $bx1 + a % b * y1 = gcd(b, a % b) = ay1 + b * (-\\lfloor \\frac{a}{b} \\rfloor +x1) * y1$ (3) 联立等式(2), (3)得到 $x=y_1, y=-\\lfloor \\frac{a}{b} \\rfloor +x1$ 将所得式子不断递归至$b=0$, 返回最后结果 1234567891011ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y){ if(b == 0) { x = 1, y = 0; return a; } ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d;} 设$d=gcd(a, b)$, 等式两边则同时乘上$\\frac{c}{d}$则可以获得一组特解 $x1=x0 * \\frac{c}{d}，y1=y0 * \\frac{c}{d}$ 每次将x0减少x，y0则相应增加$\\frac{ax}{b}$, 若需要保证y依然为正整数，则 $\\frac{ax}{b}=\\frac{a}{d}, x=\\frac{b}{d}$ 保证$0 &lt; x1 &lt; x$时，即可得到答案。 若$x &lt; 0$，则将x取绝对值 若$x0 &lt; 0$，则将x0加上x即可。 123456789d = exgcd(a, b, x, y);if(c% d== 0){ x *= c / d; t = b / d; t = abs(t); x = (x % t + t) % t; printf(\"%d\\n\", x);} 1.3. 求解线性同余方程 给出n个同余方程$N \\equiv a_1\\mod p_1, N \\equiv a_n\\mod p_n$ 求x的最小正整数解, $p_i$不互质 显然可以化为 $k1 * p1+a1=k2 * p2+a2-&gt;k1 * p1+(-k2 * p2)=a2-a1$ 设$a=p1, b=p2, x=k1, y=(-k2), c=a2-a1$方程可写为$ax+by=c$ 则问题转变为上一个题目 那么将x化为原方程的最小正整数解，$x=(x * (\\frac{c}{d})%(\\frac{b}{d})+(\\frac{b}{d}))%(\\frac{b}{d})$ 所以$N=a * (x+z * (\\frac{b}{d}))+r1-&gt;N=(\\frac{ab}{d}) * z+(a * x+r1)$ 现在只有z是未知数，所以变成$N\\equiv (a * x+r1) mod (\\frac{ab}{d}))$的问题 继续合并同余方程即可 12345678910111213141516171819202122232425ll M[55], A[55];ll China(int r){ ll dm, i, a, b, x, y, d; ll c, c1, c2; a=M[0]; c1=A[0]; for(i = 1; i &lt; r; i++){ b = M[i]; c2 = A[i]; exgcd(a, b ,d, x, y); c = c2 - c1; if(c % d) return -1;//c一定是d的倍数，如果不是，则肯定无解 dm = b / d; x = ((x * (c / d)) % dm + dm) % dm;//保证x为最小正数//c/dm是余数，系数扩大 c1 = a * x + c1; a = a * dm; } if(c1 == 0){//余数为0，说明M[]是等比数列。且余数都为0 c1 = 1; for(i = 0; i &lt; r; i++) c1 = c1 * M[i] / gcd(c1, M[i]); } return c1;} 中国剩余定理 12345678910//n个方程：x=a[i](mod m[i]) (0&lt;=i&lt;n)LL china(int n, LL *a, LL *m){ LL M = 1, ret = 0; for(int i = 0; i &lt; n; i ++) M *= m[i]; for(int i = 0; i &lt; n; i ++){ LL w = M / m[i]; ret = (ret + w * inv(w, m[i]) * a[i]) % M; } return (ret + M) % M;} 进阶: 给出k个模方程组：x mod ai = ri。求x的最小正值。如果不存在这样的x，那么输出-1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;typedef pair&lt;LL, LL&gt; PLL;LL a[100000], b[100000], m[100000];LL gcd(LL a, LL b){ return b ? gcd(b, a%b) : a;}void ex_gcd(LL a, LL b, LL &amp;x, LL &amp;y, LL &amp;d){ if (!b) {d = a, x = 1, y = 0;} else{ ex_gcd(b, a % b, y, x, d); y -= x * (a / b); }}LL inv(LL t, LL p){//如果不存在，返回-1 LL d, x, y; ex_gcd(t, p, x, y, d); return d == 1 ? (x % p + p) % p : -1;}PLL linear(LL A[], LL B[], LL M[], int n) {//求解A[i]x = B[i] (mod M[i]),总共n个线性方程组 LL x = 0, m = 1; for(int i = 0; i &lt; n; i ++) { LL a = A[i] * m, b = B[i] - A[i]*x, d = gcd(M[i], a); if(b % d != 0) return PLL(0, -1);//答案，不存在，返回-1 LL t = b/d * inv(a/d, M[i]/d)%(M[i]/d); x = x + m*t; m *= M[i]/d; } x = (x % m + m ) % m; return PLL(x, m);//返回的x就是答案，m是最后的lcm值}int main(){ int n; while(scanf(\"%d\", &amp;n) != EOF){ for(int i = 0; i &lt; n; i ++){ a[i] = 1; scanf(\"%d%d\", &amp;m[i], &amp;b[i]); } PLL ans = linear(a, b, m, n); if(ans.second == -1) printf(\"-1\\n\"); else printf(\"%I64d\\n\", ans.first); }} 1.4. 欧拉定理(扩展， 不适用于矩阵) $a^{b} \\equiv a^{b \\mod \\varphi(p)} \\mod p$ (a与p互质) $a^{b} \\equiv a^{b \\mod \\varphi(p) + \\varphi(p)} \\mod p$ (a与p不互质) 1234567891011121314151617181920212223242526272829303132ll ph(ll x){ ll res = x, a = x; for(ll i = 2; i * i &lt;= x; i++){ if(a % i == 0){ res = res / i * (i - 1); while(a % i == 0) a /= i; } } if(a &gt; 1) res = res / a * (a - 1); return res;}ll quick_pow(ll a, ll b, ll mod){ ll ans = 1; while(b) { if(b &amp; 1) ans = (ans * a) % mod; a = (a * a) % mod; b &gt;&gt;= 1; } return ans;}ll ph_pow(ll a, ll b, ll mod){ if(gcd(b, mod) == 1){ return quick_pow(a, b % (mod - 1), mod); } else { ll phi = ph(mod); return quick_pow(a, b % (phi) + phi, mod); }} 1.5. 矩阵 斐波那契数列求解 $F[n] = F[n-1] + F[n-2]$ 则可以看作矩阵$$ \\left[\\begin{matrix}F[n] \\ F[n-1]\\end{matrix} \\right] = \\left[\\begin{matrix}1&amp;1 \\ 1&amp;0\\end{matrix} \\right] * \\left[\\begin{matrix}F[n-1] \\ F[n-2]\\end{matrix} \\right]$$ 设$$A = \\left[\\begin{matrix}1&amp;1 \\ 1&amp;0\\end{matrix} \\right] B = \\left[\\begin{matrix}1 \\ 1\\end{matrix} \\right]$$, 则计算F[n]就是计算$A^{n-1}*B$, 再取出矩阵第一项即可。 上述相对应的操作在矩阵上均可运用。 1234567891011121314151617181920212223242526272829303132333435363738394041struct Matrix{ int n, m; ll a[maxn][maxn]; void clear() { n = m = 0; memset(a, 0, sizeof(a)); } void init (int x) { n = m = maxn; memset(a, 0, sizeof(a)); if(x) for(int i = 0; i &lt; 3; i++) a[i][i] = 1; } Matrix operator *(const Matrix &amp;b) const { Matrix tmp; tmp.clear(); tmp.n = n; tmp.m = b.m; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; b.m; j++) for(int k = 0; k &lt; m; k++) (tmp.a[i][j] += a[i][k] * b.a[k][j] % mod) %= mod; return tmp; } Matrix qpow(ll b) { Matrix ans, p = *this; ans.n = p.n; ans.init(1); while (b){ if (b &amp; 1) ans = ans * p; p = p * p; b &gt;&gt;= 1; } return ans; }}; 1.6. 广义斐波那契数列循环节123456789101112131415161718192021222324252627282930313233typedef long long ll;typedef __int128 i16;const int N = 1e5 + 7;int pr[N], pn;bitset&lt;N&gt; np;void init() { for(int i = 2; i &lt; N; i++) { if(!np[i]) pr[pn++] = i; for(int j = 0; j &lt; pn &amp;&amp; i * pr[j] &lt; N; j++) { np[i * pr[j]] = 1; if(i % pr[j] == 0) break; } }}ll getpp(int p) { ll ret = 1; for(int i = 0; i &lt; pn &amp;&amp; pr[i] * pr[i] &lt;= p; i++) { if(p % pr[i] == 0) { ret *= (pr[i] - 1ll) * (pr[i] + 1); p /= pr[i]; while(p % pr[i] == 0) p /= pr[i], ret *= pr[i]; } } if(p != 1) ret *= (p - 1ll) * (p + 1); return ret;}//使用方式scanf(\"%s%d\", s, &amp;mod);int len = strlen(s);ll ord = getpp(mod), r = 0;//ord为循环节长度for(int i = 0; i &lt; len; i++) { r = ((i16)r * 10 + s[i] - '0') % ord;//简化r的大小} 1.7. 整除分块正常整除分块为 $ans = (ans + ((n / l) * (r – l + 1) mod m) mod m$ 求$\\sum_{i=1}^n \\lfloor n/i\\rfloor * i^2 mod 1e9+7$ 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;typedef long long LL;const LL mod = 1e9 + 7;const LL inv = 166666668;const LL inv2 = 500000004;LL f(LL x){ return ((((x * (x + 1)) % mod) * (2 * x + 1) % mod) % mod) * inv % mod;}LL call(LL n, LL m){ LL ans = 0, ans1 = 0, t1 = ((((n * n) % mod) * (n + 1)) % mod) * inv2 % mod, t2 = ((((m * m) % mod) * (m + 1)) % mod) * inv2 % mod; for(LL l = 1, r; l &lt;= n; l = r + 1){ r = n / (n / l); LL tmp = (f(r) - f(l - 1) + mod) % mod; ans = (ans + ((n / l) * tmp) % mod) % mod; } ans = (t1 + mod - ans) % mod; for(LL l = 1, r; l &lt;= m; l = r + 1){ r = m / (m / l); LL tmp = (f(r) - f(l - 1) + mod) % mod; ans1 = (ans1 + ((m / l) * tmp) % mod) % mod; } ans1 = (t2 + mod - ans1) % mod; return (ans * ans1) % mod;}int main(){ LL n, m; while(~scanf(\"%lld %lld\", &amp;n, &amp;m)){ printf(\"%lld\\n\", call(n, m)); } return 0;} 1.8. 莫比乌斯反演 这里的ans后面少了mu函数，代码是对的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const long long MAXN=1e6+5;//线性筛法求莫比乌斯函数bool check[MAXN+10];long long prime[MAXN+10];int mu[MAXN+10];void Moblus(){ memset(check,false,sizeof(check)); mu[1] = 1; long long tot = 0; for(long long i = 2; i &lt;= MAXN; i++) { if( !check[i] ){ prime[tot++] = i; mu[i] = -1; } for(long long j = 0; j &lt; tot; j++) { if(i * prime[j] &gt; MAXN) break; check[i * prime[j]] = true; if( i % prime[j] == 0){ mu[i * prime[j]] = 0; break; }else{ mu[i * prime[j]] = -mu[i]; } } }}int main(){ Moblus(); int t; scanf(\"%d\",&amp;t); while(t--) { long long n; scanf(\"%lld\",&amp;n); long long ans=3; for(long long i=1;i&lt;=n;i++) ans+=mu[i]*(n/i)*(n/i)*(n/i+3); printf(\"%lld\\n\",ans); }} 1.9. Lucas1234567891011121314151617181920212223242526272829303132333435363738//Lucas定理实现C(n,m)%p的代码：p为素数LL exp_mod(LL a, LL b, LL p){ //快速幂取模 LL res = 1; while(b != 0) { if(b&amp;1) res = (res * a) % p; a = (a*a) % p; b &gt;&gt;= 1; } return res;}LL Comb(LL a, LL b, LL p){ //求组合数C(a,b)%p if(a &lt; b) return 0; if(a == b) return 1; if(b &gt; a - b) b = a - b; LL ans = 1, ca = 1, cb = 1; for(LL i = 0; i &lt; b; ++i) { ca = (ca * (a - i))%p; cb = (cb * (b - i))%p; } ans = (ca*exp_mod(cb, p - 2, p)) % p; return ans;}LL Lucas(LL n,LL m,LL p){ //Lucas定理求C(n,m)%p LL ans = 1; while(n&amp;&amp;m&amp;&amp;ans) { ans = (ans*Comb(n%p, m%p, p)) % p; n /= p; m /= p; } return ans;} 组合数取模 123456789typedef long long LL;const LL maxn(1000005), mod(1e9 + 7);LL Jc[maxn];void calJc() //求maxn以内的数的阶乘{ Jc[0] = Jc[1] = 1; for(LL i = 2; i &lt; maxn; i++) Jc[i] = Jc[i - 1] * i % mod;} 1.10. 逆元 费马小定理求逆元 12345678910111213141516171819202122LL pow(LL a, LL n, LL p) //快速幂 a^n % p{ LL ans = 1; while(n) { if(n &amp; 1) ans = ans * a % p; a = a * a % p; n &gt;&gt;= 1; } return ans;}LL niYuan(LL a, LL b) //费马小定理求逆元{ return pow(a, b - 2, b);}LL C(LL a, LL b) //计算C(a, b){ return Jc[a] * niYuan(Jc[b], mod) % mod * niYuan(Jc[a - b], mod) % mod;} 拓展欧几里得算法求逆元 123456789101112131415void exgcd(LL a, LL b, LL &amp;x, LL &amp;y) //拓展欧几里得算法{ if(!b) x = 1, y = 0; else { exgcd(b, a % b, y, x); y -= x * (a / b); }}LL niYuan(LL a, LL b) //求a对b取模的逆元{ LL x, y; exgcd(a, b, x, y); return (x + b) % b;} 线性求逆元 1234567891011121314#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define maxn 3000006#define LL long longusing namespace std;int n,p,inv[maxn];int main(){ scanf(\"%d%d\",&amp;n,&amp;p); inv[1]=1; for(int i=2;i&lt;=n;i++)inv[i]=(p-(LL)p/i*inv[p%i]%p)%p; for(int i=1;i&lt;=n;i++)printf(\"%d\\n\",inv[i]); return 0;} 1.11. BM算法 给出前k项，即可求出第n项，只能用于符合递推方程形式的方程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cassert&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%mod;a=a*a%mod;}return res;}// headint _;ll n;namespace linear_seq { const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt; Md; void mul(ll *a,ll *b,int k) { rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; } int solve(ll n,VI a,VI b) { // a 系数 b 初值 b[n+1]=a[0]*b[n]+... // printf(\"%d\\n\",SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) { mul(res,res,k); if ((n&gt;&gt;p)&amp;1) { for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; } } rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; } VI BM(VI s) { VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) { ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) { VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; } else { ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; } } return C; } int gao(VI a,ll n) { VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); }};int main() { for (scanf(\"%d\",&amp;_);_;_--) { scanf(\"%lld\",&amp;n); vector&lt;int&gt;a; a.push_back(1); a.push_back(3); a.push_back(5); a.push_back(7); printf(\"%d\\n\",linear_seq::gao(a,n-1)); }} 1.12. 二次剩余123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define re register#define gc getchar#define pc putchar#define puts put_s#define cs constnamespace IO{ namespace READONLY{ cs int Rlen=1&lt;&lt;18|1; char buf[Rlen],*p1,*p2; char obuf[Rlen],*p3=obuf; char ch[23]; } inline char get_char(){ using namespace READONLY; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,Rlen,stdin),p1==p2)?EOF:*p1++; } inline void put_char(cs char &amp;c){ using namespace READONLY; *p3++=c; if(p3==obuf+Rlen)fwrite(obuf,1,Rlen,stdout),p3=obuf; } inline void put_s(cs char *s){ for(;*s;++s)pc(*s); pc('\\n'); } inline void FLUSH(){ using namespace READONLY; fwrite(obuf,1,p3-obuf,stdout); p3=obuf; } inline ll getint(){ re ll num; re char c; while(!isdigit(c=gc()));num=c^48; while(isdigit(c=gc()))num=(num+(num&lt;&lt;2)&lt;&lt;1)+(c^48); return num; } inline void outint(ll a){ using namespace READONLY; if(a==0)pc('0'); if(a&lt;0)pc('-'),a=-a; while(a)ch[++ch[0]]=a-a/10*10,a/=10; while(ch[0])pc(ch[ch[0]--]^48); }}using namespace IO;namespace Linear_sieves{ cs int P=300005; int prime[P],pcnt; bool mark[P]; inline void init(int len=P-5){ mark[1]=true; for(int re i=2;i&lt;=len;++i){ if(!mark[i])prime[++pcnt]=i; for(int re j=1;j&lt;=pcnt&amp;&amp;i*prime[j]&lt;=len;++j){ mark[i*prime[j]]=true; if(i%prime[j]==0)break; } } }}namespace Find_root{ #define complex COMPLEX using namespace Linear_sieves; inline ll mul(cs ll &amp;a,cs ll &amp;b,cs ll &amp;mod){ return (a*b-(ll)((long double)a/mod*b)*mod+mod)%mod; } inline ll quickpow(ll a,ll b,cs ll &amp;mod,ll res=1){ for(;b;b&gt;&gt;=1,a=mul(a,a,mod))if(b&amp;1)res=mul(res,a,mod); return res; } inline ll ex_gcd(cs ll &amp;a,cs ll &amp;b,ll &amp;x,ll &amp;y){ if(!b){ y=0; x=1; return a; } ll t=ex_gcd(b,a-a/b*b,y,x); y-=(a/b)*x; return t; } inline ll inv(cs ll a,cs ll mod){ ll x,y; ll t=ex_gcd(a,mod,x,y); return (x%mod+mod)%mod; } ll W,Mod; class complex{ public: ll x,y; complex(cs ll &amp;_x=0,cs ll &amp;_y=0):x(_x),y(_y){} inline friend complex operator*(cs complex &amp;a,cs complex &amp;b){ return complex( (mul(a.x,b.x,Mod)+mul(mul(a.y,b.y,Mod),W,Mod))%Mod, (mul(a.x,b.y,Mod)+mul(a.y,b.x,Mod))%Mod); } }; complex quickpow(complex a,ll b){ complex res(1,0); for(;b;b&gt;&gt;=1,a=a*a)if(b&amp;1)res=res*a; return res; } inline bool isprime(ll x){ if(x&lt;=P-5)return !mark[x]; if(x%2==0||x%3==0||x%5==0||x%7==0||x%31==0||x%24251==0)return false; re ll t=x-1,s; t&gt;&gt;=(s=__builtin_ctzll(t)); for(int re i=1;i&lt;=5;++i){ re ll p=prime[rand()%pcnt+1]; re ll num=quickpow(p,t,x),pre=num; for(int re j=0;j&lt;s;++j){ num=mul(num,num,x); if(num==1&amp;&amp;pre!=x-1&amp;&amp;pre!=1)return false; pre=num; if(num==1)break; } if(num^1)return false; } return true; } inline ll Pollard_rho(ll x){ if(x%2==0)return 2; if(x%3==0)return 3; if(x%5==0)return 5; if(x%7==0)return 7; if(x%31==0)return 31; if(x%24251==0)return 24251; re ll n=0,m=0,t=1,q=1,c=rand()%(x-2)+2; for(int re k=2;;k&lt;&lt;=1,m=n,q=1){ for(int re i=1;i&lt;=k;++i){ n=(mul(n,n,x)+c)%x; q=mul(q,abs(n-m),x); } if((t=__gcd(q,x))&gt;1)return t; } } ll fact[60],cntf; inline void sieves(ll x){ if(x==1)return ; if(isprime(x)){fact[++cntf]=x;return;} re ll p=x; while(p==x)p=Pollard_rho(p); sieves(p); while(x%p==0)x/=p; sieves(x); } inline ll solve_2k(ll a,ll k){ if(a%(1&lt;&lt;k)==0)return 0; a%=(1&lt;&lt;k); re ll t=0,res=1; a&gt;&gt;=(t=__builtin_ctzll(a)); if((a&amp;7)^1)return -1; if(t&amp;1)return -1; k-=t; for(int re i=4;i&lt;=k;++i){ res=(res+(a%(1&lt;&lt;i)-res*res)/2)%(1&lt;&lt;k); } res%=1&lt;&lt;k; if(res&lt;0)res+=1&lt;&lt;k; return res&lt;&lt;(t&gt;&gt;1); } inline ll solve_p(ll a,ll p){ a%=p; if(quickpow(a,(p-1)&gt;&gt;1,p)==p-1)return -1; re ll b; Mod=p; while(true){ b=rand()%p; W=(mul(b,b,p)-a+p)%p; if(quickpow(W,(p-1)&gt;&gt;1,p)==p-1)break; } re ll ans=quickpow(complex(b,1),(p+1)&gt;&gt;1).x; return min(ans,p-ans); } inline ll solve_pk(ll a,ll k,ll p,ll mod){ if(a%mod==0)return 0; re ll t=0,hmod=1; while(a%p==0)a/=p,++t,hmod*=(t&amp;1)?p:1; if(t&amp;1)return -1; k-=t; mod/=hmod*hmod; re ll res=solve_p(a,p); if(res==-1)return -1; complex tmp(res,1); W=a; Mod=mod; tmp=quickpow(tmp,k); res=mul(tmp.x,inv(tmp.y,Mod),Mod); return res*hmod; } ll remain[20],mod[20],p; inline ll CRT(){ re ll ans=0; for(int re i=1;i&lt;=cntf;++i){ ans=(ans+mul(mul(p/mod[i],inv(p/mod[i],mod[i]),p),remain[i],p))%p; } return ans; } inline ll solve(ll a,ll pmod){ a%=pmod; cntf=0; p=pmod; sieves(pmod); if(cntf&gt;1)sort(fact+1,fact+cntf+1); if(cntf&gt;1)cntf=unique(fact+1,fact+cntf+1)-fact-1; for(int re i=1;i&lt;=cntf;++i){ re ll now=0,rmod=1; while(pmod%fact[i]==0)pmod/=fact[i],++now,rmod*=fact[i]; mod[i]=rmod; if(fact[i]==2)remain[i]=solve_2k(a,now); else remain[i]=solve_pk(a,now,fact[i],rmod); if(remain[i]==-1)return -1; } return CRT(); } #undef complex}int T;signed main(){ srand(time(0)); Linear_sieves::init(); T=getint(); const ll p = 1e9+7; while(T--){ re ll b=getint(),c=getint(),ans; ans=Find_root::solve(b * b - 4 * c,4*p); if(ans == -1){ b += p; ans=Find_root::solve(b * b - 4 * c,4*p); if(ans == -1){ printf(\"-1 -1\\n\"); continue; } } ll x = ans + b; x &gt;&gt;= 1; x %= p; ll y = (b - x + p) % p; if(x &gt; y){ swap(x, y); } printf(\"%lld %lld\\n\", x, y); } FLUSH(); return 0;} 1.13. k次幂和12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int P=1000000009;const int INV2=500000005;const int SQRT5=383008016;const int INVSQRT5=276601605;const int A=691504013;const int B=308495997;const int N=100005;ll n,K;ll fac[N],inv[N];ll pa[N],pb[N];inline void Pre(int n){ fac[0]=1; for (int i=1;i&lt;=n;i++) fac[i]=fac[i-1]*i%P; inv[1]=1; for (int i=2;i&lt;=n;i++) inv[i]=(P-P/i)*inv[P%i]%P; inv[0]=1; for (int i=1;i&lt;=n;i++) inv[i]=inv[i]*inv[i-1]%P; pa[0]=1; for (int i=1;i&lt;=n;i++) pa[i]=pa[i-1]*A%P; pb[0]=1; for (int i=1;i&lt;=n;i++) pb[i]=pb[i-1]*B%P;}inline ll C(int n,int m){ return fac[n]*inv[m]%P*inv[n-m]%P;}inline ll Pow(ll a,ll b){ ll ret=1; for (;b;b&gt;&gt;=1,a=a*a%P) if (b&amp;1) ret=ret*a%P; return ret;}inline ll Inv(ll x){ return Pow(x,P-2);}inline void Solve(){ ll Ans=0; for (int j=0;j&lt;=K;j++){ ll t=pa[K-j]*pb[j]%P,tem; tem=t==1?n%P:t*(Pow(t,n)-1+P)%P*Inv(t-1)%P; if (~j&amp;1) Ans+=C(K,j)*tem%P,Ans%=P; else Ans+=P-C(K,j)*tem%P,Ans%=P; } Ans=Ans*Pow(INVSQRT5,K)%P; printf(\"%lld\\n\",Ans);}int main(){ int T; freopen(\"t.in\",\"r\",stdin); freopen(\"t.out\",\"w\",stdout); Pre(100000); scanf(\"%d\",&amp;T); while (T--){ scanf(\"%lld%lld\",&amp;n,&amp;K); Solve(); } return 0;} 1.14. 杜教筛 筛$\\mu$和$\\varphi$的板子,根据内存来限制先预处理多少 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define N 6000010using namespace std;template&lt;typename T&gt;inline void read(T &amp;x){ x=0; static int p;p=1; static char c;c=getchar(); while(!isdigit(c)){if(c=='-')p=-1;c=getchar();} while(isdigit(c)) {x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c-48);c=getchar();} x*=p;}bool vis[N];int mu[N],sum1[N],phi[N];long long sum2[N];int cnt,prim[N];tr1::unordered_map&lt;long long,long long&gt;w1;tr1::unordered_map&lt;int,int&gt;w;void get(int maxn){ phi[1]=mu[1]=1; for(int i=2;i&lt;=maxn;i++) { if(!vis[i]) { prim[++cnt]=i; mu[i]=-1;phi[i]=i-1; } for(int j=1;j&lt;=cnt&amp;&amp;prim[j]*i&lt;=maxn;j++) { vis[i*prim[j]]=1; if(i%prim[j]==0) { phi[i*prim[j]]=phi[i]*prim[j]; break; } else mu[i*prim[j]]=-mu[i],phi[i*prim[j]]=phi[i]*(prim[j]-1); } } for(int i=1;i&lt;=maxn;i++)sum1[i]=sum1[i-1]+mu[i],sum2[i]=sum2[i-1]+phi[i];}int djsmu(int x){ if(x&lt;=6000000)return sum1[x]; if(w[x])return w[x]; int ans=1; for(int l=2,r;l&gt;=0&amp;&amp;l&lt;=x;l=r+1) { r=x/(x/l); ans-=(r-l+1)*djsmu(x/l); } return w[x]=ans;}long long djsphi(long long x){ if(x&lt;=6000000)return sum2[x]; if(w1[x])return w1[x]; long long ans=x*(x+1)/2; for(long long l=2,r;l&lt;=x;l=r+1) { r=x/(x/l); ans-=(r-l+1)*djsphi(x/l); } return w1[x]=ans;}int main(){ int t,n; read(t); get(6000000); while(t--) { read(n); printf(\"%lld %d\\n\",djsphi(n),djsmu(n)); } return 0;} 2. 数据结构2.1. kd树 x维数为2的KDtree模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL INF = 0x3f3f3f3f3f3f3f3f;const int MAXN = 1e5 + 10;struct Node { int lson, rson; LL Min[2], Max[2], x[2]; int id;} kdt[MAXN &lt;&lt; 1], tmp;int root, cmp_x;LL ans, xx0, xx1;bool cmp (const Node &amp;a, const Node &amp;b) { return a.x[cmp_x] &lt; b.x[cmp_x] || (a.x[cmp_x] == b.x[cmp_x] &amp;&amp; a.x[cmp_x^1] &lt; b.x[cmp_x^1]);}// 更新每个结点的边界信息void pushUp(int u, int v) { for (int i = 0; i &lt; 2; i++) kdt[u].Min[i] = min(kdt[u].Min[i], kdt[v].Min[i]); for (int i = 0; i &lt; 2; i++) kdt[u].Max[i] = max(kdt[u].Max[i], kdt[v].Max[i]);}int kdtBuild(int l, int r, int X) { int mid = (l + r) &gt;&gt; 1; kdt[mid].lson = kdt[mid].rson = 0; cmp_x = X; nth_element(kdt + l + 1, kdt + mid + 1, kdt + r + 1, cmp); // 将编号为mid的元素放在中间，比它小的放在前面，比它大的放后面 kdt[mid].Min[0] = kdt[mid].Max[0] = kdt[mid].x[0]; kdt[mid].Min[1] = kdt[mid].Max[1] = kdt[mid].x[1]; if (l != mid) kdt[mid].lson = kdtBuild(l, mid - 1, X ^ 1); if (r != mid) kdt[mid].rson = kdtBuild(mid + 1, r, X ^ 1); if (kdt[mid].lson) pushUp(mid, kdt[mid].lson); if (kdt[mid].rson) pushUp(mid, kdt[mid].rson); return mid;}// 插入新的结点void kdtInsert(int now) { int X = 0, p = root; while (true) { pushUp(p, now); if (kdt[now].x[X] &lt; kdt[p].x[X]) { if (!kdt[p].lson) { kdt[p].lson = now; return; } else p = kdt[p].lson; } else { if (!kdt[p].rson) { kdt[p].rson = now; return; } else p = kdt[p].rson; } }}// 点(x,y)在结点id的边界范围内能得到的最大距离上界LL getMaxDis(int id, LL x0, LL x1) { LL res = 0; if (x0 &lt; kdt[id].Min[0]) res += (kdt[id].Min[0] - x0) * (kdt[id].Min[0] - x0); if (x0 &gt; kdt[id].Max[0]) res += (kdt[id].Max[0] - x0) * (kdt[id].Max[0] - x0); if (x1 &lt; kdt[id].Min[1]) res += (kdt[id].Min[1] - x1) * (kdt[id].Min[1] - x1); if (x1 &gt; kdt[id].Max[1]) res += (kdt[id].Max[1] - x1) * (kdt[id].Max[1] - x1); return res;}LL dist(int id, LL x0, LL x1) { return (kdt[id].x[0] - x0) * (kdt[id].x[0] - x0) + (kdt[id].x[1] - x1) * (kdt[id].x[1] - x1);}void kdtQuery(int p) { LL dl = INF, dr = INF, d; d = dist(p, xx0, xx1); if (kdt[p].x[0] == xx0 &amp;&amp; kdt[p].x[1] == xx1) d = INF; // 查询(x,y)时要将(x,y)到自己的距离设为INF ans = min(ans, d); if (kdt[p].lson) dl = getMaxDis(kdt[p].lson, xx0, xx1); if (kdt[p].rson) dr = getMaxDis(kdt[p].rson, xx0, xx1); if (dl &lt; dr) { if (dl &lt; ans) kdtQuery(kdt[p].lson); if (dr &lt; ans) kdtQuery(kdt[p].rson); } else { if (dr &lt; ans) kdtQuery(kdt[p].rson); if (dl &lt; ans) kdtQuery(kdt[p].lson); }}LL answer[MAXN];int main() { //freopen(\"in.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) { int n; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(\"%I64d%I64d\", &amp;kdt[i].x[0], &amp;kdt[i].x[1]); kdt[i].id = i; } root = kdtBuild(1, n, 0); for (int i = 1; i &lt;= n; i++) { ans = INF; xx0 = kdt[i].x[0]; xx1 = kdt[i].x[1]; kdtQuery(root); answer[kdt[i].id] = ans; // printf(\"---%d\\n\", ans); } for (int i = 1; i &lt;= n; i++) printf(\"%I64d\\n\", answer[i]); } return 0;} 3. dp3.1. 区间dp1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define mst(a,b) memset((a),(b),sizeof(a))#define rush() int T;scanf(\"%d\",&amp;T);while(T--)typedef long long ll;const int maxn = 205;const ll mod = 1e9+7;const ll INF = 1e18;const double eps = 1e-9;int n,x;int sum[maxn];int dp[maxn][maxn];int main(){ while(~scanf(\"%d\",&amp;n)) { sum[0]=0; mst(dp,0x3f); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;x); sum[i]=sum[i-1]+x; dp[i][i]=0; } for(int len=2;len&lt;=n;len++) for(int i=1;i&lt;=n;i++) { int j=i+len-1; if(j&gt;n) continue; for(int k=i;k&lt;j;k++) { dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]); } } printf(\"%d\\n\",dp[1][n]); } return 0;} 3.2. 状压dp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int RD(){ int out = 0,flag = 1;char c = getchar(); while(c &lt; '0' || c &gt;'9'){if(c == '-')flag = -1;c = getchar();} while(c &gt;= '0' &amp;&amp; c &lt;= '9'){out = out * 10 + c - '0';c = getchar();} return flag * out; }const int maxn = 2048;int num,m,numd;struct Node{ int dp,step; };int vis[maxn];int map[maxn][maxn];void BFS(int n){ queue&lt;Node&gt;Q; Node fir;fir.step = 0,fir.dp = n;//初始状态入队 Q.push(fir); while(!Q.empty()){//BFS Node u = Q.front(); Q.pop(); int pre = u.dp; for(int i = 1;i &lt;= m;i++){//枚举每个操作 int now = pre; for(int j = 1;j &lt;= num;j++){ if(map[i][j] == 1){ if( (1 &lt;&lt; (j - 1)) &amp; now){ now = now ^ (1 &lt;&lt; (j - 1));//对状态进行操作 } } else if(map[i][j] == -1){ now = ( (1 &lt;&lt; (j - 1) ) | now);//对状态进行操作 } } fir.dp = now,fir.step = u.step + 1;//记录步数 if(vis[now] == true){ continue; } if(fir.dp == 0){//达到目标状态 vis[0] = true;//相当于一个标记flag cout&lt;&lt;fir.step&lt;&lt;endl;//输出 return ;//退出函数 } Q.push(fir);//新状态入队 vis[now] = true;//表示这个状态操作过了（以后在有这个状态就不用试了） } } }int main(){ num = RD();m = RD(); int n = (1 &lt;&lt; (num)) - 1; for(int i = 1;i &lt;= m;i++){ for(int j = 1;j &lt;= num;j++){ map[i][j] = RD(); } } BFS(n); if(vis[0] == false) cout&lt;&lt;-1&lt;&lt;endl; return 0;} 3.3. 数位dp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849typedef long long ll; int a[20]; ll dp[20][state];//不同题目状态不同ll dfs(int pos,/*state变量*/,bool lead/*前导零*/,bool limit/*数位上界变量*/)//不是每个题都要判断前导零 { //递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了 if(pos==-1) return 1;/*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。不过具体题目不同或者写法不同的话不一定要返回1 */ //第二个就是记忆化(在此前可能不同题目还能有一些剪枝) if(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=-1) return dp[pos][state]; /*常规写法都是在没有限制的条件记忆化，这里与下面记录状态是对应，具体为什么是有条件的记忆化后面会讲*/ int up=limit?a[pos]:9;//根据limit判断枚举的上界up;这个的例子前面用213讲过了 ll ans=0; //开始计数 for(int i=0;i&lt;=up;i++)//枚举，然后把不同情况的个数加到ans就可以了 { if() ... else if()... ans+=dfs(pos-1,/*状态转移*/,lead &amp;&amp; i==0,limit &amp;&amp; i==a[pos]) //最后两个变量传参都是这样写的 /*这里还算比较灵活，不过做几个题就觉得这里也是套路了 大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论 去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目 要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类， 前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/ } //计算完，记录状态 if(!limit &amp;&amp; !lead) dp[pos][state]=ans; /*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/ return ans; } ll solve(ll x) { int pos=0; while(x)//把数位都分解出来 { a[pos++]=x%10;//个人老是喜欢编号为[0,pos),看不惯的就按自己习惯来，反正注意数位边界就行 x/=10; } return dfs(pos-1/*从最高位开始枚举*/,/*一系列状态 */,true,true);//刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛 } int main() { ll le,ri; while(~scanf(\"%lld%lld\",&amp;le,&amp;ri)) { //初始化dp数组为-1,这里还有更加优美的优化,后面讲 printf(\"%lld\\n\",solve(ri)-solve(le-1)); } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;typedef long long ll;int a[20];ll dp[20][2];ll dfs(int pos, int pre, int state, bool limit)//不是每个题都要判断前导零{ if(pos==-1) return 1; if(!limit &amp;&amp; dp[pos][state]!=-1) return dp[pos][state]; int up=limit?a[pos]:9; ll ans=0; for(int i=0;i&lt;=up;i++) { if(i == 4) continue; else if(pre == 6 &amp;&amp; i == 2) continue; ans+=dfs(pos-1, i, i == 6 ? 1 : 0, limit &amp;&amp; i==a[pos]); } if(!limit) dp[pos][state]=ans; return ans;}ll solve(ll x){ int pos=0; while(x) { a[pos++]=x%10; x/=10; } return dfs(pos - 1, 0, 0, true);}int main(){ ll le,ri; while(~scanf(\"%lld%lld\",&amp;le,&amp;ri) &amp;&amp; (le || ri)) { memset(dp, -1, sizeof(dp)); printf(\"%lld\\n\",solve(ri)-solve(le-1)); } return 0;} 4. 计算几何4.1. 红书4.2. 三维向量旋转1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;#define eps 1e-10#define pi acos(-1.0)using namespace std;int dcmp(double x){if (fabs(x)&lt;eps)return 0;else return x&lt;0?-1:1;}struct Point3{ double x,y,z; Point3(double x=0,double y=0,double z=0):x(x),y(y),z(z){};};typedef Point3 Vector3;Vector3 operator + (Vector3 a,Vector3 b){return Vector3(a.x+b.x,a.y+b.y,a.z+b.z);}Vector3 operator - (Vector3 a,Vector3 b){return Vector3(a.x-b.x,a.y-b.y,a.z-b.z);}Vector3 operator * (Vector3 a,double b){return Vector3(a.x*b,a.y*b,a.z*b);}Vector3 operator / (Vector3 a,double b){return Vector3(a.x/b,a.y/b,a.z/b);}bool operator == (Vector3 a,Vector3 b){return a.x==b.x &amp;&amp; a.y==b.y &amp;&amp; a.z==b.z;}double Dot3(Vector3 a,Vector3 b){return a.x*b.x+a.y*b.y+a.z*b.z;} //点积double Length3(Vector3 a){return sqrt(Dot3(a,a));}Vector3 Cross3(Vector3 a,Vector3 b) //叉积{return Vector3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);}double Angle3(Vector3 a,Vector3 b){return acos(Dot3(a,b)/Length3(a)/Length3(b));}// 范围[0,180]//点到线段的距离double DistanceToSeg3(Point3 p,Point3 a,Point3 b){ if(a==b) return Length3(p-a); Vector3 v1=b-a,v2=p-a,v3=p-b; if(dcmp(Dot3(v1,v2))&lt;0) return Length3(v2); else if(dcmp(Dot3(v1,v3))&gt;0) return Length3(v3); else return Length3(Cross3(v1,v2))/Length3(v1);}//点p绕向量ov旋转ang角度，旋转方向是向量ov叉乘向量opPoint3 rotate3(Point3 p,Vector3 v,double ang){ double ret[3][3],a[3]; v = v / Length3(v); ret[0][0] = (1.0 - cos(ang)) * v.x * v.x + cos(ang); ret[0][1] = (1.0 - cos(ang)) * v.x * v.y - sin(ang) * v.z; ret[0][2] = (1.0 - cos(ang)) * v.x * v.z + sin(ang) * v.y; ret[1][0] = (1.0 - cos(ang)) * v.y * v.x + sin(ang) * v.z; ret[1][1] = (1.0 - cos(ang)) * v.y * v.y + cos(ang); ret[1][2] = (1.0 - cos(ang)) * v.y * v.z - sin(ang) * v.x; ret[2][0] = (1.0 - cos(ang)) * v.z * v.x - sin(ang) * v.y; ret[2][1] = (1.0 - cos(ang)) * v.z * v.y + sin(ang) * v.x; ret[2][2] = (1.0 - cos(ang)) * v.z * v.z + cos(ang); for (int i=0;i&lt;3;i++) a[i]=ret[i][0]*p.x+ret[i][1]*p.y+ret[i][2]*p.z; return Point3(a[0],a[1],a[2]);}Point3 face,head,st,en,a,vx=Point3(1,0,0),vy=Point3(0,1,0),vz=Point3(0,0,1);int main(){ int T,n; scanf(\"%d\",&amp;T); while (T--) { double ans=1e8,ang,dx,dy,dz,d; char x[3]; face=Point3(1,0,0); head=Point3(0,0,1); scanf(\"%lf%lf%lf\",&amp;st.x,&amp;st.y,&amp;st.z); scanf(\"%lf%lf%lf\",&amp;en.x,&amp;en.y,&amp;en.z); scanf(\"%d\",&amp;n); while (n--) { scanf(\"%lf %s %lf\",&amp;d,x,&amp;ang); dx=d*cos(Angle3(vx,face)); dy=d*cos(Angle3(vy,face)); dz=d*cos(Angle3(vz,face)); a=st+Point3(dx,dy,dz); ans=min(ans,DistanceToSeg3(en,st,a)); st=a; if (x[0]=='U') { Vector3 v=Cross3(face,head); face=rotate3(face,v,ang); head=rotate3(head,v,ang); }else if (x[0]=='D') { Vector3 v=Cross3(head,face); face=rotate3(face,v,ang); head=rotate3(head,v,ang); }else if (x[0]=='L') { face=rotate3(face,head,ang); }else if (x[0]=='R') { Vector3 v=head*(-1); face=rotate3(face,v,ang); } } printf(\"%.2f\\n\",ans); } return 0;} 5. 博弈6. 图论7. 黑科技7.1. 高精123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145struct Wint:vector&lt;int&gt;{ Wint(int n=0) { push_back(n); check(); } Wint&amp; check() { while(!empty()&amp;&amp;!back())pop_back(); if(empty())return *this; for(int i=1; i&lt;size(); ++i) { (*this)[i]+=(*this)[i-1]/10; (*this)[i-1]%=10; } while(back()&gt;=10) { push_back(back()/10); (*this)[size()-2]%=10; } return *this; }};istream&amp; operator&gt;&gt;(istream &amp;is,Wint &amp;n){ string s; is&gt;&gt;s; n.clear(); for(int i=s.size()-1; i&gt;=0; --i)n.push_back(s[i]-'0'); return is;}ostream&amp; operator&lt;&lt;(ostream &amp;os,const Wint &amp;n){ if(n.empty())os&lt;&lt;0; for(int i=n.size()-1; i&gt;=0; --i)os&lt;&lt;n[i]; return os;}bool operator!=(const Wint &amp;a,const Wint &amp;b){ if(a.size()!=b.size())return 1; for(int i=a.size()-1; i&gt;=0; --i) if(a[i]!=b[i])return 1; return 0;}bool operator==(const Wint &amp;a,const Wint &amp;b){ return !(a!=b);}bool operator&lt;(const Wint &amp;a,const Wint &amp;b){ if(a.size()!=b.size())return a.size()&lt;b.size(); for(int i=a.size()-1; i&gt;=0; --i) if(a[i]!=b[i])return a[i]&lt;b[i]; return 0;}bool operator&gt;(const Wint &amp;a,const Wint &amp;b){ return b&lt;a;}bool operator&lt;=(const Wint &amp;a,const Wint &amp;b){ return !(a&gt;b);}bool operator&gt;=(const Wint &amp;a,const Wint &amp;b){ return !(a&lt;b);}Wint&amp; operator+=(Wint &amp;a,const Wint &amp;b){ if(a.size()&lt;b.size())a.resize(b.size()); for(int i=0; i!=b.size(); ++i)a[i]+=b[i]; return a.check();}Wint operator+(Wint a,const Wint &amp;b){ return a+=b;}Wint&amp; operator-=(Wint &amp;a,Wint b){ if(a&lt;b)swap(a,b); for(int i=0; i!=b.size(); a[i]-=b[i],++i) if(a[i]&lt;b[i]) { int j=i+1; while(!a[j])++j; while(j&gt;i) { --a[j]; a[--j]+=10; } } return a.check();}Wint operator-(Wint a,const Wint &amp;b){ return a-=b;}Wint operator*(const Wint &amp;a,const Wint &amp;b){ Wint n; n.assign(a.size()+b.size()-1,0); for(int i=0; i!=a.size(); ++i) for(int j=0; j!=b.size(); ++j) n[i+j]+=a[i]*b[j]; return n.check();}Wint&amp; operator*=(Wint &amp;a,const Wint &amp;b){ return a=a*b;}Wint divmod(Wint &amp;a,const Wint &amp;b){ Wint ans; for(int t=a.size()-b.size(); a&gt;=b; --t) { Wint d; d.assign(t+1,0); d.back()=1; Wint c=b*d; while(a&gt;=c) { a-=c; ans+=d; } } return ans;}Wint operator/(Wint a,const Wint &amp;b){ return divmod(a,b);}Wint&amp; operator/=(Wint &amp;a,const Wint &amp;b){ return a=a/b;}Wint&amp; operator%=(Wint &amp;a,const Wint &amp;b){ divmod(a,b); return a;}Wint operator%(Wint a,const Wint &amp;b){ return a%=b;} 8. tips 唯一分解定理：n的因子个数Num(n) = (1 + a1) * (1 + a2) * … * (1 + an)a &gt; b 且 gcd(a, b) == 1, 有$(gcd(a^n - b^n, a^m - b^m)) = a^{gcd(n, m)} - b^{gcd(n, m)}$$\\mu(n)$——莫比乌斯函数$\\varphi(n)$——欧拉函数。表示不大于n且与n互质的正整数个数，十分常见的数论函数。用数学式子表示即：$\\varphi(n)=\\sum_{i=1}^{n}[gcd(n,i) == 1]$$d(n)$——约数个数。表示n的约数的个数。用式子表示为:$d(n)=\\sum_{d|n}1$,也可以写作:$d(n)=\\sum_{d=1}^{n}[d|n]$$\\sigma(n)$——约数和函数。即n的各个约数之和。表示为$\\sigma(n)=\\sum_{d|n}d=\\sum_{d=1}^{n}[d|n] * d$ document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Science/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"诗句","slug":"诗句","link":"/tags/%E8%AF%97%E5%8F%A5/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"基础","slug":"基础","link":"/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Introduction","slug":"Introduction","link":"/tags/Introduction/"},{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"模板","slug":"模板","link":"/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"C++Primer","slug":"C-Primer","link":"/tags/C-Primer/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"面向面试编程","slug":"面向面试编程","link":"/tags/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E7%BC%96%E7%A8%8B/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"容器化","slug":"容器化","link":"/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"编译原理","slug":"编译原理","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"GO","slug":"GO","link":"/tags/GO/"},{"name":"分布式","slug":"分布式","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"做题家","slug":"做题家","link":"/tags/%E5%81%9A%E9%A2%98%E5%AE%B6/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"汇编","slug":"汇编","link":"/tags/%E6%B1%87%E7%BC%96/"},{"name":"安全","slug":"安全","link":"/tags/%E5%AE%89%E5%85%A8/"}],"categories":[{"name":"Romance","slug":"Romance","link":"/categories/Romance/"},{"name":"Science","slug":"Science","link":"/categories/Science/"},{"name":"Ego","slug":"Ego","link":"/categories/Ego/"}]}